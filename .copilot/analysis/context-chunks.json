{
  "GeneratedAt": "2026-01-06T00:30:09Z",
  "ChunkSettings": {
    "MaxTokens": 2000,
    "MaxChars": 8000,
    "TokenHeuristic": "approxTokens = chars / 4"
  },
  "Chunks": [
    {
      "path": "./src/core/config/index.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 98,
      "chars": 2398,
      "approxTokens": 600.0,
      "sha256": "F2C862663333A5942078195B17B34335FF25F20655115C867B7649DEDCE42307",
      "content": "/**\n * Configuration loader and validator\n *\n * @module core/config\n */\n\nimport { z } from 'zod';\nimport { ConfigurationError } from '../errors/index.js';\n\n/**\n * Property configuration schema\n */\nconst PropertyConfigSchema = z.object({\n  type: z.string(),\n  required: z.boolean().optional(),\n  target: z.string().optional(),\n  options: z.array(z.string()).optional(),\n  computed: z.boolean().optional(),\n});\n\n/**\n * Database configuration schema\n */\nconst DatabaseConfigSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  url: z.string().optional(),\n  properties: z.record(z.string(), PropertyConfigSchema).optional(),\n});\n\n/**\n * Safety limits schema\n */\nconst SafetyLimitsSchema = z.object({\n  maxBatchSize: z.number().int().positive(),\n  rateLimitPerSecond: z.number().positive(),\n  requireApprovalForBulk: z.boolean(),\n});\n\n/**\n * MCP configuration schema\n */\nconst McpConfigSchema = z.object({\n  serverCommand: z.string(),\n  serverArgs: z.array(z.string()),\n  defaultTimeout: z.number().int().positive(),\n  maxRetries: z.number().int().nonnegative(),\n});\n\n/**\n * Full configuration schema\n */\nconst ConfigSchema = z.object({\n  databases: z.record(z.string(), DatabaseConfigSchema),\n  safetyLimits: SafetyLimitsSchema,\n  mcp: McpConfigSchema,\n});\n\n/**\n * Configuration type\n */\nexport type Config = z.infer<typeof ConfigSchema>;\nexport type DatabaseConfig = z.infer<typeof DatabaseConfigSchema>;\nexport type SafetyLimits = z.infer<typeof SafetyLimitsSchema>;\nexport type McpConfig = z.infer<typeof McpConfigSchema>;\n\n/**\n * Load and validate configuration from JSON\n */\nexport function loadConfig(configData: unknown): Config {\n  try {\n    return ConfigSchema.parse(configData);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const errorDetails = error.errors.map((e) => `${e.path.join('.')}: ${e.message}`).join(', ');\n      throw new ConfigurationError(`Invalid configuration: ${errorDetails}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get database configuration by key\n */\nexport function getDatabaseConfig(config: Config, key: string): DatabaseConfig {\n  const dbConfig = config.databases[key];\n  if (!dbConfig) {\n    throw new ConfigurationError(`Database configuration not found: ${key}`);\n  }\n  return dbConfig;\n}\n\n/**\n * Get database ID by key\n */\nexport function getDatabaseId(config: Config, key: string): string {\n  return getDatabaseConfig(config, key).id;\n}"
    },
    {
      "path": "./src/core/config/__tests__/config.test.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 87,
      "chars": 2561,
      "approxTokens": 640.0,
      "sha256": "28603C6E37CF0C6C6D630F14D181B5E20D5A275A0C68E4C5963B973D03695161",
      "content": "import { describe, it, expect } from 'vitest';\nimport { loadConfig, getDatabaseConfig, getDatabaseId } from '../index.js';\nimport { ConfigurationError } from '../../errors/index.js';\n\ndescribe('Config', () => {\n  const validConfig = {\n    databases: {\n      teams: {\n        id: 'test-id',\n        name: 'Teams',\n        url: 'https://notion.so/test',\n        properties: {\n          name: {\n            type: 'title',\n            required: true,\n          },\n        },\n      },\n    },\n    safetyLimits: {\n      maxBatchSize: 50,\n      rateLimitPerSecond: 3,\n      requireApprovalForBulk: true,\n    },\n    mcp: {\n      serverCommand: 'npx',\n      serverArgs: ['-y', '@notionhq/notion-mcp-server'],\n      defaultTimeout: 30000,\n      maxRetries: 3,\n    },\n  };\n\n  describe('loadConfig', () => {\n    it('should load valid configuration', () => {\n      const config = loadConfig(validConfig);\n      expect(config).toBeDefined();\n      expect(config.databases.teams).toBeDefined();\n      expect(config.safetyLimits.maxBatchSize).toBe(50);\n    });\n\n    it('should reject invalid configuration', () => {\n      const invalidConfig = {\n        databases: {},\n        safetyLimits: {\n          maxBatchSize: -1,\n          rateLimitPerSecond: 3,\n          requireApprovalForBulk: true,\n        },\n      };\n      expect(() => loadConfig(invalidConfig)).toThrow(ConfigurationError);\n    });\n\n    it('should reject configuration with missing required fields', () => {\n      const incompleteConfig = {\n        databases: {},\n      };\n      expect(() => loadConfig(incompleteConfig)).toThrow(ConfigurationError);\n    });\n  });\n\n  describe('getDatabaseConfig', () => {\n    it('should get database configuration by key', () => {\n      const config = loadConfig(validConfig);\n      const dbConfig = getDatabaseConfig(config, 'teams');\n      expect(dbConfig.id).toBe('test-id');\n      expect(dbConfig.name).toBe('Teams');\n    });\n\n    it('should throw error for non-existent database', () => {\n      const config = loadConfig(validConfig);\n      expect(() => getDatabaseConfig(config, 'nonexistent')).toThrow(ConfigurationError);\n    });\n  });\n\n  describe('getDatabaseId', () => {\n    it('should get database ID by key', () => {\n      const config = loadConfig(validConfig);\n      const id = getDatabaseId(config, 'teams');\n      expect(id).toBe('test-id');\n    });\n\n    it('should throw error for non-existent database', () => {\n      const config = loadConfig(validConfig);\n      expect(() => getDatabaseId(config, 'nonexistent')).toThrow(ConfigurationError);\n    });\n  });\n});"
    },
    {
      "path": "./src/core/constants/databases.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 27,
      "chars": 1217,
      "approxTokens": 304.0,
      "sha256": "FD2EE20767C07ECAB17CD0F32AAF818D6027786F1F3C1734668623022DCEE54B",
      "content": "/**\n * Database IDs for Digital Herencia Notion workspace\n */\nexport const DATABASE_IDS = {\n  TEAMS: '2d5a4e63-bf23-8151-9b98-c81833668844',\n  PROJECTS: '2d5a4e63-bf23-81b1-b507-f5ac308958e6',\n  TASKS: '2d5a4e63-bf23-816f-a217-ef754ce4a70e',\n  MEETINGS: '2d5a4e63-bf23-8168-af99-d85e20bfb76f',\n  PROMPTS: '2d5a4e63-bf23-81fa-9ca8-f6368bcda19a',\n  TECH_STACK: '276a4e63-bf23-80e2-bbae-000b2fa9662a',\n  TEMPLATES: '2d5a4e63-bf23-8162-8db4-fcce1bbe3471',\n  SOPS: '2d8a4e63-bf23-801e-b6ac-e52358ee91dc',\n  CALENDAR: '2d5a4e63-bf23-8130-acc7-f5ee01d15f22',\n} as const;\n\nexport type DatabaseId = (typeof DATABASE_IDS)[keyof typeof DATABASE_IDS];\n\n/**\n * Property type definitions matching Notion schema\n */\nexport type ProjectStatus = 'Active' | 'Completed' | 'On Hold' | 'Cancelled';\nexport type Milestone = 'M1' | 'M2' | 'M3';\nexport type Phase = 'P1.1' | 'P1.2' | 'P1.3' | 'P2.1' | 'P2.2' | 'P2.3' | 'P3.1' | 'P3.2' | 'P3.3';\nexport type Domain = 'OPS' | 'PROD' | 'DES' | 'ENG' | 'MKT' | 'RES';\nexport type Priority = 'High' | 'Medium' | 'Low';\nexport type MeetingType = 'Standup' | 'Sprint Planning' | 'Post-mortem' | 'Team Sync' | 'Ad Hoc';\nexport type Cadence = 'Daily' | 'Weekly' | 'Biweekly' | 'Monthly' | 'Ad Hoc';"
    },
    {
      "path": "./src/core/constants/index.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 44,
      "chars": 839,
      "approxTokens": 210.0,
      "sha256": "4980F0C74E91AE2E3BEEF0E8ED6CC027D473DAEB497CF2CAF80B65FEBB2C8193",
      "content": "/**\n * MCP configuration constants\n */\n\nexport const MCP_DEFAULTS = {\n  TIMEOUT: 30000, // 30 seconds\n  MAX_RETRIES: 3,\n  RATE_LIMIT_PER_SECOND: 3,\n  RETRY_BACKOFF_BASE: 1000, // 1 second\n  RETRY_BACKOFF_MAX: 10000, // 10 seconds\n} as const;\n\n/**\n * Database IDs\n */\nexport { DATABASE_IDS } from './databases.js';\n\n/**\n * Notion API constants\n */\n\nexport const NOTION_LIMITS = {\n  MAX_PAGE_SIZE: 100,\n  MAX_BATCH_SIZE: 50,\n} as const;\n\n/**\n * MCP server configuration\n */\nexport const MCP_SERVER = {\n  COMMAND: 'npx',\n  ARGS: ['-y', '@notionhq/notion-mcp-server'],\n  PACKAGE: '@notionhq/notion-mcp-server',\n} as const;\n\nexport const JSON_RPC_VERSION = '2.0';\n\nexport const JSON_RPC_ERROR_CODES = {\n  PARSE_ERROR: -32700,\n  INVALID_REQUEST: -32600,\n  METHOD_NOT_FOUND: -32601,\n  INVALID_PARAMS: -32602,\n  INTERNAL_ERROR: -32603,\n} as const;"
    },
    {
      "path": "./src/core/errors/index.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 181,
      "chars": 4262,
      "approxTokens": 1066.0,
      "sha256": "B601B28E2A9CC58D306A9E55EA7889E8E32482C0757B29457F128F909AA176D4",
      "content": "/**\n * Base error class for all Notionista errors\n */\nexport class NotionistaError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Error thrown when a repository operation fails\n */\nexport class RepositoryError extends NotionistaError {\n  constructor(message: string, code = 'REPOSITORY_ERROR') {\n    super(message, code);\n  }\n}\n\n/**\n * Error thrown when an entity is not found\n */\nexport class EntityNotFoundError extends RepositoryError {\n  constructor(entityType: string, id: string) {\n    super(`${entityType} with id '${id}' not found`, 'ENTITY_NOT_FOUND');\n  }\n}\n\n/**\n * Error thrown when validation fails\n */\nexport class ValidationError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly errors: Array<{ field: string; message: string }>\n  ) {\n    super(message, 'VALIDATION_ERROR');\n  }\n}\n\n/**\n * Error thrown when a proposal is not found\n */\nexport class ProposalNotFoundError extends NotionistaError {\n  constructor(proposalId: string) {\n    super(`Proposal '${proposalId}' not found`, 'PROPOSAL_NOT_FOUND');\n  }\n}\n\n/**\n * Error thrown when batch size exceeds limit\n */\nexport class BatchLimitExceededError extends NotionistaError {\n  constructor(actual: number, limit: number) {\n    super(`Batch size ${actual} exceeds limit of ${limit}`, 'BATCH_LIMIT_EXCEEDED');\n  }\n}\n\n/**\n * Error thrown when MCP operation fails\n */\nexport class McpError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly operation: string\n  ) {\n    super(message, 'MCP_ERROR');\n  }\n}\n\n/**\n * Error thrown when configuration is invalid\n */\nexport class ConfigurationError extends NotionistaError {\n  constructor(message: string) {\n    super(message, 'CONFIGURATION_ERROR');\n  }\n}\n\n/**\n * Error thrown when MCP transport operation fails\n */\nexport class McpTransportError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message, 'MCP_TRANSPORT_ERROR');\n  }\n}\n\n/**\n * Error thrown when MCP connection fails\n */\nexport class McpConnectionError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly details?: unknown\n  ) {\n    super(message, 'MCP_CONNECTION_ERROR');\n  }\n}\n\n// Backward compatibility error classes with specific codes\n/**\n * NotionError - Alias for NotionistaError with additional details support\n */\nexport class NotionError extends NotionistaError {\n  constructor(\n    message: string,\n    code: string,\n    public readonly details?: unknown\n  ) {\n    super(message, code);\n  }\n}\n\n/**\n * TransportError - Error for transport layer failures\n */\nexport class TransportError extends NotionistaError {\n  constructor(message: string) {\n    super(message, 'TRANSPORT_ERROR');\n  }\n}\n\n/**\n * TimeoutError - Error for timeout failures\n */\nexport class TimeoutError extends NotionistaError {\n  constructor(message: string) {\n    super(message, 'TIMEOUT_ERROR');\n  }\n}\n\n/**\n * RateLimitError - Error for rate limit failures\n */\nexport class RateLimitError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly retryAfter?: number\n  ) {\n    super(message, 'RATE_LIMIT_ERROR');\n  }\n}\n\n/**\n * NotFoundError - Error for resource not found\n */\nexport class NotFoundError extends NotionistaError {\n  constructor(\n    message: string,\n    public readonly resourceType?: string,\n    public readonly resourceId?: string\n  ) {\n    super(message, 'NOT_FOUND_ERROR');\n  }\n}\n\n/**\n * ProposalError - Error for proposal failures\n */\nexport class ProposalError extends NotionistaError {\n  constructor(message: string) {\n    super(message, 'PROPOSAL_ERROR');\n  }\n}\n\n// Type guards\nexport const isNotionError = (error: unknown): error is NotionError =>\n  error instanceof NotionError || error instanceof NotionistaError;\nexport const isValidationError = (error: unknown): error is ValidationError =>\n  error instanceof ValidationError;\nexport const isMcpError = (error: unknown): error is McpError => error instanceof McpError;\nexport const isRateLimitError = (error: unknown): error is RateLimitError =>\n  error instanceof RateLimitError;"
    },
    {
      "path": "./src/core/errors/__tests__/errors.test.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 133,
      "chars": 4452,
      "approxTokens": 1113.0,
      "sha256": "EB2E007092AF188C9C9D5F603CB1505BB4B0901FF5534782233A0C220D82856B",
      "content": "import { describe, it, expect } from 'vitest';\nimport {\n  NotionError,\n  ValidationError,\n  McpError,\n  TransportError,\n  TimeoutError,\n  RateLimitError,\n  ConfigurationError,\n  NotFoundError,\n  ProposalError,\n  isNotionError,\n  isValidationError,\n  isMcpError,\n  isRateLimitError,\n} from '../index.js';\n\ndescribe('Errors', () => {\n  describe('NotionError', () => {\n    it('should create a NotionError with message and code', () => {\n      const error = new NotionError('Test error', 'TEST_ERROR');\n      expect(error.message).toBe('Test error');\n      expect(error.code).toBe('TEST_ERROR');\n      expect(error.name).toBe('NotionError');\n    });\n\n    it('should include details', () => {\n      const error = new NotionError('Test error', 'TEST_ERROR', { foo: 'bar' });\n      expect(error.details).toEqual({ foo: 'bar' });\n    });\n  });\n\n  describe('ValidationError', () => {\n    it('should create a ValidationError', () => {\n      const error = new ValidationError('Invalid data');\n      expect(error.message).toBe('Invalid data');\n      expect(error.code).toBe('VALIDATION_ERROR');\n      expect(error.name).toBe('ValidationError');\n    });\n  });\n\n  describe('McpError', () => {\n    it('should create an McpError', () => {\n      const error = new McpError('MCP failed');\n      expect(error.message).toBe('MCP failed');\n      expect(error.code).toBe('MCP_ERROR');\n      expect(error.name).toBe('McpError');\n    });\n  });\n\n  describe('TransportError', () => {\n    it('should create a TransportError', () => {\n      const error = new TransportError('Transport failed');\n      expect(error.message).toBe('Transport failed');\n      expect(error.code).toBe('TRANSPORT_ERROR');\n      expect(error.name).toBe('TransportError');\n    });\n  });\n\n  describe('TimeoutError', () => {\n    it('should create a TimeoutError', () => {\n      const error = new TimeoutError('Request timed out');\n      expect(error.message).toBe('Request timed out');\n      expect(error.code).toBe('TIMEOUT_ERROR');\n      expect(error.name).toBe('TimeoutError');\n    });\n  });\n\n  describe('RateLimitError', () => {\n    it('should create a RateLimitError with retryAfter', () => {\n      const error = new RateLimitError('Rate limit exceeded', 60);\n      expect(error.message).toBe('Rate limit exceeded');\n      expect(error.code).toBe('RATE_LIMIT_ERROR');\n      expect(error.name).toBe('RateLimitError');\n      expect(error.retryAfter).toBe(60);\n    });\n  });\n\n  describe('ConfigurationError', () => {\n    it('should create a ConfigurationError', () => {\n      const error = new ConfigurationError('Invalid config');\n      expect(error.message).toBe('Invalid config');\n      expect(error.code).toBe('CONFIGURATION_ERROR');\n      expect(error.name).toBe('ConfigurationError');\n    });\n  });\n\n  describe('NotFoundError', () => {\n    it('should create a NotFoundError with resource info', () => {\n      const error = new NotFoundError('Resource not found', 'Project', 'project-123');\n      expect(error.message).toBe('Resource not found');\n      expect(error.code).toBe('NOT_FOUND_ERROR');\n      expect(error.name).toBe('NotFoundError');\n      expect(error.resourceType).toBe('Project');\n      expect(error.resourceId).toBe('project-123');\n    });\n  });\n\n  describe('ProposalError', () => {\n    it('should create a ProposalError', () => {\n      const error = new ProposalError('Invalid proposal');\n      expect(error.message).toBe('Invalid proposal');\n      expect(error.code).toBe('PROPOSAL_ERROR');\n      expect(error.name).toBe('ProposalError');\n    });\n  });\n\n  describe('Type guards', () => {\n    it('should identify NotionError', () => {\n      const error = new NotionError('Test', 'TEST');\n      expect(isNotionError(error)).toBe(true);\n      expect(isNotionError(new Error('Test'))).toBe(false);\n    });\n\n    it('should identify ValidationError', () => {\n      const error = new ValidationError('Test');\n      expect(isValidationError(error)).toBe(true);\n      expect(isValidationError(new NotionError('Test', 'TEST'))).toBe(false);\n    });\n\n    it('should identify McpError', () => {\n      const error = new McpError('Test');\n      expect(isMcpError(error)).toBe(true);\n      expect(isMcpError(new NotionError('Test', 'TEST'))).toBe(false);\n    });\n\n    it('should identify RateLimitError', () => {\n      const error = new RateLimitError('Test', 60);\n      expect(isRateLimitError(error)).toBe(true);\n      expect(isRateLimitError(new McpError('Test'))).toBe(false);\n    });\n  });\n});"
    },
    {
      "path": "./src/core/types/databases.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 29,
      "chars": 1295,
      "approxTokens": 324.0,
      "sha256": "1E8F5DA0C76D61B7C6671240578DC58778B74B1CF57C0743BD27B41C7F71DDD8",
      "content": "/**\n * Database ID constants from Digital Herencia Notion workspace\n * @see .github/copilot-instructions.md for database structure\n */\n\nexport const DATABASE_IDS = {\n  TEAMS: '2d5a4e63-bf23-8151-9b98-c81833668844',\n  PROJECTS: '2d5a4e63-bf23-81b1-b507-f5ac308958e6',\n  TASKS: '2d5a4e63-bf23-816f-a217-ef754ce4a70e',\n  MEETINGS: '2d5a4e63-bf23-8168-af99-d85e20bfb76f',\n  PROMPTS: '2d5a4e63-bf23-81fa-9ca8-f6368bcda19a',\n  TECH_STACK: '276a4e63-bf23-80e2-bbae-000b2fa9662a',\n  TEMPLATES: '2d5a4e63-bf23-8162-8db4-fcce1bbe3471',\n  SOPS: '2d8a4e63-bf23-801e-b6ac-e52358ee91dc',\n  CALENDAR: '2d5a4e63-bf23-8130-acc7-f5ee01d15f22',\n} as const;\n\nexport type DatabaseId = (typeof DATABASE_IDS)[keyof typeof DATABASE_IDS];\n\n/**\n * Property type enums matching Notion workspace schema\n */\nexport type ProjectStatus = 'Active' | 'Completed' | 'On Hold' | 'Cancelled';\nexport type Milestone = 'M1' | 'M2' | 'M3';\nexport type Phase = 'P1.1' | 'P1.2' | 'P1.3' | 'P2.1' | 'P2.2' | 'P2.3' | 'P3.1' | 'P3.2' | 'P3.3';\nexport type Domain = 'OPS' | 'PROD' | 'DES' | 'ENG' | 'MKT' | 'RES';\nexport type Priority = 'High' | 'Medium' | 'Low';\nexport type MeetingType = 'Standup' | 'Sprint Planning' | 'Post-mortem' | 'Team Sync' | 'Ad Hoc';\nexport type Cadence = 'Daily' | 'Weekly' | 'Biweekly' | 'Monthly' | 'Ad Hoc';"
    },
    {
      "path": "./src/core/types/index.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 1,
      "chars": 28,
      "approxTokens": 7.0,
      "sha256": "42101F68D6A64CACC951901FF54C77695AC5D7E4D4829984757EA89F7CDA62FA",
      "content": "export * from './databases';"
    },
    {
      "path": "./src/core/types/mcp.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 86,
      "chars": 1452,
      "approxTokens": 363.0,
      "sha256": "80B78CB4A9DB518FFD4AA6C7CB106D3E50A04A4934F54DCE59CCC1297FE84907",
      "content": "/**\n * JSON-RPC 2.0 protocol types for MCP communication\n */\n\nexport interface JsonRpcRequest {\n  jsonrpc: \"2.0\";\n  id: number | string;\n  method: string;\n  params?: unknown;\n}\n\nexport interface JsonRpcResponse<T = unknown> {\n  jsonrpc: \"2.0\";\n  id: number | string;\n  result?: T;\n  error?: JsonRpcErrorObject;\n}\n\nexport interface JsonRpcErrorObject {\n  code: number;\n  message: string;\n  data?: unknown;\n}\n\n/**\n * MCP Tool invocation types\n */\n\nexport interface McpToolCall {\n  name: string;\n  arguments: Record<string, unknown>;\n}\n\nexport interface McpToolResult<T = unknown> {\n  content: T;\n  isError?: boolean;\n}\n\n/**\n * MCP Request/Response wrapper types\n */\n\nexport interface McpRequest {\n  tool: string;\n  params: Record<string, unknown>;\n  timestamp: number;\n}\n\nexport interface McpResponse<T = unknown> {\n  data: T;\n  timestamp: number;\n  duration: number;\n}\n\n/**\n * MCP Middleware types\n */\n\nexport type McpMiddleware = (\n  req: McpRequest,\n  next: () => Promise<McpResponse>\n) => Promise<McpResponse>;\n\n/**\n * MCP Client configuration\n */\n\nexport interface McpClientOptions {\n  notionToken: string;\n  timeout?: number;\n  maxRetries?: number;\n  rateLimitPerSecond?: number;\n  enableCache?: boolean;\n  enableLogging?: boolean;\n}\n\n/**\n * MCP Transport interface\n */\n\nexport interface McpTransport {\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n  send(request: JsonRpcRequest): Promise<JsonRpcResponse>;\n  isConnected(): boolean;\n}"
    },
    {
      "path": "./src/core/types/notion-filters.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 156,
      "chars": 3116,
      "approxTokens": 779.0,
      "sha256": "05A8EB29E4A7BB4B58744D7AE3CD4CB0A3E51765EA09026C26E0978410C333EA",
      "content": "/**\n * Type definitions for Notion API filter objects\n * Based on: https://developers.notion.com/reference/post-database-query-filter\n */\n\n/**\n * Property filter operators for different property types\n */\n\n// Text property filters\nexport interface TextFilter {\n  equals?: string;\n  does_not_equal?: string;\n  contains?: string;\n  does_not_contain?: string;\n  starts_with?: string;\n  ends_with?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Number property filters\nexport interface NumberFilter {\n  equals?: number;\n  does_not_equal?: number;\n  greater_than?: number;\n  less_than?: number;\n  greater_than_or_equal_to?: number;\n  less_than_or_equal_to?: number;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Checkbox property filters\nexport interface CheckboxFilter {\n  equals?: boolean;\n  does_not_equal?: boolean;\n}\n\n// Select property filters\nexport interface SelectFilter {\n  equals?: string;\n  does_not_equal?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Multi-select property filters\nexport interface MultiSelectFilter {\n  contains?: string;\n  does_not_contain?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Date property filters\nexport interface DateFilter {\n  equals?: string;\n  before?: string;\n  after?: string;\n  on_or_before?: string;\n  on_or_after?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n  past_week?: Record<string, never>;\n  past_month?: Record<string, never>;\n  past_year?: Record<string, never>;\n  next_week?: Record<string, never>;\n  next_month?: Record<string, never>;\n  next_year?: Record<string, never>;\n}\n\n// People property filters\nexport interface PeopleFilter {\n  contains?: string;\n  does_not_contain?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Files property filters\nexport interface FilesFilter {\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Relation property filters\nexport interface RelationFilter {\n  contains?: string;\n  does_not_contain?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n// Status property filters\nexport interface StatusFilter {\n  equals?: string;\n  does_not_equal?: string;\n  is_empty?: true;\n  is_not_empty?: true;\n}\n\n/**\n * Property filter condition\n */\nexport interface PropertyFilter {\n  property: string;\n  title?: TextFilter;\n  rich_text?: TextFilter;\n  number?: NumberFilter;\n  checkbox?: CheckboxFilter;\n  select?: SelectFilter;\n  multi_select?: MultiSelectFilter;\n  date?: DateFilter;\n  people?: PeopleFilter;\n  files?: FilesFilter;\n  relation?: RelationFilter;\n  status?: StatusFilter;\n}\n\n/**\n * Compound filter conditions\n */\nexport interface CompoundFilter {\n  and?: Filter[];\n  or?: Filter[];\n}\n\n/**\n * Combined filter type\n */\nexport type Filter = PropertyFilter | CompoundFilter;\n\n/**\n * Sort direction\n */\nexport type SortDirection = \"ascending\" | \"descending\";\n\n/**\n * Sort condition\n */\nexport interface Sort {\n  property?: string;\n  timestamp?: \"created_time\" | \"last_edited_time\";\n  direction: SortDirection;\n}\n\n/**\n * Query parameters for database queries\n */\nexport interface QueryParams {\n  filter?: Filter;\n  sorts?: Sort[];\n  start_cursor?: string;\n  page_size?: number;\n}"
    },
    {
      "path": "./src/core/types/notion.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 143,
      "chars": 2796,
      "approxTokens": 699.0,
      "sha256": "73485F30679A701F3E90A68E6B738ADAB78EFB7E8650994B8920D16E54CC4110",
      "content": "/**\n * Notion page object structure\n */\nexport interface NotionPage {\n  id: string;\n  created_time: string;\n  last_edited_time: string;\n  parent: {\n    type: string;\n    database_id?: string;\n  };\n  properties: Record<string, NotionProperty>;\n  url: string;\n}\n\n/**\n * Notion property types\n */\nexport type NotionProperty =\n  | TitleProperty\n  | RichTextProperty\n  | NumberProperty\n  | SelectProperty\n  | MultiSelectProperty\n  | DateProperty\n  | CheckboxProperty\n  | RelationProperty\n  | RollupProperty\n  | FormulaProperty;\n\nexport interface TitleProperty {\n  type: 'title';\n  title: Array<{ plain_text: string }>;\n}\n\nexport interface RichTextProperty {\n  type: 'rich_text';\n  rich_text: Array<{ plain_text: string }>;\n}\n\nexport interface NumberProperty {\n  type: 'number';\n  number: number | null;\n}\n\nexport interface SelectProperty {\n  type: 'select';\n  select: { name: string } | null;\n}\n\nexport interface MultiSelectProperty {\n  type: 'multi_select';\n  multi_select: Array<{ name: string }>;\n}\n\nexport interface DateProperty {\n  type: 'date';\n  date: { start: string; end?: string } | null;\n}\n\nexport interface CheckboxProperty {\n  type: 'checkbox';\n  checkbox: boolean;\n}\n\nexport interface RelationProperty {\n  type: 'relation';\n  relation: Array<{ id: string }>;\n}\n\nexport interface RollupProperty {\n  type: 'rollup';\n  rollup: {\n    type: string;\n    number?: number;\n    array?: unknown[];\n  };\n}\n\nexport interface FormulaProperty {\n  type: 'formula';\n  formula: {\n    type: 'string' | 'number' | 'boolean' | 'date';\n    string?: string;\n    number?: number;\n    boolean?: boolean;\n    date?: { start: string };\n  };\n}\n\n/**\n * Properties for creating/updating pages\n */\nexport type PageProperties = Record<string, PropertyValue>;\n\nexport type PropertyValue =\n  | { title: Array<{ text: { content: string } }> }\n  | { rich_text: Array<{ text: { content: string } }> }\n  | { number: number | null }\n  | { select: { name: string } | null }\n  | { multi_select: Array<{ name: string }> }\n  | { date: { start: string; end?: string } | null }\n  | { checkbox: boolean }\n  | { relation: Array<{ id: string }> };\n\n/**\n * Query filter structure\n */\nexport interface QueryFilter {\n  and?: QueryFilter[];\n  or?: QueryFilter[];\n  property?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Query sort structure\n */\nexport interface QuerySort {\n  property?: string;\n  timestamp?: 'created_time' | 'last_edited_time';\n  direction: 'ascending' | 'descending';\n}\n\n/**\n * Query parameters for database queries\n */\nexport interface QueryParams {\n  database_id: string;\n  filter?: QueryFilter;\n  sorts?: QuerySort[];\n  page_size?: number;\n  start_cursor?: string;\n}\n\n/**\n * Query result with pagination\n */\nexport interface QueryResult {\n  results: NotionPage[];\n  has_more: boolean;\n  next_cursor: string | null;\n}"
    },
    {
      "path": "./src/core/types/proposals.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 112,
      "chars": 2293,
      "approxTokens": 573.0,
      "sha256": "1B9B114608A3AC197E362EB8A0F9EFBA4F92EED7B398B9E23F82116AA4BBF69E",
      "content": "import type { DatabaseId } from '../constants/databases';\n\n/**\n * Represents a change proposal in the safety workflow\n * Propose → Approve → Apply pattern\n */\nexport interface ChangeProposal<T> {\n  /** Unique identifier for this proposal */\n  id: string;\n  \n  /** Type of operation being proposed */\n  type: 'create' | 'update' | 'delete' | 'bulk';\n  \n  /** Target database and page for the operation */\n  target: {\n    database: DatabaseId;\n    pageId?: string;\n  };\n  \n  /** Current state (null for creates) */\n  currentState: T | null;\n  \n  /** Proposed new state */\n  proposedState: T;\n  \n  /** Property-level differences */\n  diff: PropertyDiff[];\n  \n  /** Related side effects of this change */\n  sideEffects: SideEffect[];\n  \n  /** Validation results */\n  validation: ValidationResult;\n  \n  /** When this proposal was created */\n  createdAt: Date;\n}\n\n/**\n * Represents a difference between current and proposed states\n */\nexport interface PropertyDiff {\n  /** Property name that changed */\n  property: string;\n  \n  /** Current value */\n  oldValue: unknown;\n  \n  /** Proposed value */\n  newValue: unknown;\n  \n  /** Impact level of this change */\n  impact: 'low' | 'medium' | 'high';\n}\n\n/**\n * Represents a side effect of a proposed change\n */\nexport interface SideEffect {\n  /** Type of side effect */\n  type: 'relation_update' | 'rollup_recalc' | 'cascade';\n  \n  /** Human-readable description */\n  description: string;\n  \n  /** IDs of items that will be affected */\n  affectedItems: string[];\n}\n\n/**\n * Validation result for a proposal\n */\nexport interface ValidationResult {\n  /** Whether validation passed */\n  valid: boolean;\n  \n  /** List of validation errors */\n  errors: ValidationError[];\n  \n  /** List of validation warnings */\n  warnings: ValidationWarning[];\n}\n\nexport interface ValidationError {\n  field: string;\n  message: string;\n  code: string;\n}\n\nexport interface ValidationWarning {\n  field: string;\n  message: string;\n  code: string;\n}\n\n/**\n * Result of applying a proposal\n */\nexport interface ApplyResult<T = unknown> {\n  /** Whether the operation succeeded */\n  success: boolean;\n  \n  /** The resulting entity (if successful) */\n  result?: T;\n  \n  /** Error information (if failed) */\n  error?: {\n    code: string;\n    message: string;\n    details?: unknown;\n  };\n}"
    },
    {
      "path": "./src/core/types/schemas.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 74,
      "chars": 1941,
      "approxTokens": 485.0,
      "sha256": "067B3B2F51A3FF97362DC1EFC006127F07F593F502D24BBF404D9545AAA3931F",
      "content": "import { z } from \"zod\";\n\nconst notionId = z.string();\nconst isoDate = z.string(); // ISO 8601\n\nexport const Team = z.object({\n  id: notionId,\n  name: z.string(),\n  meetings: z.array(notionId).default([]),\n  projects: z.array(notionId).default([]),\n  projectsComplete: z.number().optional(), // rollup/formula\n  tasks: z.array(notionId).default([]),\n  tasksCompleted: z.number().optional(), // rollup/formula\n});\nexport type Team = z.infer<typeof Team>;\n\nexport const Project = z.object({\n  id: notionId,\n  name: z.string(),\n  status: z.enum([\"Active\", \"Completed\", \"On Hold\", \"Cancelled\"]),\n  milestone: z.enum([\"M1\", \"M2\", \"M3\"]).nullable(),\n  phase: z\n    .enum([\n      \"P1.1\",\n      \"P1.2\",\n      \"P1.3\",\n      \"P2.1\",\n      \"P2.2\",\n      \"P2.3\",\n      \"P3.1\",\n      \"P3.2\",\n      \"P3.3\",\n    ])\n    .nullable(),\n  domain: z.enum([\"OPS\", \"PROD\", \"DES\", \"ENG\", \"MKT\", \"RES\"]).nullable(),\n  startDate: isoDate.nullable(),\n  endDate: isoDate.nullable(),\n  teamId: notionId.optional(),\n  taskIds: z.array(notionId).default([]),\n});\nexport type Project = z.infer<typeof Project>;\n\nexport const Task = z.object({\n  id: notionId,\n  name: z.string(),\n  done: z.boolean(),\n  taskCode: z.string().optional(),\n  due: isoDate.nullable(),\n  priority: z.enum([\"High\", \"Medium\", \"Low\"]).nullable(),\n  projectId: notionId.optional(),\n  teamId: notionId.optional(),\n});\nexport type Task = z.infer<typeof Task>;\n\nexport const Meeting = z.object({\n  id: notionId,\n  name: z.string(),\n  type: z.enum([\n    \"Standup\",\n    \"Sprint Planning\",\n    \"Post-mortem\",\n    \"Team Sync\",\n    \"Ad Hoc\",\n  ]),\n  cadence: z\n    .enum([\"Daily\", \"Weekly\", \"Biweekly\", \"Monthly\", \"Ad Hoc\"])\n    .nullable(),\n  date: isoDate.nullable(),\n  attendeeTeamIds: z.array(notionId).default([]),\n  actionItemTaskIds: z.array(notionId).default([]),\n  projectIds: z.array(notionId).default([]),\n  teamIds: z.array(notionId).default([]),\n});\nexport type Meeting = z.infer<typeof Meeting>;"
    },
    {
      "path": "./src/core/types/snapshot.ts",
      "category": "core",
      "startLine": 1,
      "endLine": 81,
      "chars": 1918,
      "approxTokens": 480.0,
      "sha256": "48F802E511C8345FF5783B861012A5B7B735AF1E25E4F7F34966AFD8188CC742",
      "content": "import { z } from \"zod\";\n\n/**\n * A record parsed from a Notion CSV export snapshot\n */\nexport interface SnapshotRecord {\n  /** Extracted Notion page ID */\n  id: string;\n  /** Normalized property values */\n  properties: Record<string, unknown>;\n  /** Source of the snapshot data */\n  source: \"csv\" | \"markdown\";\n  /** Path to the source file */\n  filePath: string;\n}\n\n/**\n * A complete snapshot of a Notion database at a point in time\n */\nexport interface Snapshot {\n  /** Unique snapshot identifier */\n  id: string;\n  /** Notion database ID */\n  databaseId: string;\n  /** When the snapshot was captured */\n  capturedAt: Date;\n  /** Number of pages in snapshot */\n  pageCount: number;\n  /** All records in the snapshot */\n  records: SnapshotRecord[];\n}\n\n/**\n * Comparison result between a snapshot and current state\n */\nexport interface SnapshotDiff {\n  /** Records added since snapshot */\n  added: SnapshotRecord[];\n  /** Records removed since snapshot */\n  removed: SnapshotRecord[];\n  /** Records with changed properties */\n  modified: Array<{\n    id: string;\n    oldRecord: SnapshotRecord;\n    newRecord: SnapshotRecord;\n    changedProperties: string[];\n  }>;\n}\n\n/**\n * Options for CSV parsing\n */\nexport interface CsvParserOptions {\n  /** Whether to trim whitespace from values */\n  trim?: boolean;\n  /** Whether to skip empty lines */\n  skipEmptyLines?: boolean;\n  /** Custom property normalizers */\n  normalizers?: Record<string, (value: string) => unknown>;\n}\n\n/**\n * Zod schema for validating snapshot records\n */\nexport const SnapshotRecordSchema = z.object({\n  id: z.string(),\n  properties: z.record(z.unknown()),\n  source: z.enum([\"csv\", \"markdown\"]),\n  filePath: z.string(),\n});\n\n/**\n * Zod schema for validating snapshots\n */\nexport const SnapshotSchema = z.object({\n  id: z.string(),\n  databaseId: z.string(),\n  capturedAt: z.date(),\n  pageCount: z.number(),\n  records: z.array(SnapshotRecordSchema),\n});"
    },
    {
      "path": "./src/domain/index.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 2,
      "chars": 106,
      "approxTokens": 26.0,
      "sha256": "D43E23E10D6059F25806EB9A23B8FF147980537B3846FE9B8393ABC5892D92A7",
      "content": "export * from './repositories';\nexport type { Team, Project, Task, Meeting } from '../core/types/schemas';"
    },
    {
      "path": "./src/domain/entities/index.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 6,
      "chars": 102,
      "approxTokens": 26.0,
      "sha256": "C45143460D80C955343E100C02431680F731D59D9F6FDC8647AF74871DDCD516",
      "content": "/**\n * Domain entity exports (placeholder for EPIC-003)\n */\n\n// TODO: Implement in EPIC-003\nexport {};"
    },
    {
      "path": "./src/domain/repositories/base.repository.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 294,
      "chars": 8723,
      "approxTokens": 2181.0,
      "sha256": "CA6E6BD50BC9BAFE969A71EC93B8B7B9AC7B5D619E262F2AB13C54A36199A749",
      "content": "import type { IMcpClient } from '../../mcp/client';\r\nimport type { DatabaseId } from '../../core/constants/databases';\r\nimport type { NotionPage, PageProperties, QueryFilter } from '../../core/types/notion';\r\nimport type { ChangeProposal, PropertyDiff, SideEffect, ValidationResult } from '../../core/types/proposals';\r\nimport { EntityNotFoundError, ValidationError as DomainValidationError } from '../../core/errors';\r\n\r\n/**\r\n * Abstract base repository implementing the repository pattern\r\n * All concrete repositories extend this class\r\n * \r\n * @template TEntity - The domain entity type\r\n * @template TCreateInput - Input type for creating entities\r\n * @template TUpdateInput - Input type for updating entities\r\n */\r\nexport abstract class BaseRepository<TEntity, TCreateInput, TUpdateInput> {\r\n  constructor(\r\n    protected readonly mcp: IMcpClient,\r\n    protected readonly databaseId: DatabaseId\r\n  ) {}\r\n\r\n  /**\r\n   * Find all entities matching the filter\r\n   */\r\n  async findMany(filter?: QueryFilter): Promise<TEntity[]> {\r\n    const result = await this.mcp.queryDatabase({\r\n      database_id: this.databaseId,\r\n      filter,\r\n      page_size: 100,\r\n    });\r\n\r\n    return result.results.map((page: NotionPage) => this.toDomainEntity(page));\r\n  }\r\n\r\n  /**\r\n   * Find a single entity by ID\r\n   * @returns The entity or null if not found\r\n   */\r\n  async findById(id: string): Promise<TEntity | null> {\r\n    try {\r\n      const page = await this.mcp.getPage(id);\r\n      return this.toDomainEntity(page);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find a single entity by ID, throw if not found\r\n   * @throws {EntityNotFoundError} If entity is not found\r\n   */\r\n  async findByIdOrThrow(id: string): Promise<TEntity> {\r\n    const entity = await this.findById(id);\r\n    if (!entity) {\r\n      throw new EntityNotFoundError(this.getEntityName(), id);\r\n    }\r\n    return entity;\r\n  }\r\n\r\n  /**\r\n   * Create a new entity - returns a proposal for the safety workflow\r\n   * Does NOT execute the change immediately\r\n   */\r\n  async create(input: TCreateInput): Promise<ChangeProposal<TEntity>> {\r\n    // Validate input\r\n    const validation = await this.validateCreate(input);\r\n    if (!validation.valid) {\r\n      throw new DomainValidationError('Create validation failed', validation.errors);\r\n    }\r\n\r\n    // Create proposed entity\r\n    const proposedState = this.createProposedEntity(input);\r\n\r\n    // Detect side effects\r\n    const sideEffects = await this.detectSideEffects('create', null, proposedState);\r\n\r\n    // Generate diff\r\n    const diff = this.generateDiff(null, proposedState);\r\n\r\n    return {\r\n      id: this.generateProposalId(),\r\n      type: 'create',\r\n      target: {\r\n        database: this.databaseId,\r\n      },\r\n      currentState: null,\r\n      proposedState,\r\n      diff,\r\n      sideEffects,\r\n      validation,\r\n      createdAt: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update an existing entity - returns a proposal for the safety workflow\r\n   * Does NOT execute the change immediately\r\n   */\r\n  async update(id: string, input: TUpdateInput): Promise<ChangeProposal<TEntity>> {\r\n    // Get current state\r\n    const currentState = await this.findByIdOrThrow(id);\r\n\r\n    // Validate update\r\n    const validation = await this.validateUpdate(id, input);\r\n    if (!validation.valid) {\r\n      throw new DomainValidationError('Update validation failed', validation.errors);\r\n    }\r\n\r\n    // Create proposed state\r\n    const proposedState = this.mergeUpdate(currentState, input);\r\n\r\n    // Detect side effects\r\n    const sideEffects = await this.detectSideEffects('update', currentState, proposedState);\r\n\r\n    // Generate diff\r\n    const diff = this.generateDiff(currentState, proposedState);\r\n\r\n    return {\r\n      id: this.generateProposalId(),\r\n      type: 'update',\r\n      target: {\r\n        database: this.databaseId,\r\n        pageId: id,\r\n      },\r\n      currentState,\r\n      proposedState,\r\n      diff,\r\n      sideEffects,\r\n      validation,\r\n      createdAt: new Date(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Execute a create proposal\r\n   * @internal Used by ProposalManager\r\n   */\r\n  async executeCreate(proposal: ChangeProposal<TEntity>): Promise<TEntity> {\r\n    const properties = this.toNotionProperties(proposal.proposedState as any);\r\n    const page = await this.mcp.createPage(this.databaseId, properties);\r\n    return this.toDomainEntity(page);\r\n  }\r\n\r\n  /**\r\n   * Execute an update proposal\r\n   * @internal Used by ProposalManager\r\n   */\r\n  async executeUpdate(proposal: ChangeProposal<TEntity>): Promise<TEntity> {\r\n    if (!proposal.target.pageId) {\r\n      throw new Error('Update proposal must have a pageId');\r\n    }\r\n    const properties = this.toNotionProperties(proposal.proposedState as any);\r\n    const page = await this.mcp.updatePage(proposal.target.pageId, properties);\r\n    return this.toDomainEntity(page);\r\n  }\r\n\r\n  /**\r\n   * Convert a Notion page to a domain entity\r\n   * Must be implemented by concrete repositories\r\n   */\r\n  protected abstract toDomainEntity(page: NotionPage): TEntity;\r\n\r\n  /**\r\n   * Convert domain input to Notion properties\r\n   * Must be implemented by concrete repositories\r\n   */\r\n  protected abstract toNotionProperties(input: TCreateInput | TUpdateInput | TEntity): PageProperties;\r\n\r\n  /**\r\n   * Get the entity name for error messages\r\n   */\r\n  protected abstract getEntityName(): string;\r\n\r\n  /**\r\n   * Validate create input\r\n   * Can be overridden by concrete repositories for custom validation\r\n   */\r\n  protected async validateCreate(_input: TCreateInput): Promise<ValidationResult> {\r\n    return {\r\n      valid: true,\r\n      errors: [],\r\n      warnings: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate update input\r\n   * Can be overridden by concrete repositories for custom validation\r\n   */\r\n  protected async validateUpdate(_id: string, _input: TUpdateInput): Promise<ValidationResult> {\r\n    return {\r\n      valid: true,\r\n      errors: [],\r\n      warnings: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a proposed entity from input (used in create proposal)\r\n   * Can be overridden for more complex entity construction\r\n   */\r\n  protected createProposedEntity(input: TCreateInput): TEntity {\r\n    return {\r\n      id: 'proposed-id',\r\n      ...input,\r\n    } as TEntity;\r\n  }\r\n\r\n  /**\r\n   * Merge update input with current state\r\n   * Can be overridden for complex merge logic\r\n   */\r\n  protected mergeUpdate(current: TEntity, update: TUpdateInput): TEntity {\r\n    return {\r\n      ...current,\r\n      ...update,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect side effects of a change\r\n   * Can be overridden to detect relations, rollups, etc.\r\n   */\r\n  protected async detectSideEffects(\r\n    _operation: 'create' | 'update',\r\n    _current: TEntity | null,\r\n    _proposed: TEntity\r\n  ): Promise<SideEffect[]> {\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Generate property-level diff between states\r\n   */\r\n  protected generateDiff(current: TEntity | null, proposed: TEntity): PropertyDiff[] {\r\n    const diffs: PropertyDiff[] = [];\r\n\r\n    if (!current) {\r\n      // All properties are new\r\n      Object.entries(proposed as any).forEach(([key, value]) => {\r\n        if (key !== 'id') {\r\n          diffs.push({\r\n            property: key,\r\n            oldValue: null,\r\n            newValue: value,\r\n            impact: this.assessImpact(key),\r\n          });\r\n        }\r\n      });\r\n    } else {\r\n      // Compare properties\r\n      Object.entries(proposed as any).forEach(([key, newValue]) => {\r\n        const oldValue = (current as any)[key];\r\n        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\r\n          diffs.push({\r\n            property: key,\r\n            oldValue,\r\n            newValue,\r\n            impact: this.assessImpact(key),\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return diffs;\r\n  }\r\n\r\n  /**\r\n   * Assess the impact level of a property change\r\n   * Can be overridden for domain-specific impact assessment\r\n   */\r\n  protected assessImpact(property: string): 'low' | 'medium' | 'high' {\r\n    // Relations and status changes are high impact\r\n    if (property.includes('Id') || property.includes('Ids') || property === 'status') {\r\n      return 'high';\r\n    }\r\n    // Dates and priorities are medium impact\r\n    if (property.includes('date') || property.includes('Date') || property === 'priority') {\r\n      return 'medium';\r\n    }\r\n    // Everything else is low impact\r\n    return 'low';\r\n  }\r\n\r\n  /**\r\n   * Generate a unique proposal ID\r\n   */\r\n  protected generateProposalId(): string {\r\n    return `proposal-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Extract title from Notion title property\r\n   */\r\n  protected extractTitle(properties: Record<string, any>, propertyName: string): string {"
    },
    {
      "path": "./src/domain/repositories/base.repository.ts",
      "category": "domain",
      "startLine": 295,
      "endLine": 373,
      "chars": 2402,
      "approxTokens": 600.0,
      "sha256": "7D9B43E0E1AFF880A474353E5573068F341B48308203D7E2538FFA4EB3B53B9D",
      "content": "    const prop = properties[propertyName];\r\n    if (prop?.type === 'title' && prop.title.length > 0) {\r\n      return prop.title[0].plain_text;\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Extract select value from Notion select property\r\n   */\r\n  protected extractSelect(properties: Record<string, any>, propertyName: string): string | null {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'select' && prop.select) {\r\n      return prop.select.name;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract date from Notion date property\r\n   */\r\n  protected extractDate(properties: Record<string, any>, propertyName: string): string | null {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'date' && prop.date) {\r\n      return prop.date.start;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Extract checkbox from Notion checkbox property\r\n   */\r\n  protected extractCheckbox(properties: Record<string, any>, propertyName: string): boolean {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'checkbox') {\r\n      return prop.checkbox;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Extract relation IDs from Notion relation property\r\n   */\r\n  protected extractRelation(properties: Record<string, any>, propertyName: string): string[] {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'relation' && prop.relation) {\r\n      return prop.relation.map((r: any) => r.id);\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Extract number from Notion number/formula/rollup property\r\n   */\r\n  protected extractNumber(properties: Record<string, any>, propertyName: string): number | undefined {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'number') {\r\n      return prop.number ?? undefined;\r\n    }\r\n    if (prop?.type === 'formula' && prop.formula?.type === 'number') {\r\n      return prop.formula.number ?? undefined;\r\n    }\r\n    if (prop?.type === 'rollup' && prop.rollup?.type === 'number') {\r\n      return prop.rollup.number ?? undefined;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Extract rich text from Notion rich text property\r\n   */\r\n  protected extractRichText(properties: Record<string, any>, propertyName: string): string {\r\n    const prop = properties[propertyName];\r\n    if (prop?.type === 'rich_text' && prop.rich_text.length > 0) {\r\n      return prop.rich_text[0].plain_text;\r\n    }\r\n    return '';\r\n  }\r\n}"
    },
    {
      "path": "./src/domain/repositories/index.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 1,
      "chars": 29,
      "approxTokens": 7.0,
      "sha256": "E005C9BA4A706ACE1681BAB584F5B94BC6F0EEBF1CCC722C9EB51811572B845C",
      "content": "export * from './interfaces';"
    },
    {
      "path": "./src/domain/repositories/interfaces.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 89,
      "chars": 2076,
      "approxTokens": 519.0,
      "sha256": "5579E2F01D476375117293D217C371FDAD3769E2B128FC317476FD3CD190ED76",
      "content": "import type { ChangeProposal } from '../../safety';\nimport type { Team, Project, Task, Meeting } from '../../schemas';\nimport type {\n  ProjectStatus,\n  Milestone,\n  Phase,\n  Domain,\n  Priority,\n  MeetingType,\n  Cadence,\n} from '../../core/types';\n\n/**\n * Input for creating a new project\n */\nexport interface ProjectCreateInput {\n  name: string;\n  status: ProjectStatus;\n  milestone: Milestone | null;\n  phase: Phase | null;\n  domain: Domain | null;\n  startDate: string | null;\n  endDate: string | null;\n  teamId: string;\n}\n\n/**\n * Input for creating a new task\n */\nexport interface TaskCreateInput {\n  name: string;\n  done?: boolean;\n  due: string | null;\n  priority: Priority | null;\n  projectId?: string;\n  teamId: string;\n}\n\n/**\n * Input for creating a new meeting\n */\nexport interface MeetingCreateInput {\n  name: string;\n  type: MeetingType;\n  cadence: Cadence | null;\n  date: string | null;\n  teamIds: string[];\n  projectIds?: string[];\n  actionItemTaskIds?: string[];\n}\n\n/**\n * Repository interface for Team operations\n */\nexport interface ITeamRepository {\n  findById(id: string): Promise<Team | null>;\n  findMany(): Promise<Team[]>;\n}\n\n/**\n * Repository interface for Project operations\n */\nexport interface IProjectRepository {\n  findById(id: string): Promise<Project | null>;\n  findByTeam(teamId: string): Promise<Project[]>;\n  findMany(): Promise<Project[]>;\n  create(input: ProjectCreateInput): Promise<ChangeProposal<Project>>;\n}\n\n/**\n * Repository interface for Task operations\n */\nexport interface ITaskRepository {\n  findById(id: string): Promise<Task | null>;\n  findByTeam(teamId: string): Promise<Task[]>;\n  findByProject(projectId: string): Promise<Task[]>;\n  findMany(): Promise<Task[]>;\n  create(input: TaskCreateInput): Promise<ChangeProposal<Task>>;\n}\n\n/**\n * Repository interface for Meeting operations\n */\nexport interface IMeetingRepository {\n  findById(id: string): Promise<Meeting | null>;\n  findByTeam(teamId: string): Promise<Meeting[]>;\n  findMany(): Promise<Meeting[]>;\n  create(input: MeetingCreateInput): Promise<ChangeProposal<Meeting>>;\n}"
    },
    {
      "path": "./src/domain/repositories/meeting.repository.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 224,
      "chars": 5935,
      "approxTokens": 1484.0,
      "sha256": "C1A89F3185CF386FC00D22AC64C4608B5B807B9B9F49280D7917BECAB26A099B",
      "content": "import type { Meeting } from '../../core/types/schemas';\nimport type { NotionPage, PageProperties } from '../../core/types/notion';\nimport type { MeetingType, Cadence } from '../../core/constants/databases';\nimport { BaseRepository } from './base.repository';\nimport { DATABASE_IDS } from '../../core/constants/databases';\n\n/**\n * Input for creating a new meeting\n */\nexport interface CreateMeetingInput {\n  name: string;\n  type: MeetingType;\n  cadence?: Cadence | null;\n  date?: string | null;\n  attendeeTeamIds?: string[];\n  actionItemTaskIds?: string[];\n  projectIds?: string[];\n  teamIds?: string[];\n}\n\n/**\n * Input for updating a meeting\n */\nexport interface UpdateMeetingInput {\n  name?: string;\n  type?: MeetingType;\n  cadence?: Cadence | null;\n  date?: string | null;\n  attendeeTeamIds?: string[];\n  actionItemTaskIds?: string[];\n  projectIds?: string[];\n  teamIds?: string[];\n}\n\n/**\n * Repository for Meeting entities\n */\nexport class MeetingRepository extends BaseRepository<Meeting, CreateMeetingInput, UpdateMeetingInput> {\n  constructor(mcp: any) {\n    super(mcp, DATABASE_IDS.MEETINGS);\n  }\n\n  protected getEntityName(): string {\n    return 'Meeting';\n  }\n\n  protected toDomainEntity(page: NotionPage): Meeting {\n    const props = page.properties;\n\n    return {\n      id: page.id,\n      name: this.extractTitle(props, 'Name'),\n      type: (this.extractSelect(props, 'Type') as MeetingType) || 'Ad Hoc',\n      cadence: this.extractSelect(props, 'Cadence') as Cadence | null,\n      date: this.extractDate(props, 'Date'),\n      attendeeTeamIds: this.extractRelation(props, 'Attendees'),\n      actionItemTaskIds: this.extractRelation(props, 'Action Items'),\n      projectIds: this.extractRelation(props, 'Projects'),\n      teamIds: this.extractRelation(props, 'Teams'),\n    };\n  }\n\n  protected toNotionProperties(input: CreateMeetingInput | UpdateMeetingInput | Meeting): PageProperties {\n    const properties: PageProperties = {};\n\n    if ('name' in input && input.name !== undefined) {\n      properties['Name'] = {\n        title: [{ text: { content: input.name } }],\n      };\n    }\n\n    if ('type' in input && input.type !== undefined) {\n      properties['Type'] = {\n        select: { name: input.type },\n      };\n    }\n\n    if ('cadence' in input) {\n      properties['Cadence'] = input.cadence\n        ? { select: { name: input.cadence } }\n        : { select: null };\n    }\n\n    if ('date' in input) {\n      properties['Date'] = input.date\n        ? { date: { start: input.date } }\n        : { date: null };\n    }\n\n    if ('attendeeTeamIds' in input && input.attendeeTeamIds) {\n      properties['Attendees'] = {\n        relation: input.attendeeTeamIds.map(id => ({ id })),\n      };\n    }\n\n    if ('actionItemTaskIds' in input && input.actionItemTaskIds) {\n      properties['Action Items'] = {\n        relation: input.actionItemTaskIds.map(id => ({ id })),\n      };\n    }\n\n    if ('projectIds' in input && input.projectIds) {\n      properties['Projects'] = {\n        relation: input.projectIds.map(id => ({ id })),\n      };\n    }\n\n    if ('teamIds' in input && input.teamIds) {\n      properties['Teams'] = {\n        relation: input.teamIds.map(id => ({ id })),\n      };\n    }\n\n    return properties;\n  }\n\n  /**\n   * Find meetings by type\n   */\n  async findByType(type: MeetingType): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    return allMeetings.filter(meeting => meeting.type === type);\n  }\n\n  /**\n   * Find standups\n   */\n  async findStandups(): Promise<Meeting[]> {\n    return this.findByType('Standup');\n  }\n\n  /**\n   * Find sprint planning meetings\n   */\n  async findSprintPlannings(): Promise<Meeting[]> {\n    return this.findByType('Sprint Planning');\n  }\n\n  /**\n   * Find post-mortem meetings\n   */\n  async findPostMortems(): Promise<Meeting[]> {\n    return this.findByType('Post-mortem');\n  }\n\n  /**\n   * Find meetings by team\n   */\n  async findByTeam(teamId: string): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    return allMeetings.filter(meeting => \n      meeting.teamIds.includes(teamId) || meeting.attendeeTeamIds.includes(teamId)\n    );\n  }\n\n  /**\n   * Find meetings by project\n   */\n  async findByProject(projectId: string): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    return allMeetings.filter(meeting => meeting.projectIds.includes(projectId));\n  }\n\n  /**\n   * Find meetings by cadence\n   */\n  async findByCadence(cadence: Cadence): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    return allMeetings.filter(meeting => meeting.cadence === cadence);\n  }\n\n  /**\n   * Find daily meetings\n   */\n  async findDaily(): Promise<Meeting[]> {\n    return this.findByCadence('Daily');\n  }\n\n  /**\n   * Find meetings within a date range\n   */\n  async findByDateRange(startDate: string, endDate: string): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    return allMeetings.filter(meeting => {\n      if (!meeting.date) return false;\n      return meeting.date >= startDate && meeting.date <= endDate;\n    });\n  }\n\n  /**\n   * Find upcoming meetings (date in the future)\n   */\n  async findUpcoming(): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    const now = new Date().toISOString();\n    \n    return allMeetings.filter(meeting => \n      meeting.date && meeting.date >= now\n    );\n  }\n\n  /**\n   * Find past meetings (date in the past)\n   */\n  async findPast(): Promise<Meeting[]> {\n    const allMeetings = await this.findMany();\n    const now = new Date().toISOString();\n    \n    return allMeetings.filter(meeting => \n      meeting.date && meeting.date < now\n    );\n  }\n\n  /**\n   * Get meeting with action items\n   */\n  async findWithActionItems(meetingId: string): Promise<{ meeting: Meeting; actionItemIds: string[] }> {\n    const meeting = await this.findByIdOrThrow(meetingId);\n    return {\n      meeting,\n      actionItemIds: meeting.actionItemTaskIds,\n    };\n  }\n}"
    },
    {
      "path": "./src/domain/repositories/project.repository.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 185,
      "chars": 5080,
      "approxTokens": 1270.0,
      "sha256": "2E64F3194D8031502AE01FE77C738DA664C68C88D986DAA94E6C46CF02A01B10",
      "content": "import type { Project } from '../../core/types/schemas';\nimport type { NotionPage, PageProperties } from '../../core/types/notion';\nimport type { ProjectStatus, Milestone, Phase, Domain } from '../../core/constants/databases';\nimport { BaseRepository } from './base.repository';\nimport { DATABASE_IDS } from '../../core/constants/databases';\n\n/**\n * Input for creating a new project\n */\nexport interface CreateProjectInput {\n  name: string;\n  status: ProjectStatus;\n  milestone?: Milestone | null;\n  phase?: Phase | null;\n  domain?: Domain | null;\n  startDate?: string | null;\n  endDate?: string | null;\n  teamId?: string;\n}\n\n/**\n * Input for updating a project\n */\nexport interface UpdateProjectInput {\n  name?: string;\n  status?: ProjectStatus;\n  milestone?: Milestone | null;\n  phase?: Phase | null;\n  domain?: Domain | null;\n  startDate?: string | null;\n  endDate?: string | null;\n  teamId?: string;\n}\n\n/**\n * Repository for Project entities\n */\nexport class ProjectRepository extends BaseRepository<Project, CreateProjectInput, UpdateProjectInput> {\n  constructor(mcp: any) {\n    super(mcp, DATABASE_IDS.PROJECTS);\n  }\n\n  protected getEntityName(): string {\n    return 'Project';\n  }\n\n  protected toDomainEntity(page: NotionPage): Project {\n    const props = page.properties;\n\n    return {\n      id: page.id,\n      name: this.extractTitle(props, 'Name'),\n      status: (this.extractSelect(props, 'Status') as ProjectStatus) || 'Active',\n      milestone: this.extractSelect(props, 'Milestone') as Milestone | null,\n      phase: this.extractSelect(props, 'Phase') as Phase | null,\n      domain: this.extractSelect(props, 'Domain') as Domain | null,\n      startDate: this.extractDate(props, 'Start Date'),\n      endDate: this.extractDate(props, 'End Date'),\n      teamId: this.extractRelation(props, 'Team')[0],\n      taskIds: this.extractRelation(props, 'Tasks'),\n    };\n  }\n\n  protected toNotionProperties(input: CreateProjectInput | UpdateProjectInput | Project): PageProperties {\n    const properties: PageProperties = {};\n\n    if ('name' in input && input.name !== undefined) {\n      properties['Name'] = {\n        title: [{ text: { content: input.name } }],\n      };\n    }\n\n    if ('status' in input && input.status !== undefined) {\n      properties['Status'] = {\n        select: { name: input.status },\n      };\n    }\n\n    if ('milestone' in input) {\n      properties['Milestone'] = input.milestone\n        ? { select: { name: input.milestone } }\n        : { select: null };\n    }\n\n    if ('phase' in input) {\n      properties['Phase'] = input.phase\n        ? { select: { name: input.phase } }\n        : { select: null };\n    }\n\n    if ('domain' in input) {\n      properties['Domain'] = input.domain\n        ? { select: { name: input.domain } }\n        : { select: null };\n    }\n\n    if ('startDate' in input) {\n      properties['Start Date'] = input.startDate\n        ? { date: { start: input.startDate } }\n        : { date: null };\n    }\n\n    if ('endDate' in input) {\n      properties['End Date'] = input.endDate\n        ? { date: { start: input.endDate } }\n        : { date: null };\n    }\n\n    if ('teamId' in input && input.teamId) {\n      properties['Team'] = {\n        relation: [{ id: input.teamId }],\n      };\n    }\n\n    return properties;\n  }\n\n  /**\n   * Find projects by status\n   */\n  async findByStatus(status: ProjectStatus): Promise<Project[]> {\n    const allProjects = await this.findMany();\n    return allProjects.filter(project => project.status === status);\n  }\n\n  /**\n   * Find projects by team\n   */\n  async findByTeam(teamId: string): Promise<Project[]> {\n    const allProjects = await this.findMany();\n    return allProjects.filter(project => project.teamId === teamId);\n  }\n\n  /**\n   * Find projects by milestone\n   */\n  async findByMilestone(milestone: Milestone): Promise<Project[]> {\n    const allProjects = await this.findMany();\n    return allProjects.filter(project => project.milestone === milestone);\n  }\n\n  /**\n   * Find projects by domain\n   */\n  async findByDomain(domain: Domain): Promise<Project[]> {\n    const allProjects = await this.findMany();\n    return allProjects.filter(project => project.domain === domain);\n  }\n\n  /**\n   * Find active projects (status = Active)\n   */\n  async findActive(): Promise<Project[]> {\n    return this.findByStatus('Active');\n  }\n\n  /**\n   * Find completed projects\n   */\n  async findCompleted(): Promise<Project[]> {\n    return this.findByStatus('Completed');\n  }\n\n  /**\n   * Get project with all related tasks\n   */\n  async findWithTasks(projectId: string): Promise<{ project: Project; taskIds: string[] }> {\n    const project = await this.findByIdOrThrow(projectId);\n    return {\n      project,\n      taskIds: project.taskIds,\n    };\n  }\n\n  /**\n   * Find projects within a date range\n   */\n  async findByDateRange(startDate: string, endDate: string): Promise<Project[]> {\n    const allProjects = await this.findMany();\n    return allProjects.filter(project => {\n      if (!project.startDate) return false;\n      return project.startDate >= startDate && project.startDate <= endDate;\n    });\n  }\n}"
    },
    {
      "path": "./src/domain/repositories/task.repository.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 215,
      "chars": 5480,
      "approxTokens": 1370.0,
      "sha256": "60C15B5F827F4F929BF8B35B019F85A0D1C84C2D53D362D78448BE8763348230",
      "content": "import type { Task } from '../../core/types/schemas';\nimport type { NotionPage, PageProperties } from '../../core/types/notion';\nimport type { Priority } from '../../core/constants/databases';\nimport { BaseRepository } from './base.repository';\nimport { DATABASE_IDS } from '../../core/constants/databases';\n\n/**\n * Input for creating a new task\n */\nexport interface CreateTaskInput {\n  name: string;\n  done?: boolean;\n  due?: string | null;\n  priority?: Priority | null;\n  projectId?: string;\n  teamId?: string;\n}\n\n/**\n * Input for updating a task\n */\nexport interface UpdateTaskInput {\n  name?: string;\n  done?: boolean;\n  due?: string | null;\n  priority?: Priority | null;\n  projectId?: string;\n  teamId?: string;\n}\n\n/**\n * Repository for Task entities\n */\nexport class TaskRepository extends BaseRepository<Task, CreateTaskInput, UpdateTaskInput> {\n  constructor(mcp: any) {\n    super(mcp, DATABASE_IDS.TASKS);\n  }\n\n  protected getEntityName(): string {\n    return 'Task';\n  }\n\n  protected toDomainEntity(page: NotionPage): Task {\n    const props = page.properties;\n\n    return {\n      id: page.id,\n      name: this.extractTitle(props, 'Name'),\n      done: this.extractCheckbox(props, 'Done'),\n      taskCode: this.extractRichText(props, 'Task Code') || undefined,\n      due: this.extractDate(props, 'Due'),\n      priority: this.extractSelect(props, 'Priority') as Priority | null,\n      projectId: this.extractRelation(props, 'Project')[0],\n      teamId: this.extractRelation(props, 'Team')[0],\n    };\n  }\n\n  protected toNotionProperties(input: CreateTaskInput | UpdateTaskInput | Task): PageProperties {\n    const properties: PageProperties = {};\n\n    if ('name' in input && input.name !== undefined) {\n      properties['Name'] = {\n        title: [{ text: { content: input.name } }],\n      };\n    }\n\n    if ('done' in input && input.done !== undefined) {\n      properties['Done'] = {\n        checkbox: input.done,\n      };\n    }\n\n    if ('due' in input) {\n      properties['Due'] = input.due\n        ? { date: { start: input.due } }\n        : { date: null };\n    }\n\n    if ('priority' in input) {\n      properties['Priority'] = input.priority\n        ? { select: { name: input.priority } }\n        : { select: null };\n    }\n\n    if ('projectId' in input && input.projectId) {\n      properties['Project'] = {\n        relation: [{ id: input.projectId }],\n      };\n    }\n\n    if ('teamId' in input && input.teamId) {\n      properties['Team'] = {\n        relation: [{ id: input.teamId }],\n      };\n    }\n\n    return properties;\n  }\n\n  /**\n   * Find tasks by completion status\n   */\n  async findByDone(done: boolean): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    return allTasks.filter(task => task.done === done);\n  }\n\n  /**\n   * Find incomplete tasks\n   */\n  async findIncomplete(): Promise<Task[]> {\n    return this.findByDone(false);\n  }\n\n  /**\n   * Find completed tasks\n   */\n  async findCompleted(): Promise<Task[]> {\n    return this.findByDone(true);\n  }\n\n  /**\n   * Find tasks by project\n   */\n  async findByProject(projectId: string): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    return allTasks.filter(task => task.projectId === projectId);\n  }\n\n  /**\n   * Find tasks by team\n   */\n  async findByTeam(teamId: string): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    return allTasks.filter(task => task.teamId === teamId);\n  }\n\n  /**\n   * Find tasks by priority\n   */\n  async findByPriority(priority: Priority): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    return allTasks.filter(task => task.priority === priority);\n  }\n\n  /**\n   * Find high priority tasks\n   */\n  async findHighPriority(): Promise<Task[]> {\n    return this.findByPriority('High');\n  }\n\n  /**\n   * Find overdue tasks (incomplete with due date in the past)\n   */\n  async findOverdue(): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    const now = new Date().toISOString();\n    \n    return allTasks.filter(task => \n      !task.done && task.due && task.due < now\n    );\n  }\n\n  /**\n   * Find tasks due today\n   */\n  async findDueToday(): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    const today = new Date().toISOString().split('T')[0];\n    \n    return allTasks.filter(task => \n      task.due && task.due.startsWith(today as string)\n    );\n  }\n\n  /**\n   * Find tasks due within the next N days\n   */\n  async findDueSoon(days: number = 7): Promise<Task[]> {\n    const allTasks = await this.findMany();\n    const now = new Date();\n    const futureDate = new Date(now);\n    futureDate.setDate(futureDate.getDate() + days);\n    \n    const nowStr = now.toISOString();\n    const futureStr = futureDate.toISOString();\n    \n    return allTasks.filter(task => \n      !task.done && task.due && task.due >= nowStr && task.due <= futureStr\n    );\n  }\n\n  /**\n   * Get task completion rate for a project\n   */\n  async getProjectCompletionRate(projectId: string): Promise<number> {\n    const tasks = await this.findByProject(projectId);\n    if (tasks.length === 0) return 0;\n    \n    const completed = tasks.filter(t => t.done).length;\n    return (completed / tasks.length) * 100;\n  }\n\n  /**\n   * Get task completion rate for a team\n   */\n  async getTeamCompletionRate(teamId: string): Promise<number> {\n    const tasks = await this.findByTeam(teamId);\n    if (tasks.length === 0) return 0;\n    \n    const completed = tasks.filter(t => t.done).length;\n    return (completed / tasks.length) * 100;\n  }\n}"
    },
    {
      "path": "./src/domain/repositories/team.repository.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 109,
      "chars": 2763,
      "approxTokens": 691.0,
      "sha256": "92E6DC2FBA2F9614C6391E1FEE7261BE869575BC8B5F78D9F48BB8947D46BEE2",
      "content": "import type { Team } from '../../core/types/schemas';\nimport type { NotionPage, PageProperties } from '../../core/types/notion';\nimport { BaseRepository } from './base.repository';\nimport { DATABASE_IDS } from '../../core/constants/databases';\n\n/**\n * Input for creating a new team\n */\nexport interface CreateTeamInput {\n  name: string;\n}\n\n/**\n * Input for updating a team\n */\nexport interface UpdateTeamInput {\n  name?: string;\n}\n\n/**\n * Repository for Team entities\n */\nexport class TeamRepository extends BaseRepository<Team, CreateTeamInput, UpdateTeamInput> {\n  constructor(mcp: any) {\n    super(mcp, DATABASE_IDS.TEAMS);\n  }\n\n  protected getEntityName(): string {\n    return 'Team';\n  }\n\n  protected toDomainEntity(page: NotionPage): Team {\n    const props = page.properties;\n\n    return {\n      id: page.id,\n      name: this.extractTitle(props, 'Name'),\n      meetings: this.extractRelation(props, 'Meetings'),\n      projects: this.extractRelation(props, 'Projects'),\n      projectsComplete: this.extractNumber(props, 'Projects Complete'),\n      tasks: this.extractRelation(props, 'Tasks'),\n      tasksCompleted: this.extractNumber(props, 'Tasks Completed'),\n    };\n  }\n\n  protected toNotionProperties(input: CreateTeamInput | UpdateTeamInput | Team): PageProperties {\n    const properties: PageProperties = {};\n\n    if ('name' in input && input.name !== undefined) {\n      properties['Name'] = {\n        title: [{ text: { content: input.name } }],\n      };\n    }\n\n    return properties;\n  }\n\n  /**\n   * Find teams by name (partial match)\n   */\n  async findByName(name: string): Promise<Team[]> {\n    const allTeams = await this.findMany();\n    return allTeams.filter(team => \n      team.name.toLowerCase().includes(name.toLowerCase())\n    );\n  }\n\n  /**\n   * Get team with all related projects\n   */\n  async findWithProjects(teamId: string): Promise<{ team: Team; projectIds: string[] }> {\n    const team = await this.findByIdOrThrow(teamId);\n    return {\n      team,\n      projectIds: team.projects,\n    };\n  }\n\n  /**\n   * Get team with all related tasks\n   */\n  async findWithTasks(teamId: string): Promise<{ team: Team; taskIds: string[] }> {\n    const team = await this.findByIdOrThrow(teamId);\n    return {\n      team,\n      taskIds: team.tasks,\n    };\n  }\n\n  /**\n   * Get team completion metrics\n   */\n  async getMetrics(teamId: string): Promise<{\n    team: Team;\n    projectsComplete: number;\n    tasksCompleted: number;\n    totalProjects: number;\n    totalTasks: number;\n  }> {\n    const team = await this.findByIdOrThrow(teamId);\n    return {\n      team,\n      projectsComplete: team.projectsComplete ?? 0,\n      tasksCompleted: team.tasksCompleted ?? 0,\n      totalProjects: team.projects.length,\n      totalTasks: team.tasks.length,\n    };\n  }\n}"
    },
    {
      "path": "./src/domain/repositories/__tests__/project.repository.test.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 76,
      "chars": 2652,
      "approxTokens": 663.0,
      "sha256": "18189D57A34C1650B75BFD81E6C737D52E6C8250829FA326F4E3B09E0155AE91",
      "content": "import { describe, it, expect, beforeEach } from 'vitest';\nimport { ProjectRepository } from '../project.repository';\nimport { MockMcpClient } from '../../../mcp/client';\n\ndescribe('ProjectRepository', () => {\n  let repository: ProjectRepository;\n  let mockClient: MockMcpClient;\n\n  beforeEach(() => {\n    mockClient = new MockMcpClient();\n    repository = new ProjectRepository(mockClient);\n  });\n\n  describe('create', () => {\n    it('should return a change proposal for project creation', async () => {\n      const input = {\n        name: 'Sprint 1',\n        status: 'Active' as const,\n        milestone: 'M1' as const,\n        phase: 'P1.1' as const,\n      };\n      \n      const proposal = await repository.create(input);\n\n      expect(proposal).toBeDefined();\n      expect(proposal.type).toBe('create');\n      expect(proposal.currentState).toBeNull();\n      expect(proposal.proposedState).toBeDefined();\n      expect(proposal.proposedState.name).toBe('Sprint 1');\n      expect(proposal.proposedState.status).toBe('Active');\n      expect(proposal.proposedState.milestone).toBe('M1');\n    });\n  });\n\n  describe('findByStatus', () => {\n    it('should filter projects by status', async () => {\n      const project1 = await repository.create({ name: 'Active Project', status: 'Active' });\n      const project2 = await repository.create({ name: 'Completed Project', status: 'Completed' });\n      \n      await repository.executeCreate(project1);\n      await repository.executeCreate(project2);\n\n      const activeProjects = await repository.findByStatus('Active');\n      expect(activeProjects.some(p => p.name === 'Active Project')).toBe(true);\n    });\n  });\n\n  describe('findActive', () => {\n    it('should return only active projects', async () => {\n      const project1 = await repository.create({ name: 'Active', status: 'Active' });\n      const project2 = await repository.create({ name: 'Done', status: 'Completed' });\n      \n      await repository.executeCreate(project1);\n      await repository.executeCreate(project2);\n\n      const active = await repository.findActive();\n      expect(active.length).toBeGreaterThan(0);\n      expect(active.every(p => p.status === 'Active')).toBe(true);\n    });\n  });\n\n  describe('findByMilestone', () => {\n    it('should filter projects by milestone', async () => {\n      const project = await repository.create({\n        name: 'M1 Project',\n        status: 'Active',\n        milestone: 'M1',\n      });\n      \n      await repository.executeCreate(project);\n\n      const m1Projects = await repository.findByMilestone('M1');\n      expect(m1Projects.some(p => p.name === 'M1 Project')).toBe(true);\n    });\n  });\n});"
    },
    {
      "path": "./src/domain/repositories/__tests__/task.repository.test.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 94,
      "chars": 3067,
      "approxTokens": 767.0,
      "sha256": "9F54EA530859B5B9B483DAC86029A6F80B00DFD973DEB81995F0F1F44E28566F",
      "content": "import { describe, it, expect, beforeEach } from 'vitest';\nimport { TaskRepository } from '../task.repository';\nimport { MockMcpClient } from '../../../mcp/client';\n\ndescribe('TaskRepository', () => {\n  let repository: TaskRepository;\n  let mockClient: MockMcpClient;\n\n  beforeEach(() => {\n    mockClient = new MockMcpClient();\n    repository = new TaskRepository(mockClient);\n  });\n\n  describe('create', () => {\n    it('should return a change proposal for task creation', async () => {\n      const input = {\n        name: 'Implement feature X',\n        done: false,\n        priority: 'High' as const,\n      };\n      \n      const proposal = await repository.create(input);\n\n      expect(proposal).toBeDefined();\n      expect(proposal.type).toBe('create');\n      expect(proposal.proposedState.name).toBe('Implement feature X');\n      expect(proposal.proposedState.done).toBe(false);\n      expect(proposal.proposedState.priority).toBe('High');\n    });\n  });\n\n  describe('findIncomplete', () => {\n    it('should return only incomplete tasks', async () => {\n      const task1 = await repository.create({ name: 'Todo', done: false });\n      const task2 = await repository.create({ name: 'Done', done: true });\n      \n      await repository.executeCreate(task1);\n      await repository.executeCreate(task2);\n\n      const incomplete = await repository.findIncomplete();\n      expect(incomplete.length).toBeGreaterThan(0);\n      expect(incomplete.every(t => !t.done)).toBe(true);\n    });\n  });\n\n  describe('findHighPriority', () => {\n    it('should return only high priority tasks', async () => {\n      const task = await repository.create({\n        name: 'Urgent task',\n        done: false,\n        priority: 'High',\n      });\n      \n      await repository.executeCreate(task);\n\n      const highPriority = await repository.findHighPriority();\n      expect(highPriority.length).toBeGreaterThan(0);\n      expect(highPriority.every(t => t.priority === 'High')).toBe(true);\n    });\n  });\n\n  describe('findOverdue', () => {\n    it('should return tasks that are past due', async () => {\n      const yesterday = new Date();\n      yesterday.setDate(yesterday.getDate() - 1);\n      \n      const task = await repository.create({\n        name: 'Overdue task',\n        done: false,\n        due: yesterday.toISOString(),\n      });\n      \n      await repository.executeCreate(task);\n\n      const overdue = await repository.findOverdue();\n      expect(overdue.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('getProjectCompletionRate', () => {\n    it('should calculate correct completion rate', async () => {\n      const projectId = 'test-project-id';\n      \n      const task1 = await repository.create({ name: 'Task 1', done: true, projectId });\n      const task2 = await repository.create({ name: 'Task 2', done: false, projectId });\n      \n      await repository.executeCreate(task1);\n      await repository.executeCreate(task2);\n\n      const rate = await repository.getProjectCompletionRate(projectId);\n      expect(rate).toBe(50); // 1 out of 2 tasks completed\n    });\n  });\n});"
    },
    {
      "path": "./src/domain/repositories/__tests__/team.repository.test.ts",
      "category": "domain",
      "startLine": 1,
      "endLine": 114,
      "chars": 4336,
      "approxTokens": 1084.0,
      "sha256": "7718B1B9F2FB93639E42C06ED26AC7F62D503BA69B4DFA7D891957C1A95709C3",
      "content": "import { describe, it, expect, beforeEach } from 'vitest';\nimport { TeamRepository } from '../team.repository';\nimport { MockMcpClient } from '../../../mcp/client';\n\ndescribe('TeamRepository', () => {\n  let repository: TeamRepository;\n  let mockClient: MockMcpClient;\n\n  beforeEach(() => {\n    mockClient = new MockMcpClient();\n    repository = new TeamRepository(mockClient);\n  });\n\n  describe('create', () => {\n    it('should return a change proposal for team creation', async () => {\n      const input = { name: 'Engineering Team' };\n      \n      const proposal = await repository.create(input);\n\n      expect(proposal).toBeDefined();\n      expect(proposal.type).toBe('create');\n      expect(proposal.currentState).toBeNull();\n      expect(proposal.proposedState).toBeDefined();\n      expect(proposal.proposedState.name).toBe('Engineering Team');\n      expect(proposal.validation.valid).toBe(true);\n      expect(proposal.diff).toBeDefined();\n      expect(proposal.diff.length).toBeGreaterThan(0);\n    });\n\n    it('should include property diffs in the proposal', async () => {\n      const input = { name: 'Design Team' };\n      \n      const proposal = await repository.create(input);\n\n      const nameDiff = proposal.diff.find(d => d.property === 'name');\n      expect(nameDiff).toBeDefined();\n      expect(nameDiff?.oldValue).toBeNull();\n      expect(nameDiff?.newValue).toBe('Design Team');\n    });\n  });\n\n  describe('update', () => {\n    it('should return a change proposal for team update', async () => {\n      // First create a team\n      const createProposal = await repository.create({ name: 'Original Team' });\n      const createdTeam = await repository.executeCreate(createProposal);\n\n      // Now update it\n      const updateProposal = await repository.update(createdTeam.id, { name: 'Updated Team' });\n\n      expect(updateProposal).toBeDefined();\n      expect(updateProposal.type).toBe('update');\n      expect(updateProposal.currentState).toBeDefined();\n      expect(updateProposal.currentState?.name).toBe('Original Team');\n      expect(updateProposal.proposedState.name).toBe('Updated Team');\n      expect(updateProposal.target.pageId).toBe(createdTeam.id);\n    });\n\n    it('should generate accurate diffs', async () => {\n      const createProposal = await repository.create({ name: 'Team A' });\n      const createdTeam = await repository.executeCreate(createProposal);\n\n      const updateProposal = await repository.update(createdTeam.id, { name: 'Team B' });\n\n      const nameDiff = updateProposal.diff.find(d => d.property === 'name');\n      expect(nameDiff).toBeDefined();\n      expect(nameDiff?.oldValue).toBe('Team A');\n      expect(nameDiff?.newValue).toBe('Team B');\n    });\n  });\n\n  describe('findById', () => {\n    it('should return null for non-existent team', async () => {\n      const team = await repository.findById('non-existent');\n      expect(team).toBeNull();\n    });\n\n    it('should return team after creation', async () => {\n      const createProposal = await repository.create({ name: 'Test Team' });\n      const createdTeam = await repository.executeCreate(createProposal);\n\n      const foundTeam = await repository.findById(createdTeam.id);\n      expect(foundTeam).toBeDefined();\n      expect(foundTeam?.name).toBe('Test Team');\n    });\n  });\n\n  describe('findByName', () => {\n    it('should find teams by partial name match', async () => {\n      const team1Proposal = await repository.create({ name: 'Engineering Team' });\n      const team2Proposal = await repository.create({ name: 'Product Team' });\n      await repository.executeCreate(team1Proposal);\n      await repository.executeCreate(team2Proposal);\n\n      const results = await repository.findByName('eng');\n      expect(results.length).toBeGreaterThan(0);\n      expect(results[0]?.name).toContain('Engineering');\n    });\n  });\n\n  describe('getMetrics', () => {\n    it('should return team metrics', async () => {\n      const createProposal = await repository.create({ name: 'Metrics Team' });\n      const createdTeam = await repository.executeCreate(createProposal);\n\n      const metrics = await repository.getMetrics(createdTeam.id);\n      \n      expect(metrics).toBeDefined();\n      expect(metrics.team.name).toBe('Metrics Team');\n      expect(metrics.totalProjects).toBe(0);\n      expect(metrics.totalTasks).toBe(0);\n    });\n  });\n});"
    },
    {
      "path": "./src/mcp/client.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 207,
      "chars": 5840,
      "approxTokens": 1460.0,
      "sha256": "9ADF32F5CDE16F71449910030B126DF1B7F17081DB110394416BBF16D0228D53",
      "content": "import type { DatabaseId } from '../core/constants/databases';\nimport type { McpClientOptions } from '../core/types/mcp';\nimport type { NotionPage, PageProperties, QueryParams, QueryResult } from '../core/types/notion';\n\n/**\n * Interface for MCP client operations\n * Abstracts the MCP tool calls for Notion operations\n */\nexport interface IMcpClient {\n  /**\n   * Query a database with filters and sorting\n   */\n  queryDatabase(params: QueryParams): Promise<QueryResult>;\n\n  /**\n   * Retrieve a single page by ID\n   */\n  getPage(pageId: string): Promise<NotionPage>;\n\n  /**\n   * Create a new page in a database\n   */\n  createPage(databaseId: DatabaseId, properties: PageProperties): Promise<NotionPage>;\n\n  /**\n   * Update properties of an existing page\n   */\n  updatePage(pageId: string, properties: PageProperties): Promise<NotionPage>;\n\n  /**\n   * Delete a page (archive it in Notion)\n   */\n  deletePage(pageId: string): Promise<void>;\n\n  /**\n   * Search for pages by title\n   */\n  search(query: string): Promise<NotionPage[]>;\n}\n\n/**\n * MCP Client for Notion integration\n * Provides methods to interact with the Notion API through MCP\n */\nexport class McpClient implements IMcpClient {\n  private connected: boolean = false;\n\n  constructor(_options: McpClientOptions) {\n    // TODO: Store configuration when implementation is complete\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Call an MCP tool with the given name and arguments\n   */\n  async callTool<T = unknown>(toolName: string, _args: Record<string, unknown>): Promise<T> {\n    // TODO: Implement actual MCP tool invocation via transport layer\n    throw new Error(`MCP tool invocation not implemented: ${toolName}`);\n  }\n\n  async queryDatabase(_params: QueryParams): Promise<QueryResult> {\n    throw new Error('Not implemented');\n  }\n\n  async getPage(_pageId: string): Promise<NotionPage> {\n    throw new Error('Not implemented');\n  }\n\n  async createPage(_databaseId: DatabaseId, _properties: PageProperties): Promise<NotionPage> {\n    throw new Error('Not implemented');\n  }\n\n  async updatePage(_pageId: string, _properties: PageProperties): Promise<NotionPage> {\n    throw new Error('Not implemented');\n  }\n\n  async deletePage(_pageId: string): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async search(_query: string): Promise<NotionPage[]> {\n    throw new Error('Not implemented');\n  }\n}\n\n/**\n * Mock MCP client for testing\n */\nexport class MockMcpClient implements IMcpClient {\n  private pages: Map<string, NotionPage> = new Map();\n\n  async queryDatabase(params: QueryParams): Promise<QueryResult> {\n    const pages = Array.from(this.pages.values()).filter(\n      (page) => page.parent.database_id === params.database_id\n    );\n    return {\n      results: pages,\n      has_more: false,\n      next_cursor: null,\n    };\n  }\n\n  async getPage(pageId: string): Promise<NotionPage> {\n    const page = this.pages.get(pageId);\n    if (!page) {\n      throw new Error(`Page not found: ${pageId}`);\n    }\n    return page;\n  }\n\n  async createPage(databaseId: DatabaseId, properties: PageProperties): Promise<NotionPage> {\n    const page: NotionPage = {\n      id: `mock-${Date.now()}`,\n      created_time: new Date().toISOString(),\n      last_edited_time: new Date().toISOString(),\n      parent: {\n        type: 'database_id',\n        database_id: databaseId,\n      },\n      properties: this.convertToNotionProperties(properties),\n      url: `https://notion.so/mock-${Date.now()}`,\n    };\n    this.pages.set(page.id, page);\n    return page;\n  }\n\n  async updatePage(pageId: string, properties: PageProperties): Promise<NotionPage> {\n    const page = await this.getPage(pageId);\n    page.properties = {\n      ...page.properties,\n      ...this.convertToNotionProperties(properties),\n    };\n    page.last_edited_time = new Date().toISOString();\n    return page;\n  }\n\n  async deletePage(pageId: string): Promise<void> {\n    this.pages.delete(pageId);\n  }\n\n  async search(query: string): Promise<NotionPage[]> {\n    return Array.from(this.pages.values()).filter((page) => {\n      const titleProp = Object.values(page.properties).find((p: any) => p.type === 'title');\n      if (titleProp && titleProp.type === 'title') {\n        return titleProp.title.some((t: any) => t.plain_text.includes(query));\n      }\n      return false;\n    });\n  }\n\n  private convertToNotionProperties(properties: PageProperties): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    for (const [key, value] of Object.entries(properties)) {\n      if ('title' in value && value.title) {\n        result[key] = {\n          type: 'title',\n          title: value.title.map((t: any) => ({\n            plain_text: t.text?.content || '',\n          })),\n        };\n      } else if ('rich_text' in value && value.rich_text) {\n        result[key] = {\n          type: 'rich_text',\n          rich_text: value.rich_text.map((t: any) => ({\n            plain_text: t.text?.content || '',\n          })),\n        };\n      } else if ('number' in value) {\n        result[key] = {\n          type: 'number',\n          number: value.number,\n        };\n      } else if ('select' in value) {\n        result[key] = {\n          type: 'select',\n          select: value.select,\n        };\n      } else if ('multi_select' in value) {\n        result[key] = {\n          type: 'multi_select',\n          multi_select: value.multi_select,\n        };\n      } else if ('date' in value) {\n        result[key] = {\n          type: 'date',\n          date: value.date,\n        };\n      } else if ('checkbox' in value) {\n        result[key] = {\n          type: 'checkbox',\n          checkbox: value.checkbox,\n        };\n      } else if ('relation' in value) {\n        result[key] = {\n          type: 'relation',\n          relation: value.relation,\n        };\n      }\n    }\n\n    return result;\n  }\n}"
    },
    {
      "path": "./src/mcp/transport.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 198,
      "chars": 5294,
      "approxTokens": 1324.0,
      "sha256": "34FCA8502455605EF2C1721B619352519848205E49ABC24D9082A0CEC59FD4C9",
      "content": "/**\n * Stdio transport for communicating with @notionhq/notion-mcp-server\n * \n * Spawns the MCP server as a child process and handles JSON-RPC message exchange\n * via stdio (stdin/stdout).\n */\n\nimport { spawn, type ChildProcess } from \"child_process\";\nimport { EventEmitter } from \"events\";\nimport type { JsonRpcRequest, JsonRpcResponse, McpTransport } from \"../core/types/mcp.js\";\nimport { McpTransportError, McpConnectionError } from \"../core/errors/index.js\";\nimport { MCP_SERVER } from \"../core/constants/index.js\";\n\nexport interface StdioTransportOptions {\n  notionToken: string;\n  serverCommand?: string;\n  serverArgs?: string[];\n}\n\nexport class StdioTransport extends EventEmitter implements McpTransport {\n  private process: ChildProcess | null = null;\n  private connected = false;\n  private buffer = \"\";\n  private pendingRequests = new Map<\n    number | string,\n    {\n      resolve: (response: JsonRpcResponse) => void;\n      reject: (error: Error) => void;\n    }\n  >();\n\n  constructor(private readonly options: StdioTransportOptions) {\n    super();\n  }\n\n  /**\n   * Connect to the MCP server by spawning the child process\n   */\n  connect(): Promise<void> {\n    if (this.connected) {\n      return Promise.resolve();\n    }\n\n    const command = this.options.serverCommand ?? MCP_SERVER.COMMAND;\n    const args = this.options.serverArgs ?? MCP_SERVER.ARGS;\n\n    try {\n      this.process = spawn(command, args, {\n        env: {\n          ...process.env,\n          NOTION_TOKEN: this.options.notionToken,\n        },\n        stdio: [\"pipe\", \"pipe\", \"inherit\"],\n      });\n\n      this.setupProcessHandlers();\n      this.connected = true;\n      this.emit(\"connected\");\n      return Promise.resolve();\n    } catch (error) {\n      throw new McpConnectionError(\"Failed to spawn MCP server process\", error);\n    }\n  }\n\n  /**\n   * Disconnect from the MCP server\n   */\n  async disconnect(): Promise<void> {\n    if (!this.connected || !this.process) {\n      return;\n    }\n\n    return new Promise((resolve) => {\n      if (!this.process) {\n        resolve();\n        return;\n      }\n\n      this.process.once(\"close\", () => {\n        this.connected = false;\n        this.process = null;\n        this.emit(\"disconnected\");\n        resolve();\n      });\n\n      this.process.kill(\"SIGTERM\");\n\n      // Force kill after 5 seconds\n      setTimeout(() => {\n        if (this.process) {\n          this.process.kill(\"SIGKILL\");\n        }\n      }, 5000);\n    });\n  }\n\n  /**\n   * Send a JSON-RPC request and wait for the response\n   */\n  async send(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    if (!this.connected || !this.process || !this.process.stdin) {\n      throw new McpTransportError(\"Transport not connected\");\n    }\n\n    return new Promise((resolve, reject) => {\n      // Store the pending request\n      this.pendingRequests.set(request.id, { resolve, reject });\n\n      // Serialize and send the request\n      const message = JSON.stringify(request) + \"\\n\";\n      this.process!.stdin!.write(message, (error) => {\n        if (error) {\n          this.pendingRequests.delete(request.id);\n          reject(new McpTransportError(\"Failed to write to stdin\", error));\n        }\n      });\n    });\n  }\n\n  /**\n   * Check if transport is connected\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Set up event handlers for the child process\n   */\n  private setupProcessHandlers(): void {\n    if (!this.process) return;\n\n    // Handle stdout data (JSON-RPC responses)\n    this.process.stdout?.on(\"data\", (data: Buffer) => {\n      this.handleStdout(data);\n    });\n\n    // Handle process errors\n    this.process.on(\"error\", (error) => {\n      this.emit(\"error\", new McpTransportError(\"Process error\", error));\n    });\n\n    // Handle process exit\n    this.process.on(\"close\", (code, signal) => {\n      this.connected = false;\n      this.emit(\"close\", { code, signal });\n\n      // Reject all pending requests\n      for (const { reject } of this.pendingRequests.values()) {\n        reject(new McpTransportError(\"Process closed unexpectedly\"));\n      }\n      this.pendingRequests.clear();\n    });\n  }\n\n  /**\n   * Handle stdout data from the child process\n   * \n   * Messages are newline-delimited JSON-RPC responses.\n   * We need to handle partial messages across multiple data events.\n   */\n  private handleStdout(data: Buffer): void {\n    this.buffer += data.toString();\n\n    // Split by newlines\n    const lines = this.buffer.split(\"\\n\");\n\n    // Keep the last incomplete line in the buffer\n    this.buffer = lines.pop() ?? \"\";\n\n    // Process complete lines\n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const response = JSON.parse(line) as JsonRpcResponse;\n          this.handleResponse(response);\n        } catch (error) {\n          this.emit(\"error\", new McpTransportError(\"Failed to parse JSON-RPC response\", error));\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle a parsed JSON-RPC response\n   */\n  private handleResponse(response: JsonRpcResponse): void {\n    const pending = this.pendingRequests.get(response.id);\n\n    if (!pending) {\n      this.emit(\"error\", new McpTransportError(`No pending request for response ID: ${response.id}`));\n      return;\n    }\n\n    this.pendingRequests.delete(response.id);\n    pending.resolve(response);\n  }\n}"
    },
    {
      "path": "./src/mcp/middleware/cache.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 96,
      "chars": 2323,
      "approxTokens": 581.0,
      "sha256": "70A9E0088F7EB27E279C02D51DB087A7472853E1647F9BD2303CA8402B285B31",
      "content": "/**\n * Cache middleware\n * \n * Caches responses for read-only operations to reduce API calls.\n */\n\nimport type { McpMiddleware, McpRequest, McpResponse } from \"../../core/types/mcp.js\";\n\nexport interface CacheOptions {\n  enabled?: boolean;\n  ttl?: number; // Time to live in milliseconds\n  maxSize?: number; // Maximum cache entries\n}\n\ninterface CacheEntry {\n  response: McpResponse;\n  timestamp: number;\n}\n\nexport function createCacheMiddleware(options: CacheOptions = {}): McpMiddleware {\n  const { enabled = true, ttl = 60000, maxSize = 100 } = options;\n\n  const cache = new Map<string, CacheEntry>();\n\n  // Periodically clean expired entries\n  const cleanInterval = setInterval(() => {\n    const now = Date.now();\n    for (const [key, entry] of cache.entries()) {\n      if (now - entry.timestamp > ttl) {\n        cache.delete(key);\n      }\n    }\n  }, ttl);\n\n  // Clean up interval on process exit\n  if (typeof process !== \"undefined\") {\n    process.once(\"beforeExit\", () => clearInterval(cleanInterval));\n  }\n\n  return async (req: McpRequest, next: () => Promise<McpResponse>): Promise<McpResponse> => {\n    if (!enabled || !isCacheable(req.tool)) {\n      return next();\n    }\n\n    const cacheKey = generateCacheKey(req);\n    const cached = cache.get(cacheKey);\n\n    // Return cached response if valid\n    if (cached && Date.now() - cached.timestamp < ttl) {\n      return cached.response;\n    }\n\n    // Execute request and cache the response\n    const response = await next();\n\n    // Enforce max cache size\n    if (cache.size >= maxSize) {\n      // Remove oldest entry\n      const oldestKey = cache.keys().next().value as string;\n      cache.delete(oldestKey);\n    }\n\n    cache.set(cacheKey, {\n      response,\n      timestamp: Date.now(),\n    });\n\n    return response;\n  };\n}\n\n/**\n * Determine if a tool call is cacheable (read-only operations)\n */\nfunction isCacheable(tool: string): boolean {\n  const readOnlyTools = [\n    \"retrieve-a-data-source\",\n    \"query-data-source\",\n    \"retrieve-a-page\",\n    \"get-block-children\",\n    \"retrieve-a-block\",\n    \"post-search\",\n    \"get-self\",\n    \"get-user\",\n    \"get-users\",\n  ];\n\n  return readOnlyTools.includes(tool);\n}\n\n/**\n * Generate a cache key from request\n */\nfunction generateCacheKey(req: McpRequest): string {\n  return `${req.tool}:${JSON.stringify(req.params)}`;\n}"
    },
    {
      "path": "./src/mcp/middleware/index.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 8,
      "chars": 150,
      "approxTokens": 38.0,
      "sha256": "3155BDAF62F2B11E425894963B7C11D4B86629F67369DEFDB698F302D262D9ED",
      "content": "/**\n * Middleware exports\n */\n\nexport * from \"./rate-limiter.js\";\nexport * from \"./retry.js\";\nexport * from \"./logger.js\";\nexport * from \"./cache.js\";"
    },
    {
      "path": "./src/mcp/middleware/logger.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 75,
      "chars": 1931,
      "approxTokens": 483.0,
      "sha256": "5C0027D462BC52A9355B43693C7C1D64A5D158DF79EA74575586174980FECDA5",
      "content": "/**\n * Logger middleware\n * \n * Logs MCP requests and responses for debugging.\n */\n\nimport type { McpMiddleware, McpRequest, McpResponse } from \"../../core/types/mcp.js\";\n\nexport interface LoggerOptions {\n  enabled?: boolean;\n  logRequests?: boolean;\n  logResponses?: boolean;\n  logErrors?: boolean;\n  logger?: Logger;\n}\n\nexport interface Logger {\n  debug(message: string, data?: unknown): void;\n  info(message: string, data?: unknown): void;\n  warn(message: string, data?: unknown): void;\n  error(message: string, data?: unknown): void;\n}\n\nconst defaultLogger: Logger = {\n  debug: (message, data) => console.debug(`[MCP] ${message}`, data ?? \"\"),\n  info: (message, data) => console.info(`[MCP] ${message}`, data ?? \"\"),\n  warn: (message, data) => console.warn(`[MCP] ${message}`, data ?? \"\"),\n  error: (message, data) => console.error(`[MCP] ${message}`, data ?? \"\"),\n};\n\nexport function createLoggerMiddleware(options: LoggerOptions = {}): McpMiddleware {\n  const {\n    enabled = true,\n    logRequests = true,\n    logResponses = true,\n    logErrors = true,\n    logger = defaultLogger,\n  } = options;\n\n  return async (req: McpRequest, next: () => Promise<McpResponse>): Promise<McpResponse> => {\n    if (!enabled) {\n      return next();\n    }\n\n    if (logRequests) {\n      logger.debug(`Request: ${req.tool}`, {\n        params: req.params,\n        timestamp: req.timestamp,\n      });\n    }\n\n    const startTime = Date.now();\n\n    try {\n      const response = await next();\n\n      if (logResponses) {\n        logger.debug(`Response: ${req.tool}`, {\n          duration: response.duration,\n          timestamp: response.timestamp,\n        });\n      }\n\n      return response;\n    } catch (error) {\n      if (logErrors) {\n        logger.error(`Error: ${req.tool}`, {\n          error: error instanceof Error ? error.message : String(error),\n          duration: Date.now() - startTime,\n        });\n      }\n      throw error;\n    }\n  };\n}"
    },
    {
      "path": "./src/mcp/middleware/rate-limiter.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 69,
      "chars": 1877,
      "approxTokens": 469.0,
      "sha256": "7509E9B11A87DD5CFA616B5A6C9A9B32BCA53AFECA2B51668E09122BFD7F5571",
      "content": "/**\n * Rate limiter middleware\n * \n * Enforces a maximum number of requests per second to prevent API throttling.\n */\n\nimport type { McpMiddleware, McpRequest, McpResponse } from \"../../core/types/mcp.js\";\n\nexport interface RateLimiterOptions {\n  requestsPerSecond: number;\n}\n\nexport function createRateLimiter(options: RateLimiterOptions): McpMiddleware {\n  const { requestsPerSecond } = options;\n  const minInterval = 1000 / requestsPerSecond;\n  let lastRequestTime = 0;\n  const queue: Array<() => void> = [];\n  let processing = false;\n\n  const processQueue = (): void => {\n    if (processing || queue.length === 0) {\n      return;\n    }\n\n    processing = true;\n\n    const run = (): void => {\n      while (queue.length > 0) {\n        const now = Date.now();\n        const timeSinceLastRequest = now - lastRequestTime;\n\n        if (timeSinceLastRequest >= minInterval) {\n          // Execute next request immediately\n          lastRequestTime = now;\n          const next = queue.shift();\n          next?.();\n          // Loop to check if we can process another immediately\n        } else {\n          // Wait before executing next request\n          const delay = minInterval - timeSinceLastRequest;\n          setTimeout(() => {\n            lastRequestTime = Date.now();\n            const next = queue.shift();\n            next?.();\n            // After executing one delayed request, continue processing\n            run();\n          }, delay);\n          return;\n        }\n      }\n\n      // No more queued requests; allow processing to be restarted\n      processing = false;\n    };\n\n    run();\n  };\n\n  return async (_req: McpRequest, next: () => Promise<McpResponse>): Promise<McpResponse> => {\n    return new Promise((resolve, reject) => {\n      queue.push(() => {\n        next()\n          .then(resolve)\n          .catch(reject);\n      });\n      processQueue();\n    });\n  };\n}"
    },
    {
      "path": "./src/mcp/middleware/retry.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 85,
      "chars": 2215,
      "approxTokens": 554.0,
      "sha256": "C4066885C94DB516EFB66F1F58CBC768F96FC100C0AE8C166FE36A0850A15985",
      "content": "/**\n * Retry middleware\n * \n * Automatically retries failed requests with exponential backoff.\n */\n\nimport type { McpMiddleware, McpRequest, McpResponse } from \"../../core/types/mcp.js\";\nimport { MCP_DEFAULTS } from \"../../core/constants/index.js\";\n\nexport interface RetryOptions {\n  maxRetries?: number;\n  backoff?: \"exponential\" | \"linear\";\n  initialDelay?: number;\n  maxDelay?: number;\n  shouldRetry?: (error: Error) => boolean;\n}\n\nexport function createRetryMiddleware(options: RetryOptions = {}): McpMiddleware {\n  const {\n    maxRetries = MCP_DEFAULTS.MAX_RETRIES,\n    backoff = \"exponential\",\n    initialDelay = MCP_DEFAULTS.RETRY_BACKOFF_BASE,\n    maxDelay = MCP_DEFAULTS.RETRY_BACKOFF_MAX,\n    shouldRetry = defaultShouldRetry,\n  } = options;\n\n  return async (_req: McpRequest, next: () => Promise<McpResponse>): Promise<McpResponse> => {\n    let lastError: Error | undefined;\n    let attempt = 0;\n\n    while (attempt <= maxRetries) {\n      try {\n        return await next();\n      } catch (error) {\n        lastError = error as Error;\n        attempt++;\n\n        // Don't retry if we've exhausted attempts or error is not retryable\n        if (attempt > maxRetries || !shouldRetry(lastError)) {\n          throw lastError;\n        }\n\n        // Calculate delay\n        const delay = calculateDelay(attempt, backoff, initialDelay, maxDelay);\n\n        // Wait before retry\n        await sleep(delay);\n      }\n    }\n\n    throw lastError;\n  };\n}\n\nfunction calculateDelay(\n  attempt: number,\n  backoff: \"exponential\" | \"linear\",\n  initialDelay: number,\n  maxDelay: number\n): number {\n  const delay =\n    backoff === \"exponential\"\n      ? initialDelay * Math.pow(2, attempt - 1)\n      : initialDelay * attempt;\n\n  return Math.min(delay, maxDelay);\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction defaultShouldRetry(error: Error): boolean {\n  // Retry on network errors and timeouts\n  const retryableErrors = [\n    \"ECONNRESET\",\n    \"ENOTFOUND\",\n    \"ETIMEDOUT\",\n    \"ECONNREFUSED\",\n    \"MCP_TIMEOUT_ERROR\",\n    \"MCP_TRANSPORT_ERROR\",\n  ];\n\n  return retryableErrors.some((code) => error.message.includes(code) || error.name.includes(code));\n}"
    },
    {
      "path": "./src/mcp/tools/blocks.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 75,
      "chars": 1638,
      "approxTokens": 410.0,
      "sha256": "F6C66D717B6A4A89AD6A68634AE0CAC2751DC9C9FBBCF314C4449271863732CD",
      "content": "/**\n * Block tool wrappers\n * \n * Typed wrappers for Notion block operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\n\nexport interface Block {\n  object: \"block\";\n  id: string;\n  type: string;\n  [key: string]: unknown;\n}\n\nexport interface AppendBlocksParams extends Record<string, unknown> {\n  block_id: string;\n  children: unknown[];\n}\n\nexport interface UpdateBlockParams extends Record<string, unknown> {\n  block_id: string;\n}\n\nexport class BlockTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Get children blocks of a parent block or page\n   */\n  async getBlockChildren(blockId: string, startCursor?: string): Promise<{\n    results: Block[];\n    next_cursor: string | null;\n    has_more: boolean;\n  }> {\n    return this.client.callTool(\"get-block-children\", {\n      block_id: blockId,\n      start_cursor: startCursor,\n    });\n  }\n\n  /**\n   * Retrieve a block by ID\n   */\n  async getBlock(blockId: string): Promise<Block> {\n    return this.client.callTool<Block>(\"retrieve-a-block\", {\n      block_id: blockId,\n    });\n  }\n\n  /**\n   * Append blocks to a parent block or page\n   */\n  async appendBlocks(params: AppendBlocksParams): Promise<{\n    results: Block[];\n  }> {\n    return this.client.callTool(\"patch-block-children\", params);\n  }\n\n  /**\n   * Update a block\n   */\n  async updateBlock(params: UpdateBlockParams): Promise<Block> {\n    return this.client.callTool<Block>(\"update-a-block\", params);\n  }\n\n  /**\n   * Delete a block\n   */\n  async deleteBlock(blockId: string): Promise<Block> {\n    return this.client.callTool<Block>(\"delete-a-block\", {\n      block_id: blockId,\n    });\n  }\n}"
    },
    {
      "path": "./src/mcp/tools/comments.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 79,
      "chars": 1689,
      "approxTokens": 422.0,
      "sha256": "E08325EEF34CDEF4F76A6D7AA55415DEA7FC8CC7ABE007D9DBFDA9CB341130DA",
      "content": "/**\n * Comment tool wrappers\n * \n * Typed wrappers for Notion comment operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\n\nexport interface Comment {\n  object: \"comment\";\n  id: string;\n  parent: {\n    type: \"page_id\" | \"block_id\";\n    page_id?: string;\n    block_id?: string;\n  };\n  discussion_id: string;\n  created_time: string;\n  last_edited_time: string;\n  created_by: {\n    object: \"user\";\n    id: string;\n  };\n  rich_text: Array<{\n    type: \"text\";\n    text: {\n      content: string;\n    };\n    plain_text: string;\n  }>;\n}\n\nexport interface CreateCommentParams extends Record<string, unknown> {\n  parent: {\n    page_id?: string;\n    block_id?: string;\n  };\n  rich_text: Array<{\n    text: {\n      content: string;\n    };\n  }>;\n  discussion_id?: string;\n}\n\nexport class CommentTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Create a comment on a page or block\n   */\n  async createComment(params: CreateCommentParams): Promise<Comment> {\n    return this.client.callTool<Comment>(\"create-a-comment\", params);\n  }\n\n  /**\n   * Retrieve a comment by ID\n   */\n  async getComment(commentId: string): Promise<Comment> {\n    return this.client.callTool<Comment>(\"retrieve-a-comment\", {\n      comment_id: commentId,\n    });\n  }\n\n  /**\n   * Get comments on a page or block\n   * Note: The actual MCP tool name may vary - verify against @notionhq/notion-mcp-server\n   */\n  async getComments(blockId: string, startCursor?: string): Promise<{\n    results: Comment[];\n    next_cursor: string | null;\n    has_more: boolean;\n  }> {\n    return this.client.callTool(\"retrieve-comments\", {\n      block_id: blockId,\n      start_cursor: startCursor,\n    });\n  }\n}"
    },
    {
      "path": "./src/mcp/tools/databases.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 41,
      "chars": 1071,
      "approxTokens": 268.0,
      "sha256": "B4C60907CE191C53450A49EDFE3EDFA501D7D10DC06CDEB4EBB9DBB285D9C564",
      "content": "/**\n * Database tool wrappers\n * \n * Typed wrappers for Notion database operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\nimport type { QueryParams, QueryResult } from \"../../core/types/notion.js\";\n\nexport class DatabaseTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Query a database with filters, sorts, and pagination\n   */\n  async queryDatabase(params: QueryParams): Promise<QueryResult> {\n    return this.client.callTool<QueryResult>(\"query-data-source\", {\n      database_id: params.database_id,\n      filter: params.filter,\n      sorts: params.sorts,\n      page_size: params.page_size,\n      start_cursor: params.start_cursor,\n    });\n  }\n\n  /**\n   * Retrieve database metadata\n   */\n  async getDatabase(databaseId: string): Promise<unknown> {\n    return this.client.callTool(\"retrieve-a-data-source\", {\n      database_id: databaseId,\n    });\n  }\n\n  /**\n   * List available data source templates\n   */\n  async listTemplates(): Promise<unknown> {\n    return this.client.callTool(\"list-data-source-templates\", {});\n  }\n}"
    },
    {
      "path": "./src/mcp/tools/index.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 10,
      "chars": 210,
      "approxTokens": 52.0,
      "sha256": "305B06F5671511C156FF5C20FFAFAA14FC004337583D94516F9626EB02512BBF",
      "content": "/**\n * Tool wrappers exports\n */\n\nexport * from \"./databases.js\";\nexport * from \"./pages.js\";\nexport * from \"./blocks.js\";\nexport * from \"./search.js\";\nexport * from \"./comments.js\";\nexport * from \"./users.js\";"
    },
    {
      "path": "./src/mcp/tools/pages.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 65,
      "chars": 1544,
      "approxTokens": 386.0,
      "sha256": "CEA167B020860E329066D64C8FE0BB58F8E3DD68CEBBBB7599BDF7D066C61038",
      "content": "/**\n * Page tool wrappers\n * \n * Typed wrappers for Notion page operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\nimport type { NotionPage } from \"../../core/types/notion.js\";\n\nexport interface CreatePageParams extends Record<string, unknown> {\n  parent: {\n    database_id: string;\n  };\n  properties: Record<string, unknown>;\n  children?: unknown[];\n}\n\nexport interface UpdatePageParams extends Record<string, unknown> {\n  page_id: string;\n  properties?: Record<string, unknown>;\n  archived?: boolean;\n}\n\nexport class PageTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Create a new page in a database\n   */\n  async createPage(params: CreatePageParams): Promise<NotionPage> {\n    return this.client.callTool<NotionPage>(\"post-page\", params);\n  }\n\n  /**\n   * Update an existing page\n   */\n  async updatePage(params: UpdatePageParams): Promise<NotionPage> {\n    return this.client.callTool<NotionPage>(\"patch-page\", {\n      page_id: params.page_id,\n      properties: params.properties,\n      archived: params.archived,\n    });\n  }\n\n  /**\n   * Retrieve a page by ID\n   */\n  async getPage(pageId: string): Promise<NotionPage> {\n    return this.client.callTool<NotionPage>(\"retrieve-a-page\", {\n      page_id: pageId,\n    });\n  }\n\n  /**\n   * Move a page to a different parent\n   */\n  async movePage(pageId: string, parentId: string): Promise<NotionPage> {\n    return this.client.callTool<NotionPage>(\"move-page\", {\n      page_id: pageId,\n      parent: {\n        page_id: parentId,\n      },\n    });\n  }\n}"
    },
    {
      "path": "./src/mcp/tools/search.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 66,
      "chars": 1366,
      "approxTokens": 342.0,
      "sha256": "30F70A44447CB776E7759D200DB596C06239452FB8F92BF69398DDCC91667803",
      "content": "/**\n * Search tool wrappers\n * \n * Typed wrappers for Notion search operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\nimport type { NotionPage } from \"../../core/types/notion.js\";\n\nexport interface SearchParams extends Record<string, unknown> {\n  query?: string;\n  filter?: {\n    value: \"page\" | \"database\";\n    property: \"object\";\n  };\n  sort?: {\n    direction: \"ascending\" | \"descending\";\n    timestamp: \"last_edited_time\";\n  };\n  start_cursor?: string;\n  page_size?: number;\n}\n\nexport interface SearchResult {\n  object: \"list\";\n  results: NotionPage[];\n  next_cursor: string | null;\n  has_more: boolean;\n}\n\nexport class SearchTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Search pages and databases by title\n   */\n  async search(params: SearchParams = {}): Promise<SearchResult> {\n    return this.client.callTool<SearchResult>(\"post-search\", params);\n  }\n\n  /**\n   * Search only pages\n   */\n  async searchPages(query?: string): Promise<SearchResult> {\n    return this.search({\n      query,\n      filter: {\n        value: \"page\",\n        property: \"object\",\n      },\n    });\n  }\n\n  /**\n   * Search only databases\n   */\n  async searchDatabases(query?: string): Promise<SearchResult> {\n    return this.search({\n      query,\n      filter: {\n        value: \"database\",\n        property: \"object\",\n      },\n    });\n  }\n}"
    },
    {
      "path": "./src/mcp/tools/users.ts",
      "category": "mcp",
      "startLine": 1,
      "endLine": 55,
      "chars": 1012,
      "approxTokens": 253.0,
      "sha256": "47659D74C0A30F026798C1C03BED68FE7DBDE084908659F42C0732D0F2C88302",
      "content": "/**\n * User tool wrappers\n * \n * Typed wrappers for Notion user operations via MCP.\n */\n\nimport type { McpClient } from \"../client.js\";\n\nexport interface User {\n  object: \"user\";\n  id: string;\n  type?: \"person\" | \"bot\";\n  name?: string;\n  avatar_url?: string;\n  person?: {\n    email?: string;\n  };\n  bot?: {\n    owner?: unknown;\n    workspace_name?: string;\n  };\n}\n\nexport class UserTools {\n  constructor(private readonly client: McpClient) {}\n\n  /**\n   * Get the current bot user\n   */\n  async getSelf(): Promise<User> {\n    return this.client.callTool<User>(\"get-self\", {});\n  }\n\n  /**\n   * Get a user by ID\n   */\n  async getUser(userId: string): Promise<User> {\n    return this.client.callTool<User>(\"get-user\", {\n      user_id: userId,\n    });\n  }\n\n  /**\n   * List all users\n   */\n  async listUsers(startCursor?: string): Promise<{\n    results: User[];\n    next_cursor: string | null;\n    has_more: boolean;\n  }> {\n    return this.client.callTool(\"get-users\", {\n      start_cursor: startCursor,\n    });\n  }\n}"
    },
    {
      "path": "./src/query/builder.test.ts",
      "category": "query",
      "startLine": 1,
      "endLine": 315,
      "chars": 7964,
      "approxTokens": 1991.0,
      "sha256": "148CDD71B1434345A5874D9053C9CAA4E1C5B9D688246D04E62F07F796BED279",
      "content": "/**\r\n * Query Builder Tests\r\n * \r\n * Run with: node --test src/query/builder.test.ts\r\n * Or with a test runner like Vitest\r\n */\r\n\r\nimport { QueryBuilder, QueryBuilderHelpers } from \"./builder\";\r\n\r\n// Simple test runner (can be replaced with proper test framework)\r\nfunction describe(name: string, fn: () => void) {\r\n  console.log(`\\n${name}`);\r\n  fn();\r\n}\r\n\r\nfunction it(name: string, fn: () => void) {\r\n  try {\r\n    fn();\r\n    console.log(`  ✓ ${name}`);\r\n  } catch (error) {\r\n    console.log(`  ✗ ${name}`);\r\n    console.error(`    ${error}`);\r\n  }\r\n}\r\n\r\nfunction expect(actual: unknown) {\r\n  return {\r\n    toEqual(expected: unknown) {\r\n      const actualStr = JSON.stringify(actual, null, 2);\r\n      const expectedStr = JSON.stringify(expected, null, 2);\r\n      if (actualStr !== expectedStr) {\r\n        throw new Error(\r\n          `Expected:\\n${expectedStr}\\n\\nActual:\\n${actualStr}`\r\n        );\r\n      }\r\n    },\r\n    toBeDefined() {\r\n      if (actual === undefined) {\r\n        throw new Error(\"Expected value to be defined\");\r\n      }\r\n    },\r\n    toBeUndefined() {\r\n      if (actual !== undefined) {\r\n        throw new Error(\"Expected value to be undefined\");\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n// Tests\r\ndescribe(\"QueryBuilder\", () => {\r\n  describe(\"Basic Filters\", () => {\r\n    it(\"should create a simple select filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"status\", \"select\", \"equals\", \"Active\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"status\",\r\n        select: { equals: \"Active\" },\r\n      });\r\n    });\r\n\r\n    it(\"should create a checkbox filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"done\", \"checkbox\", \"equals\", false)\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"done\",\r\n        checkbox: { equals: false },\r\n      });\r\n    });\r\n\r\n    it(\"should create a number filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"count\", \"number\", \"greater_than\", 5)\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"count\",\r\n        number: { greater_than: 5 },\r\n      });\r\n    });\r\n\r\n    it(\"should create a text filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"name\", \"title\", \"contains\", \"Project\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"name\",\r\n        title: { contains: \"Project\" },\r\n      });\r\n    });\r\n\r\n    it(\"should create a date filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"due\", \"date\", \"after\", \"2025-01-01\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"due\",\r\n        date: { after: \"2025-01-01\" },\r\n      });\r\n    });\r\n\r\n    it(\"should handle is_empty operator without value\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"description\", \"rich_text\", \"is_empty\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"description\",\r\n        rich_text: { is_empty: true },\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"Multiple Filters\", () => {\r\n    it(\"should combine multiple filters with AND\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"status\", \"select\", \"equals\", \"Active\")\r\n        .where(\"priority\", \"select\", \"equals\", \"High\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        and: [\r\n          {\r\n            property: \"status\",\r\n            select: { equals: \"Active\" },\r\n          },\r\n          {\r\n            property: \"priority\",\r\n            select: { equals: \"High\" },\r\n          },\r\n        ],\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"Compound Filters\", () => {\r\n    it(\"should create an AND compound filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .and((qb) => {\r\n          qb.where(\"status\", \"select\", \"equals\", \"Active\").where(\r\n            \"milestone\",\r\n            \"select\",\r\n            \"equals\",\r\n            \"M2\"\r\n          );\r\n        })\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        and: [\r\n          {\r\n            property: \"status\",\r\n            select: { equals: \"Active\" },\r\n          },\r\n          {\r\n            property: \"milestone\",\r\n            select: { equals: \"M2\" },\r\n          },\r\n        ],\r\n      });\r\n    });\r\n\r\n    it(\"should create an OR compound filter\", () => {\r\n      const query = new QueryBuilder()\r\n        .or((qb) => {\r\n          qb.where(\"priority\", \"select\", \"equals\", \"High\").where(\r\n            \"priority\",\r\n            \"select\",\r\n            \"equals\",\r\n            \"Critical\"\r\n          );\r\n        })\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        or: [\r\n          {\r\n            property: \"priority\",\r\n            select: { equals: \"High\" },\r\n          },\r\n          {\r\n            property: \"priority\",\r\n            select: { equals: \"Critical\" },\r\n          },\r\n        ],\r\n      });\r\n    });\r\n\r\n    it(\"should combine AND and OR filters\", () => {\r\n      const query = new QueryBuilder()\r\n        .where(\"done\", \"checkbox\", \"equals\", false)\r\n        .or((qb) => {\r\n          qb.where(\"priority\", \"select\", \"equals\", \"High\").where(\r\n            \"priority\",\r\n            \"select\",\r\n            \"equals\",\r\n            \"Critical\"\r\n          );\r\n        })\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        and: [\r\n          {\r\n            property: \"done\",\r\n            checkbox: { equals: false },\r\n          },\r\n          {\r\n            or: [\r\n              {\r\n                property: \"priority\",\r\n                select: { equals: \"High\" },\r\n              },\r\n              {\r\n                property: \"priority\",\r\n                select: { equals: \"Critical\" },\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"Sorting\", () => {\r\n    it(\"should add a property sort\", () => {\r\n      const query = new QueryBuilder()\r\n        .orderBy(\"due\", \"ascending\")\r\n        .build();\r\n\r\n      expect(query.sorts).toEqual([\r\n        {\r\n          property: \"due\",\r\n          direction: \"ascending\",\r\n        },\r\n      ]);\r\n    });\r\n\r\n    it(\"should default to ascending direction\", () => {\r\n      const query = new QueryBuilder().orderBy(\"due\").build();\r\n\r\n      expect(query.sorts).toEqual([\r\n        {\r\n          property: \"due\",\r\n          direction: \"ascending\",\r\n        },\r\n      ]);\r\n    });\r\n\r\n    it(\"should add multiple sorts\", () => {\r\n      const query = new QueryBuilder()\r\n        .orderBy(\"priority\", \"descending\")\r\n        .orderBy(\"due\", \"ascending\")\r\n        .build();\r\n\r\n      expect(query.sorts).toEqual([\r\n        {\r\n          property: \"priority\",\r\n          direction: \"descending\",\r\n        },\r\n        {\r\n          property: \"due\",\r\n          direction: \"ascending\",\r\n        },\r\n      ]);\r\n    });\r\n\r\n    it(\"should add a timestamp sort\", () => {\r\n      const query = new QueryBuilder()\r\n        .orderByTimestamp(\"created_time\", \"descending\")\r\n        .build();\r\n\r\n      expect(query.sorts).toEqual([\r\n        {\r\n          timestamp: \"created_time\",\r\n          direction: \"descending\",\r\n        },\r\n      ]);\r\n    });\r\n  });\r\n\r\n  describe(\"Pagination\", () => {\r\n    it(\"should set page size\", () => {\r\n      const query = new QueryBuilder().limit(50).build();\r\n\r\n      expect(query.page_size).toEqual(50);\r\n    });\r\n\r\n    it(\"should clamp page size to max 100\", () => {\r\n      const query = new QueryBuilder().limit(200).build();\r\n\r\n      expect(query.page_size).toEqual(100);\r\n    });\r\n\r\n    it(\"should clamp page size to min 1\", () => {\r\n      const query = new QueryBuilder().limit(0).build();\r\n\r\n      expect(query.page_size).toEqual(1);\r\n    });\r\n\r\n    it(\"should set start cursor\", () => {\r\n      const query = new QueryBuilder().startAfter(\"abc123\").build();\r\n\r\n      expect(query.start_cursor).toEqual(\"abc123\");\r\n    });\r\n  });\r\n\r\n  describe(\"Complex Queries\", () => {\r\n    it(\"should build a full query with filters, sorts, and pagination\", () => {"
    },
    {
      "path": "./src/query/builder.test.ts",
      "category": "query",
      "startLine": 316,
      "endLine": 466,
      "chars": 4161,
      "approxTokens": 1040.0,
      "sha256": "4D36E7E0713098E7AFF4F47B94285D45DF391A0C012084EBD45709E52BFF2D4F",
      "content": "      const query = new QueryBuilder()\r\n        .where(\"status\", \"select\", \"equals\", \"Active\")\r\n        .where(\"priority\", \"select\", \"equals\", \"High\")\r\n        .orderBy(\"due\", \"ascending\")\r\n        .orderByTimestamp(\"created_time\", \"descending\")\r\n        .limit(50)\r\n        .startAfter(\"cursor123\")\r\n        .build();\r\n\r\n      expect(query).toEqual({\r\n        filter: {\r\n          and: [\r\n            {\r\n              property: \"status\",\r\n              select: { equals: \"Active\" },\r\n            },\r\n            {\r\n              property: \"priority\",\r\n              select: { equals: \"High\" },\r\n            },\r\n          ],\r\n        },\r\n        sorts: [\r\n          {\r\n            property: \"due\",\r\n            direction: \"ascending\",\r\n          },\r\n          {\r\n            timestamp: \"created_time\",\r\n            direction: \"descending\",\r\n          },\r\n        ],\r\n        page_size: 50,\r\n        start_cursor: \"cursor123\",\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"Reset\", () => {\r\n    it(\"should reset the builder state\", () => {\r\n      const builder = new QueryBuilder()\r\n        .where(\"status\", \"select\", \"equals\", \"Active\")\r\n        .orderBy(\"due\", \"ascending\")\r\n        .limit(50);\r\n\r\n      let query = builder.build();\r\n      expect(query.filter).toBeDefined();\r\n      expect(query.sorts).toBeDefined();\r\n      expect(query.page_size).toEqual(50);\r\n\r\n      builder.reset();\r\n      query = builder.build();\r\n      expect(query.filter).toBeUndefined();\r\n      expect(query.sorts).toBeUndefined();\r\n      expect(query.page_size).toBeUndefined();\r\n    });\r\n  });\r\n});\r\n\r\ndescribe(\"QueryBuilderHelpers\", () => {\r\n  describe(\"incompleteTasks\", () => {\r\n    it(\"should create a query for incomplete tasks\", () => {\r\n      const query = QueryBuilderHelpers.incompleteTasks().build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"done\",\r\n        checkbox: { equals: false },\r\n      });\r\n    });\r\n\r\n    it(\"should allow chaining additional conditions\", () => {\r\n      const query = QueryBuilderHelpers.incompleteTasks()\r\n        .where(\"priority\", \"select\", \"equals\", \"High\")\r\n        .build();\r\n\r\n      expect(query.filter).toEqual({\r\n        and: [\r\n          {\r\n            property: \"done\",\r\n            checkbox: { equals: false },\r\n          },\r\n          {\r\n            property: \"priority\",\r\n            select: { equals: \"High\" },\r\n          },\r\n        ],\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"tasksDueSoon\", () => {\r\n    it(\"should create a query for tasks due soon\", () => {\r\n      const query = QueryBuilderHelpers.tasksDueSoon(7).build();\r\n\r\n      expect(query.filter).toBeDefined();\r\n      // Check that it has the done filter and due filter\r\n      const filter = query.filter as any;\r\n      expect(filter.and).toBeDefined();\r\n      expect(filter.and.length).toEqual(2);\r\n    });\r\n  });\r\n\r\n  describe(\"activeProjects\", () => {\r\n    it(\"should create a query for active projects\", () => {\r\n      const query = QueryBuilderHelpers.activeProjects().build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"status\",\r\n        select: { equals: \"Active\" },\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"highPriority\", () => {\r\n    it(\"should create a query for high priority items\", () => {\r\n      const query = QueryBuilderHelpers.highPriority().build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"priority\",\r\n        select: { equals: \"High\" },\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"byTeam\", () => {\r\n    it(\"should create a query for items by team\", () => {\r\n      const query = QueryBuilderHelpers.byTeam(\"team-123\").build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"team\",\r\n        relation: { contains: \"team-123\" },\r\n      });\r\n    });\r\n  });\r\n\r\n  describe(\"byMilestone\", () => {\r\n    it(\"should create a query for items by milestone\", () => {\r\n      const query = QueryBuilderHelpers.byMilestone(\"M2\").build();\r\n\r\n      expect(query.filter).toEqual({\r\n        property: \"milestone\",\r\n        select: { equals: \"M2\" },\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n// Run tests if this is the main module\r\nif (require.main === module) {\r\n  console.log(\"Running Query Builder Tests...\");\r\n}"
    },
    {
      "path": "./src/query/builder.ts",
      "category": "query",
      "startLine": 1,
      "endLine": 330,
      "chars": 8176,
      "approxTokens": 2044.0,
      "sha256": "E42701A586AA37477705E5CB7336F179DA8D57E72D4357E729E602A0ABDC43F1",
      "content": "import type {\r\n  CheckboxFilter,\r\n  CompoundFilter,\r\n  DateFilter,\r\n  FilesFilter,\r\n  Filter,\r\n  MultiSelectFilter,\r\n  NumberFilter,\r\n  PeopleFilter,\r\n  PropertyFilter,\r\n  QueryParams,\r\n  RelationFilter,\r\n  SelectFilter,\r\n  Sort,\r\n  SortDirection,\r\n  TextFilter,\r\n} from '../core/types/notion-filters';\r\n\r\n/**\r\n * Property type discriminator\r\n */\r\nexport type PropertyType =\r\n  | 'title'\r\n  | 'rich_text'\r\n  | 'number'\r\n  | 'checkbox'\r\n  | 'select'\r\n  | 'multi_select'\r\n  | 'date'\r\n  | 'people'\r\n  | 'files'\r\n  | 'relation'\r\n  | 'status';\r\n\r\n/**\r\n * Operator types for each property type\r\n */\r\nexport type FilterOperator<T extends PropertyType = PropertyType> = T extends 'title' | 'rich_text'\r\n  ? keyof TextFilter\r\n  : T extends 'number'\r\n    ? keyof NumberFilter\r\n    : T extends 'checkbox'\r\n      ? keyof CheckboxFilter\r\n      : T extends 'select' | 'status'\r\n        ? keyof SelectFilter\r\n        : T extends 'multi_select'\r\n          ? keyof MultiSelectFilter\r\n          : T extends 'date'\r\n            ? keyof DateFilter\r\n            : T extends 'people'\r\n              ? keyof PeopleFilter\r\n              : T extends 'files'\r\n                ? keyof FilesFilter\r\n                : T extends 'relation'\r\n                  ? keyof RelationFilter\r\n                  : never;\r\n\r\n/**\r\n * Value type for each operator\r\n */\r\nexport type FilterValue = string | number | boolean | Record<string, never>;\r\n\r\n/**\r\n * Fluent query builder for Notion database queries\r\n *\r\n * @example\r\n * ```typescript\r\n * const query = new QueryBuilder()\r\n *   .where('status', 'select', 'equals', 'Active')\r\n *   .where('priority', 'select', 'equals', 'High')\r\n *   .orderBy('due', 'ascending')\r\n *   .limit(50)\r\n *   .build();\r\n * ```\r\n */\r\nexport class QueryBuilder {\r\n  private filters: Filter[] = [];\r\n  private sortConditions: Sort[] = [];\r\n  private pageSize?: number;\r\n  private startCursor?: string;\r\n\r\n  /**\r\n   * Add a property filter condition\r\n   *\r\n   * @param property - The property name to filter on\r\n   * @param type - The property type (title, select, number, etc.)\r\n   * @param operator - The filter operator (equals, contains, etc.)\r\n   * @param value - The value to filter by (optional for operators like is_empty)\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.where('status', 'select', 'equals', 'Active')\r\n   * builder.where('done', 'checkbox', 'equals', false)\r\n   * builder.where('name', 'title', 'contains', 'Project')\r\n   * ```\r\n   */\r\n  where(property: string, type: PropertyType, operator: string, value?: FilterValue): this {\r\n    const filter: PropertyFilter = {\r\n      property,\r\n      [type]: {\r\n        [operator]: value ?? true,\r\n      },\r\n    };\r\n    this.filters.push(filter);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a compound AND filter\r\n   *\r\n   * @param callback - Function that builds the AND conditions\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.and(qb => {\r\n   *   qb.where('status', 'select', 'equals', 'Active')\r\n   *     .where('priority', 'select', 'equals', 'High')\r\n   * })\r\n   * ```\r\n   */\r\n  and(callback: (builder: QueryBuilder) => void): this {\r\n    const subBuilder = new QueryBuilder();\r\n    callback(subBuilder);\r\n    const subFilters = subBuilder.getFilters();\r\n\r\n    if (subFilters.length > 0) {\r\n      const andFilter: CompoundFilter = {\r\n        and: subFilters,\r\n      };\r\n      this.filters.push(andFilter);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a compound OR filter\r\n   *\r\n   * @param callback - Function that builds the OR conditions\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.or(qb => {\r\n   *   qb.where('priority', 'select', 'equals', 'High')\r\n   *     .where('priority', 'select', 'equals', 'Critical')\r\n   * })\r\n   * ```\r\n   */\r\n  or(callback: (builder: QueryBuilder) => void): this {\r\n    const subBuilder = new QueryBuilder();\r\n    callback(subBuilder);\r\n    const subFilters = subBuilder.getFilters();\r\n\r\n    if (subFilters.length > 0) {\r\n      const orFilter: CompoundFilter = {\r\n        or: subFilters,\r\n      };\r\n      this.filters.push(orFilter);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a sort condition by property\r\n   *\r\n   * @param property - The property name to sort by\r\n   * @param direction - Sort direction (ascending or descending), defaults to ascending\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.orderBy('due', 'ascending')\r\n   * builder.orderBy('priority', 'descending')\r\n   * ```\r\n   */\r\n  orderBy(property: string, direction: SortDirection = 'ascending'): this {\r\n    this.sortConditions.push({\r\n      property,\r\n      direction,\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a sort condition by timestamp\r\n   *\r\n   * @param timestamp - The timestamp type (created_time or last_edited_time)\r\n   * @param direction - Sort direction (ascending or descending), defaults to ascending\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.orderByTimestamp('created_time', 'descending')\r\n   * builder.orderByTimestamp('last_edited_time', 'ascending')\r\n   * ```\r\n   */\r\n  orderByTimestamp(\r\n    timestamp: 'created_time' | 'last_edited_time',\r\n    direction: SortDirection = 'ascending'\r\n  ): this {\r\n    this.sortConditions.push({\r\n      timestamp,\r\n      direction,\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the page size limit\r\n   *\r\n   * @param size - Number of results to return (max 100)\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.limit(50)\r\n   * ```\r\n   */\r\n  limit(size: number): this {\r\n    this.pageSize = Math.min(Math.max(1, size), 100);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the pagination cursor\r\n   *\r\n   * @param cursor - The start cursor for pagination\r\n   * @returns This query builder for chaining\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * builder.startAfter('abc123...')\r\n   * ```\r\n   */\r\n  startAfter(cursor: string): this {\r\n    this.startCursor = cursor;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get the current filters (internal use)\r\n   */\r\n  private getFilters(): Filter[] {\r\n    return this.filters;\r\n  }\r\n\r\n  /**\r\n   * Build the final query parameters object\r\n   *\r\n   * @returns QueryParams object ready for Notion API\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const params = builder.build();\r\n   * // Use with Notion API or MCP client\r\n   * ```\r\n   */\r\n  build(): QueryParams {\r\n    const params: QueryParams = {};\r\n\r\n    // Build filter - wrap multiple filters in AND\r\n    if (this.filters.length === 1) {\r\n      params.filter = this.filters[0];\r\n    } else if (this.filters.length > 1) {\r\n      params.filter = {\r\n        and: this.filters,\r\n      };\r\n    }\r\n\r\n    // Add sorts if present\r\n    if (this.sortConditions.length > 0) {\r\n      params.sorts = this.sortConditions;\r\n    }\r\n\r\n    // Add pagination\r\n    if (this.pageSize !== undefined) {\r\n      params.page_size = this.pageSize;\r\n    }\r\n    if (this.startCursor !== undefined) {\r\n      params.start_cursor = this.startCursor;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Reset the builder to start a new query\r\n   *\r\n   * @returns This query builder for chaining\r\n   */\r\n  reset(): this {\r\n    this.filters = [];\r\n    this.sortConditions = [];\r\n    this.pageSize = undefined;\r\n    this.startCursor = undefined;\r\n    return this;\r\n  }\r\n}\r\n\r\n/**\r\n * Convenience methods for common query patterns\r\n */\r\nexport class QueryBuilderHelpers {\r\n  /**\r\n   * Create a query for incomplete tasks\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.incompleteTasks();\r\n   * ```\r\n   */\r\n  static incompleteTasks(): QueryBuilder {\r\n    return new QueryBuilder().where('done', 'checkbox', 'equals', false);\r\n  }\r\n\r\n  /**\r\n   * Create a query for tasks due soon (within specified days)\r\n   *\r\n   * @param days - Number of days from now, defaults to 7\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.tasksDueSoon(3);\r\n   * ```\r\n   */\r\n  static tasksDueSoon(days = 7): QueryBuilder {"
    },
    {
      "path": "./src/query/builder.ts",
      "category": "query",
      "startLine": 331,
      "endLine": 408,
      "chars": 1951,
      "approxTokens": 488.0,
      "sha256": "2F640F6F3BA8F374E84531D90CCA71970444A915F38AA3804C26507E4515B134",
      "content": "    const futureDate = new Date();\r\n    futureDate.setDate(futureDate.getDate() + days);\r\n\r\n    return new QueryBuilder()\r\n      .where('done', 'checkbox', 'equals', false)\r\n      .where('due', 'date', 'on_or_before', futureDate.toISOString());\r\n  }\r\n\r\n  /**\r\n   * Create a query for active projects\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.activeProjects();\r\n   * ```\r\n   */\r\n  static activeProjects(): QueryBuilder {\r\n    return new QueryBuilder().where('status', 'select', 'equals', 'Active');\r\n  }\r\n\r\n  /**\r\n   * Create a query for high priority items\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.highPriority();\r\n   * ```\r\n   */\r\n  static highPriority(): QueryBuilder {\r\n    return new QueryBuilder().where('priority', 'select', 'equals', 'High');\r\n  }\r\n\r\n  /**\r\n   * Create a query for items by team\r\n   *\r\n   * @param teamId - The team relation ID\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.byTeam('team-id-123');\r\n   * ```\r\n   */\r\n  static byTeam(teamId: string): QueryBuilder {\r\n    return new QueryBuilder().where('team', 'relation', 'contains', teamId);\r\n  }\r\n\r\n  /**\r\n   * Create a query for items by milestone\r\n   *\r\n   * @param milestone - The milestone value (M1, M2, M3)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const query = QueryBuilderHelpers.byMilestone('M2');\r\n   * ```\r\n   */\r\n  static byMilestone(milestone: string): QueryBuilder {\r\n    return new QueryBuilder().where('milestone', 'select', 'equals', milestone);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new query builder instance\r\n *\r\n * @returns New QueryBuilder instance\r\n *\r\n * @example\r\n * ```typescript\r\n * import { createQueryBuilder } from './query';\r\n *\r\n * const query = createQueryBuilder()\r\n *   .where('status', 'select', 'equals', 'Active')\r\n *   .build();\r\n * ```\r\n */\r\nexport function createQueryBuilder(): QueryBuilder {\r\n  return new QueryBuilder();\r\n}"
    },
    {
      "path": "./src/query/examples.ts",
      "category": "query",
      "startLine": 1,
      "endLine": 292,
      "chars": 8196,
      "approxTokens": 2049.0,
      "sha256": "58028C80075B9653C4F71B7C1E56F7DAA19D58601BBA1FBCAE3D027935540A56",
      "content": "/**\r\n * Query Builder Usage Examples\r\n * \r\n * This file demonstrates various use cases for the QueryBuilder\r\n */\r\n\r\nimport { QueryBuilder, QueryBuilderHelpers, createQueryBuilder } from \"./builder\";\r\n\r\n// ============================================================================\r\n// BASIC EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example 1: Simple filter query\r\n */\r\nexport function example1_SimpleFilter() {\r\n  const query = new QueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .build();\r\n\r\n  console.log(\"Example 1 - Simple Filter:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 2: Multiple filters (AND)\r\n */\r\nexport function example2_MultipleFilters() {\r\n  const query = new QueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .where(\"priority\", \"select\", \"equals\", \"High\")\r\n    .where(\"milestone\", \"select\", \"equals\", \"M2\")\r\n    .build();\r\n\r\n  console.log(\"Example 2 - Multiple Filters:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 3: OR compound filter\r\n */\r\nexport function example3_OrFilter() {\r\n  const query = new QueryBuilder()\r\n    .or((qb) => {\r\n      qb.where(\"priority\", \"select\", \"equals\", \"High\")\r\n        .where(\"priority\", \"select\", \"equals\", \"Critical\");\r\n    })\r\n    .build();\r\n\r\n  console.log(\"Example 3 - OR Filter:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 4: Complex nested filters\r\n */\r\nexport function example4_ComplexFilter() {\r\n  const query = new QueryBuilder()\r\n    .and((qb) => {\r\n      qb.where(\"status\", \"select\", \"equals\", \"Active\")\r\n        .where(\"milestone\", \"select\", \"equals\", \"M2\");\r\n    })\r\n    .or((qb) => {\r\n      qb.where(\"priority\", \"select\", \"equals\", \"High\")\r\n        .where(\"priority\", \"select\", \"equals\", \"Critical\");\r\n    })\r\n    .build();\r\n\r\n  console.log(\"Example 4 - Complex Nested Filters:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 5: Sorting\r\n */\r\nexport function example5_Sorting() {\r\n  const query = new QueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .orderBy(\"priority\", \"descending\")\r\n    .orderBy(\"due\", \"ascending\")\r\n    .build();\r\n\r\n  console.log(\"Example 5 - Sorting:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 6: Pagination\r\n */\r\nexport function example6_Pagination() {\r\n  const query = new QueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .limit(25)\r\n    .startAfter(\"cursor_abc123\")\r\n    .build();\r\n\r\n  console.log(\"Example 6 - Pagination:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n// ============================================================================\r\n// DIGITAL HERENCIA WORKSPACE EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example 7: Find active projects in Milestone M2\r\n */\r\nexport function example7_ActiveM2Projects() {\r\n  const query = new QueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .where(\"milestone\", \"select\", \"equals\", \"M2\")\r\n    .orderBy(\"startDate\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 7 - Active M2 Projects:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 8: Find high priority incomplete tasks due this week\r\n */\r\nexport function example8_HighPriorityTasksDueSoon() {\r\n  const query = new QueryBuilder()\r\n    .where(\"done\", \"checkbox\", \"equals\", false)\r\n    .where(\"priority\", \"select\", \"equals\", \"High\")\r\n    .where(\"due\", \"date\", \"next_week\")\r\n    .orderBy(\"due\", \"ascending\")\r\n    .build();\r\n\r\n  console.log(\"Example 8 - High Priority Tasks Due This Week:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 9: Find all items for Engineering team in Phase P2.1\r\n */\r\nexport function example9_EngineeringP21Items() {\r\n  const query = new QueryBuilder()\r\n    .where(\"domain\", \"select\", \"equals\", \"ENG\")\r\n    .where(\"phase\", \"select\", \"equals\", \"P2.1\")\r\n    .orderByTimestamp(\"created_time\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 9 - Engineering P2.1 Items:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 10: Find tasks without team assignment\r\n */\r\nexport function example10_UnassignedTasks() {\r\n  const query = new QueryBuilder()\r\n    .where(\"team\", \"relation\", \"is_empty\")\r\n    .where(\"done\", \"checkbox\", \"equals\", false)\r\n    .orderBy(\"priority\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 10 - Unassigned Tasks:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 11: Find overdue tasks\r\n */\r\nexport function example11_OverdueTasks() {\r\n  const today = new Date().toISOString().split(\"T\")[0];\r\n\r\n  const query = new QueryBuilder()\r\n    .where(\"done\", \"checkbox\", \"equals\", false)\r\n    .where(\"due\", \"date\", \"before\", today)\r\n    .orderBy(\"due\", \"ascending\")\r\n    .build();\r\n\r\n  console.log(\"Example 11 - Overdue Tasks:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 12: Find projects by domain and status\r\n */\r\nexport function example12_ProjectsByDomainAndStatus() {\r\n  const query = new QueryBuilder()\r\n    .or((qb) => {\r\n      qb.where(\"domain\", \"select\", \"equals\", \"ENG\")\r\n        .where(\"domain\", \"select\", \"equals\", \"PROD\");\r\n    })\r\n    .and((qb) => {\r\n      qb.or((inner) => {\r\n        inner\r\n          .where(\"status\", \"select\", \"equals\", \"Active\")\r\n          .where(\"status\", \"select\", \"equals\", \"On Hold\");\r\n      });\r\n    })\r\n    .build();\r\n\r\n  console.log(\"Example 12 - Projects by Domain and Status:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n// ============================================================================\r\n// HELPER EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example 13: Using incompleteTasks helper\r\n */\r\nexport function example13_HelperIncompleteTasks() {\r\n  const query = QueryBuilderHelpers.incompleteTasks()\r\n    .orderBy(\"due\", \"ascending\")\r\n    .limit(50)\r\n    .build();\r\n\r\n  console.log(\"Example 13 - Helper: Incomplete Tasks:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 14: Using tasksDueSoon helper\r\n */\r\nexport function example14_HelperTasksDueSoon() {\r\n  const query = QueryBuilderHelpers.tasksDueSoon(3)\r\n    .where(\"priority\", \"select\", \"equals\", \"High\")\r\n    .orderBy(\"due\", \"ascending\")\r\n    .build();\r\n\r\n  console.log(\"Example 14 - Helper: Tasks Due Soon (3 days):\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 15: Using activeProjects helper\r\n */\r\nexport function example15_HelperActiveProjects() {\r\n  const query = QueryBuilderHelpers.activeProjects()\r\n    .where(\"milestone\", \"select\", \"equals\", \"M2\")\r\n    .orderBy(\"startDate\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 15 - Helper: Active M2 Projects:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 16: Using byTeam helper\r\n */\r\nexport function example16_HelperByTeam() {\r\n  const query = QueryBuilderHelpers.byTeam(\"team-id-123\")\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .orderBy(\"priority\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 16 - Helper: Tasks by Team:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 17: Using byMilestone helper\r\n */\r\nexport function example17_HelperByMilestone() {\r\n  const query = QueryBuilderHelpers.byMilestone(\"M2\")\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .orderByTimestamp(\"created_time\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 17 - Helper: M2 Milestone Items:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n// ============================================================================\r\n// ADVANCED EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example 18: Date range filtering\r\n */"
    },
    {
      "path": "./src/query/examples.ts",
      "category": "query",
      "startLine": 293,
      "endLine": 445,
      "chars": 4241,
      "approxTokens": 1060.0,
      "sha256": "398089237C1EFB340E810707B75A17B97DB3A5EA7FF4B9EFA18F28CCE4667314",
      "content": "export function example18_DateRangeFilter() {\r\n  const startDate = \"2025-01-01\";\r\n  const endDate = \"2025-01-31\";\r\n\r\n  const query = new QueryBuilder()\r\n    .and((qb) => {\r\n      qb.where(\"startDate\", \"date\", \"on_or_after\", startDate)\r\n        .where(\"startDate\", \"date\", \"on_or_before\", endDate);\r\n    })\r\n    .orderBy(\"startDate\", \"ascending\")\r\n    .build();\r\n\r\n  console.log(\"Example 18 - Date Range Filter:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 19: Text search with contains\r\n */\r\nexport function example19_TextSearch() {\r\n  const query = new QueryBuilder()\r\n    .where(\"name\", \"title\", \"contains\", \"Sprint\")\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .build();\r\n\r\n  console.log(\"Example 19 - Text Search:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 20: Empty/not empty checks\r\n */\r\nexport function example20_EmptyChecks() {\r\n  const query = new QueryBuilder()\r\n    .where(\"description\", \"rich_text\", \"is_not_empty\")\r\n    .where(\"team\", \"relation\", \"is_not_empty\")\r\n    .where(\"attachments\", \"files\", \"is_empty\")\r\n    .build();\r\n\r\n  console.log(\"Example 20 - Empty/Not Empty Checks:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 21: Using factory function\r\n */\r\nexport function example21_FactoryFunction() {\r\n  const query = createQueryBuilder()\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .orderBy(\"priority\", \"descending\")\r\n    .build();\r\n\r\n  console.log(\"Example 21 - Factory Function:\");\r\n  console.log(JSON.stringify(query, null, 2));\r\n  return query;\r\n}\r\n\r\n/**\r\n * Example 22: Reusing and resetting builder\r\n */\r\nexport function example22_ReuseBuilder() {\r\n  const builder = new QueryBuilder();\r\n\r\n  // First query\r\n  const query1 = builder\r\n    .where(\"status\", \"select\", \"equals\", \"Active\")\r\n    .build();\r\n  console.log(\"Example 22a - First Query:\");\r\n  console.log(JSON.stringify(query1, null, 2));\r\n\r\n  // Reset and create second query\r\n  builder.reset();\r\n  const query2 = builder\r\n    .where(\"done\", \"checkbox\", \"equals\", true)\r\n    .orderByTimestamp(\"last_edited_time\", \"descending\")\r\n    .build();\r\n  console.log(\"Example 22b - Second Query:\");\r\n  console.log(JSON.stringify(query2, null, 2));\r\n\r\n  return { query1, query2 };\r\n}\r\n\r\n// ============================================================================\r\n// RUN ALL EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Run all examples\r\n */\r\nexport function runAllExamples() {\r\n  console.log(\"\\n=== QUERY BUILDER EXAMPLES ===\\n\");\r\n\r\n  // Basic examples\r\n  example1_SimpleFilter();\r\n  console.log(\"\\n---\\n\");\r\n  example2_MultipleFilters();\r\n  console.log(\"\\n---\\n\");\r\n  example3_OrFilter();\r\n  console.log(\"\\n---\\n\");\r\n  example4_ComplexFilter();\r\n  console.log(\"\\n---\\n\");\r\n  example5_Sorting();\r\n  console.log(\"\\n---\\n\");\r\n  example6_Pagination();\r\n\r\n  // Digital Herencia examples\r\n  console.log(\"\\n\\n=== DIGITAL HERENCIA WORKSPACE EXAMPLES ===\\n\");\r\n  example7_ActiveM2Projects();\r\n  console.log(\"\\n---\\n\");\r\n  example8_HighPriorityTasksDueSoon();\r\n  console.log(\"\\n---\\n\");\r\n  example9_EngineeringP21Items();\r\n  console.log(\"\\n---\\n\");\r\n  example10_UnassignedTasks();\r\n  console.log(\"\\n---\\n\");\r\n  example11_OverdueTasks();\r\n  console.log(\"\\n---\\n\");\r\n  example12_ProjectsByDomainAndStatus();\r\n\r\n  // Helper examples\r\n  console.log(\"\\n\\n=== HELPER EXAMPLES ===\\n\");\r\n  example13_HelperIncompleteTasks();\r\n  console.log(\"\\n---\\n\");\r\n  example14_HelperTasksDueSoon();\r\n  console.log(\"\\n---\\n\");\r\n  example15_HelperActiveProjects();\r\n  console.log(\"\\n---\\n\");\r\n  example16_HelperByTeam();\r\n  console.log(\"\\n---\\n\");\r\n  example17_HelperByMilestone();\r\n\r\n  // Advanced examples\r\n  console.log(\"\\n\\n=== ADVANCED EXAMPLES ===\\n\");\r\n  example18_DateRangeFilter();\r\n  console.log(\"\\n---\\n\");\r\n  example19_TextSearch();\r\n  console.log(\"\\n---\\n\");\r\n  example20_EmptyChecks();\r\n  console.log(\"\\n---\\n\");\r\n  example21_FactoryFunction();\r\n  console.log(\"\\n---\\n\");\r\n  example22_ReuseBuilder();\r\n\r\n  console.log(\"\\n\\n=== ALL EXAMPLES COMPLETED ===\\n\");\r\n}\r\n\r\n// Run examples if this is the main module\r\nif (require.main === module) {\r\n  runAllExamples();\r\n}"
    },
    {
      "path": "./src/query/index.ts",
      "category": "query",
      "startLine": 1,
      "endLine": 66,
      "chars": 1458,
      "approxTokens": 364.0,
      "sha256": "538C58E410A4BE709C791A3AD8F78B9F0D307C2580B98C2ED401AEA407339902",
      "content": "/**\n * Query Builder Module\n * \n * Fluent API for constructing type-safe Notion database queries\n * with filters, sorts, and pagination.\n * \n * @example\n * ```typescript\n * import { QueryBuilder, QueryBuilderHelpers } from './query';\n * \n * // Basic query\n * const query = new QueryBuilder()\n *   .where('status', 'select', 'equals', 'Active')\n *   .where('priority', 'select', 'equals', 'High')\n *   .orderBy('due', 'ascending')\n *   .limit(50)\n *   .build();\n * \n * // Using compound filters\n * const complexQuery = new QueryBuilder()\n *   .and(qb => {\n *     qb.where('status', 'select', 'equals', 'Active')\n *       .where('milestone', 'select', 'equals', 'M2')\n *   })\n *   .or(qb => {\n *     qb.where('priority', 'select', 'equals', 'High')\n *       .where('priority', 'select', 'equals', 'Critical')\n *   })\n *   .build();\n * \n * // Using helpers\n * const incompleteTasks = QueryBuilderHelpers.incompleteTasks()\n *   .orderBy('due', 'ascending')\n *   .build();\n * ```\n * \n * @module query\n */\n\nexport {\n  QueryBuilder,\n  QueryBuilderHelpers,\n  createQueryBuilder,\n  type PropertyType,\n  type FilterOperator,\n  type FilterValue,\n} from \"./builder\";\n\nexport type {\n  Filter,\n  PropertyFilter,\n  CompoundFilter,\n  Sort,\n  SortDirection,\n  QueryParams,\n  TextFilter,\n  NumberFilter,\n  CheckboxFilter,\n  SelectFilter,\n  MultiSelectFilter,\n  DateFilter,\n  PeopleFilter,\n  FilesFilter,\n  RelationFilter,\n  StatusFilter,\n} from \"../core/types/notion-filters\";"
    },
    {
      "path": "./src/safety/batch-limiter.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 266,
      "chars": 6711,
      "approxTokens": 1678.0,
      "sha256": "30433813852CA86F1BA8C17570381D1A0600DA8DDF05D96DD9797DC57280DFC9",
      "content": "import { BatchLimitExceededError } from '../core/errors';\n\n/**\n * Configuration for batch operations\n */\nexport interface BatchConfig {\n  /**\n   * Maximum number of items in a single batch\n   * @default 50\n   */\n  maxBatchSize: number;\n\n  /**\n   * Whether to allow splitting batches automatically\n   * @default false\n   */\n  allowSplit: boolean;\n\n  /**\n   * Progress callback for batch operations\n   */\n  onProgress?: (completed: number, total: number) => void;\n}\n\n/**\n * Batch operation metadata\n */\nexport interface BatchOperation {\n  id: string;\n  itemCount: number;\n  estimatedDuration: number; // milliseconds\n  chunks: number; // number of chunks if split\n}\n\n/**\n * Batch execution result\n */\nexport interface BatchResult {\n  successful: number;\n  failed: number;\n  errors: Array<{ index: number; error: Error }>;\n  duration: number; // milliseconds\n}\n\n/**\n * Enforces batch size limits for bulk operations\n * Protects against accidental mass updates\n */\nexport class BatchLimiter {\n  private readonly config: BatchConfig;\n\n  /**\n   * Default batch size limit (matches copilot-instructions.md)\n   */\n  static readonly DEFAULT_BATCH_SIZE = 50;\n\n  constructor(config: Partial<BatchConfig> = {}) {\n    this.config = {\n      maxBatchSize: config.maxBatchSize ?? BatchLimiter.DEFAULT_BATCH_SIZE,\n      allowSplit: config.allowSplit ?? false,\n      onProgress: config.onProgress,\n    };\n  }\n\n  /**\n   * Validate batch size against limit\n   * @param itemCount Number of items in batch\n   * @throws BatchLimitExceededError if limit exceeded\n   */\n  validateBatchSize(itemCount: number): void {\n    if (itemCount > this.config.maxBatchSize) {\n      throw new BatchLimitExceededError(itemCount, this.config.maxBatchSize);\n    }\n  }\n\n  /**\n   * Check if batch size is within limit\n   * @param itemCount Number of items in batch\n   * @returns True if within limit\n   */\n  isWithinLimit(itemCount: number): boolean {\n    return itemCount <= this.config.maxBatchSize;\n  }\n\n  /**\n   * Split batch into chunks if allowed\n   * @param items Array of items to batch\n   * @returns Array of chunks\n   */\n  splitBatch<T>(items: T[]): T[][] {\n    if (!this.config.allowSplit) {\n      this.validateBatchSize(items.length);\n      return [items];\n    }\n\n    const chunks: T[][] = [];\n    for (let i = 0; i < items.length; i += this.config.maxBatchSize) {\n      chunks.push(items.slice(i, i + this.config.maxBatchSize));\n    }\n\n    return chunks;\n  }\n\n  /**\n   * Generate dry-run summary for batch operation\n   * @param itemCount Number of items\n   * @returns Summary object\n   */\n  generateDryRunSummary(itemCount: number): BatchOperation {\n    const chunks = Math.ceil(itemCount / this.config.maxBatchSize);\n    const estimatedDuration = this.estimateDuration(itemCount);\n\n    return {\n      id: this.generateBatchId(),\n      itemCount,\n      estimatedDuration,\n      chunks,\n    };\n  }\n\n  /**\n   * Execute batch operation with progress tracking\n   * @param items Items to process\n   * @param executor Function to execute on each item\n   * @returns Batch execution result\n   */\n  async executeBatch<T, R>(\n    items: T[],\n    executor: (item: T) => Promise<R>\n  ): Promise<BatchResult> {\n    const startTime = Date.now();\n    let successful = 0;\n    let failed = 0;\n    const errors: Array<{ index: number; error: Error }> = [];\n\n    // Validate or split batch\n    const chunks = this.splitBatch(items);\n\n    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n      const chunk = chunks[chunkIndex]!;\n\n      for (let i = 0; i < chunk.length; i++) {\n        const globalIndex = chunkIndex * this.config.maxBatchSize + i;\n        const item = chunk[i]!;\n\n        try {\n          await executor(item);\n          successful++;\n        } catch (error) {\n          failed++;\n          errors.push({\n            index: globalIndex,\n            error: error instanceof Error ? error : new Error(String(error)),\n          });\n        }\n\n        // Report progress\n        if (this.config.onProgress) {\n          this.config.onProgress(successful + failed, items.length);\n        }\n      }\n    }\n\n    return {\n      successful,\n      failed,\n      errors,\n      duration: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Format batch summary for display\n   * @param summary Batch operation summary\n   * @returns Markdown formatted summary\n   */\n  formatSummary(summary: BatchOperation): string {\n    const lines = [\n      `### Batch Operation Summary`,\n      ``,\n      `- **Total Items**: ${summary.itemCount}`,\n      `- **Chunks**: ${summary.chunks}`,\n      `- **Items per Chunk**: ${this.config.maxBatchSize}`,\n      `- **Estimated Duration**: ${this.formatDuration(summary.estimatedDuration)}`,\n    ];\n\n    if (summary.chunks > 1) {\n      lines.push(``);\n      lines.push(`⚠️ This batch will be processed in ${summary.chunks} chunks`);\n    }\n\n    if (summary.itemCount > this.config.maxBatchSize && !this.config.allowSplit) {\n      lines.push(``);\n      lines.push(\n        `❌ Batch size exceeds limit of ${this.config.maxBatchSize}. Enable allowSplit to proceed.`\n      );\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Format batch result for display\n   * @param result Batch execution result\n   * @returns Markdown formatted result\n   */\n  formatResult(result: BatchResult): string {\n    const lines = [\n      `### Batch Execution Result`,\n      ``,\n      `- **Successful**: ${result.successful}`,\n      `- **Failed**: ${result.failed}`,\n      `- **Duration**: ${this.formatDuration(result.duration)}`,\n    ];\n\n    if (result.errors.length > 0) {\n      lines.push(``);\n      lines.push(`#### Errors`);\n      lines.push(``);\n\n      for (const { index, error } of result.errors.slice(0, 10)) {\n        lines.push(`- Item ${index}: ${error.message}`);\n      }\n\n      if (result.errors.length > 10) {\n        lines.push(`- ... and ${result.errors.length - 10} more errors`);\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Estimate duration based on item count\n   * Assumes ~100ms per item with rate limiting\n   */\n  private estimateDuration(itemCount: number): number {\n    // 3 req/sec rate limit = ~333ms per request\n    return itemCount * 333;\n  }\n\n  /**\n   * Format duration for display\n   */\n  private formatDuration(ms: number): string {\n    if (ms < 1000) {\n      return `${ms}ms`;\n    }\n\n    const seconds = Math.floor(ms / 1000);\n    if (seconds < 60) {\n      return `${seconds}s`;\n    }\n\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}m ${remainingSeconds}s`;\n  }\n\n  /**\n   * Generate unique batch ID\n   */\n  private generateBatchId(): string {\n    return `batch_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n  }\n}"
    },
    {
      "path": "./src/safety/diff.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 287,
      "chars": 7562,
      "approxTokens": 1890.0,
      "sha256": "5AA0E55F355C7EDE09410960ED1365D0C6AFE4C272116CC290DEEB70BF61F4A8",
      "content": "import type { PropertyDiff } from './proposal';\n\n/**\n * Impact level for property changes\n */\nexport type ImpactLevel = 'low' | 'medium' | 'high';\n\n/**\n * Diff result containing all changes\n */\nexport interface DiffResult {\n  hasChanges: boolean;\n  diffs: PropertyDiff[];\n  summary: string;\n}\n\n/**\n * Engine for computing diffs between object states\n * Used to show what will change when a proposal is applied\n */\nexport class DiffEngine {\n  /**\n   * Compute diff between current and proposed states\n   * @param current Current state (null for creates)\n   * @param proposed Proposed new state\n   * @returns Array of property diffs\n   */\n  computeDiff<T extends Record<string, unknown>>(\n    current: T | null,\n    proposed: T\n  ): PropertyDiff[] {\n    const diffs: PropertyDiff[] = [];\n\n    // If current is null, all properties are additions\n    if (current === null) {\n      for (const [key, value] of Object.entries(proposed)) {\n        diffs.push({\n          property: key,\n          oldValue: null,\n          newValue: value,\n          impact: this.assessImpact(key, null, value),\n        });\n      }\n      return diffs;\n    }\n\n    // Compare all properties in proposed state\n    for (const [key, newValue] of Object.entries(proposed)) {\n      const oldValue = current[key];\n\n      if (!this.areValuesEqual(oldValue, newValue)) {\n        diffs.push({\n          property: key,\n          oldValue,\n          newValue,\n          impact: this.assessImpact(key, oldValue, newValue),\n        });\n      }\n    }\n\n    // Check for removed properties (in current but not in proposed)\n    for (const key of Object.keys(current)) {\n      if (!(key in proposed)) {\n        diffs.push({\n          property: key,\n          oldValue: current[key],\n          newValue: undefined,\n          impact: this.assessImpact(key, current[key], undefined),\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  /**\n   * Assess the impact level of a property change\n   * @param property Property name\n   * @param _oldValue Previous value (unused but kept for API consistency)\n   * @param newValue New value\n   * @returns Impact level\n   */\n  assessImpact(property: string, _oldValue: unknown, newValue: unknown): ImpactLevel {\n    // High impact properties (critical data)\n    const highImpactProps = ['id', 'type', 'database', 'pageId', 'status', 'done'];\n    if (highImpactProps.includes(property.toLowerCase())) {\n      return 'high';\n    }\n\n    // Relation changes are high impact\n    if (property.toLowerCase().includes('relation') || property.endsWith('Id')) {\n      return 'high';\n    }\n\n    // Deletion is high impact\n    if (newValue === undefined || newValue === null) {\n      return 'high';\n    }\n\n    // Date changes are medium impact\n    if (\n      property.toLowerCase().includes('date') ||\n      property.toLowerCase().includes('due') ||\n      property.toLowerCase().includes('deadline')\n    ) {\n      return 'medium';\n    }\n\n    // Priority/urgency changes are medium impact\n    if (\n      property.toLowerCase().includes('priority') ||\n      property.toLowerCase().includes('urgency')\n    ) {\n      return 'medium';\n    }\n\n    // Default to low impact\n    return 'low';\n  }\n\n  /**\n   * Check if relation properties changed\n   * @param diffs Array of property diffs\n   * @returns True if any relation changed\n   */\n  hasRelationChanges(diffs: PropertyDiff[]): boolean {\n    return diffs.some(\n      (diff) =>\n        diff.property.toLowerCase().includes('relation') ||\n        diff.property.endsWith('Id') ||\n        diff.property.endsWith('Ids')\n    );\n  }\n\n  /**\n   * Format diff as markdown for human review\n   * @param diffs Array of property diffs\n   * @returns Markdown formatted diff\n   */\n  formatAsMarkdown(diffs: PropertyDiff[]): string {\n    if (diffs.length === 0) {\n      return '*(No changes)*';\n    }\n\n    const lines: string[] = [];\n\n    for (const diff of diffs) {\n      const impactIcon = this.getImpactIcon(diff.impact);\n      const changeType = this.getChangeType(diff);\n\n      lines.push(`${impactIcon} **${diff.property}** (${changeType})`);\n\n      if (diff.oldValue !== undefined && diff.oldValue !== null) {\n        lines.push(`  - Old: \\`${this.formatValue(diff.oldValue)}\\``);\n      }\n\n      if (diff.newValue !== undefined) {\n        lines.push(`  - New: \\`${this.formatValue(diff.newValue)}\\``);\n      } else {\n        lines.push(`  - *Removed*`);\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Generate a summary of changes\n   * @param diffs Array of property diffs\n   * @returns Human-readable summary\n   */\n  generateSummary(diffs: PropertyDiff[]): string {\n    if (diffs.length === 0) {\n      return 'No changes';\n    }\n\n    const added = diffs.filter((d) => d.oldValue === null || d.oldValue === undefined);\n    const modified = diffs.filter(\n      (d) =>\n        d.oldValue !== null &&\n        d.oldValue !== undefined &&\n        d.newValue !== null &&\n        d.newValue !== undefined\n    );\n    const removed = diffs.filter((d) => d.newValue === undefined || d.newValue === null);\n\n    const parts: string[] = [];\n\n    if (added.length > 0) {\n      parts.push(`${added.length} added`);\n    }\n\n    if (modified.length > 0) {\n      parts.push(`${modified.length} modified`);\n    }\n\n    if (removed.length > 0) {\n      parts.push(`${removed.length} removed`);\n    }\n\n    return parts.join(', ');\n  }\n\n  /**\n   * Compare two values for equality\n   * @param a First value\n   * @param b Second value\n   * @returns True if values are equal\n   */\n  private areValuesEqual(a: unknown, b: unknown): boolean {\n    // Handle null/undefined\n    if (a === null || a === undefined) {\n      return b === null || b === undefined;\n    }\n\n    if (b === null || b === undefined) {\n      return false;\n    }\n\n    // Handle primitives\n    if (typeof a !== 'object' || typeof b !== 'object') {\n      return a === b;\n    }\n\n    // Handle dates\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n\n    // Handle arrays\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      return a.every((item, index) => this.areValuesEqual(item, b[index]));\n    }\n\n    // Handle objects (shallow comparison)\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) return false;\n\n    return aKeys.every((key) =>\n      this.areValuesEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n    );\n  }\n\n  /**\n   * Get icon for impact level\n   */\n  private getImpactIcon(impact: ImpactLevel): string {\n    switch (impact) {\n      case 'high':\n        return '🔴';\n      case 'medium':\n        return '🟡';\n      case 'low':\n        return '🟢';\n    }\n  }\n\n  /**\n   * Get change type label\n   */\n  private getChangeType(diff: PropertyDiff): string {\n    if (diff.oldValue === null || diff.oldValue === undefined) {\n      return 'added';\n    }\n    if (diff.newValue === undefined || diff.newValue === null) {\n      return 'removed';\n    }\n    return 'modified';\n  }\n\n  /**\n   * Format value for display\n   */\n  private formatValue(value: unknown): string {\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (typeof value === 'string') return value;\n    if (typeof value === 'number' || typeof value === 'boolean') return String(value);\n    if (value instanceof Date) return value.toISOString();\n    if (Array.isArray(value)) return `[${value.length} items]`;\n    if (typeof value === 'object') return JSON.stringify(value);\n    return String(value);\n  }\n}"
    },
    {
      "path": "./src/safety/index.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 4,
      "chars": 113,
      "approxTokens": 28.0,
      "sha256": "0225511B170DA04D5106FC14C5C22DEDBB64CFBFF97CED09C4B0D2D6BE6A0EA2",
      "content": "export * from './proposal';\nexport * from './diff';\nexport * from './batch-limiter';\nexport * from './validator';"
    },
    {
      "path": "./src/safety/proposal.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 248,
      "chars": 6517,
      "approxTokens": 1629.0,
      "sha256": "7E6F75382E7C4ABDBFA8BD6BC17DE16258442C259D96E3E32A5BAF7FA4C71709",
      "content": "import type { DatabaseId } from '../core/types';\n\n/**\n * Represents a single property change\n */\nexport interface PropertyDiff {\n  property: string;\n  oldValue: unknown;\n  newValue: unknown;\n  impact: 'low' | 'medium' | 'high';\n}\n\n/**\n * Side effects of a proposed change\n */\nexport interface SideEffect {\n  type: 'relation_update' | 'rollup_recalc' | 'cascade';\n  description: string;\n  affectedItems: string[];\n}\n\n/**\n * Validation result for a proposed change\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * A proposed change that must be approved before execution\n * Implements the Propose → Approve → Apply safety workflow\n */\nexport interface ChangeProposal<T = unknown> {\n  id: string;\n  type: 'create' | 'update' | 'delete' | 'bulk';\n  target: {\n    database: DatabaseId;\n    pageId?: string;\n  };\n  currentState: T | null;\n  proposedState: T;\n  diff: PropertyDiff[];\n  sideEffects: SideEffect[];\n  validation: ValidationResult;\n  status: 'pending' | 'approved' | 'applied' | 'rejected' | 'failed';\n  createdAt: Date;\n  appliedAt?: Date;\n}\n\n/**\n * Result of applying a proposal\n */\nexport interface ApplyResult {\n  proposalId: string;\n  success: boolean;\n  entityId?: string;\n  error?: Error;\n  timestamp: Date;\n}\n\n/**\n * Manages the proposal lifecycle: propose → approve → apply\n */\nexport class ProposalManager {\n  private pendingProposals = new Map<string, ChangeProposal>();\n\n  /**\n   * Create a new change proposal (does NOT execute)\n   * @param change The proposed change details\n   * @returns The created proposal with unique ID\n   */\n  async propose<T>(\n    change: Omit<ChangeProposal<T>, 'id' | 'createdAt' | 'status'>\n  ): Promise<ChangeProposal<T>> {\n    const proposal: ChangeProposal<T> = {\n      ...change,\n      id: Math.random().toString(36).substring(2) + Date.now().toString(36),\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    this.pendingProposals.set(proposal.id, proposal);\n    return proposal;\n  }\n\n  /**\n   * Approve a proposal for execution\n   * @param proposalId The proposal ID to approve\n   */\n  approve(proposalId: string): void {\n    const proposal = this.pendingProposals.get(proposalId);\n    if (!proposal) {\n      throw new Error(`Proposal ${proposalId} not found`);\n    }\n    if (proposal.status !== 'pending') {\n      throw new Error(`Proposal ${proposalId} cannot be approved (status: ${proposal.status})`);\n    }\n    proposal.status = 'approved';\n  }\n\n  /**\n   * Execute an approved proposal\n   * @param proposalId The proposal ID to apply\n   * @param executor Function that performs the actual change\n   * @returns Result of the application\n   */\n  async apply(\n    proposalId: string,\n    executor: (proposal: ChangeProposal) => Promise<string>\n  ): Promise<ApplyResult> {\n    const proposal = this.pendingProposals.get(proposalId);\n    if (!proposal) {\n      throw new Error(`Proposal ${proposalId} not found`);\n    }\n    if (proposal.status !== 'approved') {\n      throw new Error(\n        `Proposal ${proposalId} must be approved before applying (status: ${proposal.status})`\n      );\n    }\n\n    try {\n      const entityId = await executor(proposal);\n      proposal.status = 'applied';\n      proposal.appliedAt = new Date();\n\n      return {\n        proposalId,\n        success: true,\n        entityId,\n        timestamp: new Date(),\n      };\n    } catch (error) {\n      proposal.status = 'failed';\n      return {\n        proposalId,\n        success: false,\n        error: error as Error,\n        timestamp: new Date(),\n      };\n    }\n  }\n\n  /**\n   * Reject a pending proposal\n   * @param proposalId The proposal ID to reject\n   */\n  reject(proposalId: string): void {\n    const proposal = this.pendingProposals.get(proposalId);\n    if (!proposal) {\n      throw new Error(`Proposal ${proposalId} not found`);\n    }\n    if (proposal.status !== 'pending') {\n      throw new Error(`Proposal ${proposalId} cannot be rejected (status: ${proposal.status})`);\n    }\n    proposal.status = 'rejected';\n  }\n\n  /**\n   * Get a proposal by ID\n   * @param proposalId The proposal ID\n   * @returns The proposal or undefined\n   */\n  get(proposalId: string): ChangeProposal | undefined {\n    return this.pendingProposals.get(proposalId);\n  }\n\n  /**\n   * Format proposal for human review\n   * @param proposal The proposal to format\n   * @returns Markdown-formatted review text\n   */\n  formatForReview<T>(proposal: ChangeProposal<T>): string {\n    const lines: string[] = [\n      `## Change Proposal: ${proposal.id}`,\n      ``,\n      `**Type**: ${proposal.type}`,\n      `**Target Database**: ${proposal.target.database}`,\n      `**Status**: ${proposal.status}`,\n      `**Created**: ${proposal.createdAt.toISOString()}`,\n      ``,\n    ];\n\n    if (proposal.diff.length > 0) {\n      lines.push(`### Property Changes`);\n      lines.push(``);\n      for (const diff of proposal.diff) {\n        lines.push(`- **${diff.property}** (${diff.impact} impact)`);\n        lines.push(`  - Old: \\`${JSON.stringify(diff.oldValue)}\\``);\n        lines.push(`  - New: \\`${JSON.stringify(diff.newValue)}\\``);\n      }\n      lines.push(``);\n    }\n\n    if (proposal.sideEffects.length > 0) {\n      lines.push(`### Side Effects`);\n      lines.push(``);\n      for (const effect of proposal.sideEffects) {\n        lines.push(`- **${effect.type}**: ${effect.description}`);\n        if (effect.affectedItems.length > 0) {\n          lines.push(`  - Affects: ${effect.affectedItems.join(', ')}`);\n        }\n      }\n      lines.push(``);\n    }\n\n    if (!proposal.validation.valid) {\n      lines.push(`### ❌ Validation Errors`);\n      lines.push(``);\n      for (const error of proposal.validation.errors) {\n        lines.push(`- ${error}`);\n      }\n      lines.push(``);\n    }\n\n    if (proposal.validation.warnings.length > 0) {\n      lines.push(`### ⚠️ Warnings`);\n      lines.push(``);\n      for (const warning of proposal.validation.warnings) {\n        lines.push(`- ${warning}`);\n      }\n      lines.push(``);\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Get all proposals with optional status filter\n   * @param status Filter by status\n   * @returns Array of proposals\n   */\n  list(status?: ChangeProposal['status']): ChangeProposal[] {\n    const proposals = Array.from(this.pendingProposals.values());\n    if (status) {\n      return proposals.filter((p) => p.status === status);\n    }\n    return proposals;\n  }\n\n  /**\n   * Clear all proposals (use with caution)\n   */\n  clear(): void {\n    this.pendingProposals.clear();\n  }\n}"
    },
    {
      "path": "./src/safety/validator.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 302,
      "chars": 8236,
      "approxTokens": 2059.0,
      "sha256": "6ED3A10EE3CC5192E62DB70377885C7B4482C59C1430696A94B7A8229F6D2367",
      "content": "import type { ValidationResult } from './proposal';\r\n\r\n/**\r\n * Validation rule for a property\r\n */\r\nexport interface ValidationRule {\r\n  field: string;\r\n  required?: boolean;\r\n  type?: 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';\r\n  allowedValues?: unknown[];\r\n  minLength?: number;\r\n  maxLength?: number;\r\n  pattern?: RegExp;\r\n  custom?: (value: unknown) => boolean;\r\n  message?: string;\r\n}\r\n\r\n/**\r\n * Validation context with additional data\r\n */\r\nexport interface ValidationContext {\r\n  /**\r\n   * Database schema information\r\n   */\r\n  schema?: {\r\n    requiredFields?: string[];\r\n    selectOptions?: Record<string, string[]>;\r\n    relationTargets?: Record<string, string>;\r\n  };\r\n\r\n  /**\r\n   * Existing entity (for updates)\r\n   */\r\n  existingEntity?: Record<string, unknown>;\r\n\r\n  /**\r\n   * Additional validator options\r\n   */\r\n  options?: {\r\n    strict?: boolean; // Fail on warnings\r\n    allowUnknownFields?: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Validation issue (error or warning)\r\n */\r\ninterface ValidationIssue {\r\n  field: string;\r\n  message: string;\r\n  severity: 'error' | 'warning';\r\n}\r\n\r\n/**\r\n * Validates entity data before mutations\r\n * Catches errors before MCP calls\r\n */\r\nexport class Validator {\r\n  /**\r\n   * Validate entity against rules\r\n   * @param entity Entity to validate\r\n   * @param rules Validation rules\r\n   * @param context Additional validation context\r\n   * @returns Validation result\r\n   */\r\n  validate(\r\n    entity: Record<string, unknown>,\r\n    rules: ValidationRule[],\r\n    context?: ValidationContext\r\n  ): ValidationResult {\r\n    const issues: ValidationIssue[] = [];\r\n\r\n    // Validate each rule\r\n    for (const rule of rules) {\r\n      const value = entity[rule.field];\r\n      const ruleIssues = this.validateField(value, rule, context);\r\n      issues.push(...ruleIssues);\r\n    }\r\n\r\n    // Check for unknown fields if strict mode\r\n    if (context?.options?.allowUnknownFields === false) {\r\n      const knownFields = new Set(rules.map((r) => r.field));\r\n      for (const field of Object.keys(entity)) {\r\n        if (!knownFields.has(field)) {\r\n          issues.push({\r\n            field,\r\n            message: `Unknown field '${field}'`,\r\n            severity: 'warning',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check schema constraints if provided\r\n    if (context?.schema) {\r\n      issues.push(...this.validateSchema(entity, context.schema));\r\n    }\r\n\r\n    // Separate errors and warnings\r\n    const errors = issues.filter((i) => i.severity === 'error').map((i) => i.message);\r\n    const warnings = issues.filter((i) => i.severity === 'warning').map((i) => i.message);\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate required properties\r\n   * @param entity Entity to validate\r\n   * @param requiredFields Required field names\r\n   * @returns Validation result\r\n   */\r\n  validateRequired(\r\n    entity: Record<string, unknown>,\r\n    requiredFields: string[]\r\n  ): ValidationResult {\r\n    const errors: string[] = [];\r\n\r\n    for (const field of requiredFields) {\r\n      const value = entity[field];\r\n      if (value === undefined || value === null || value === '') {\r\n        errors.push(`Required field '${field}' is missing`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate select option values\r\n   * @param entity Entity to validate\r\n   * @param selectOptions Map of field to allowed values\r\n   * @returns Validation result\r\n   */\r\n  validateSelectOptions(\r\n    entity: Record<string, unknown>,\r\n    selectOptions: Record<string, string[]>\r\n  ): ValidationResult {\r\n    const errors: string[] = [];\r\n\r\n    for (const [field, allowedValues] of Object.entries(selectOptions)) {\r\n      const value = entity[field];\r\n\r\n      if (value !== undefined && value !== null) {\r\n        if (!allowedValues.includes(String(value))) {\r\n          errors.push(\r\n            `Invalid value for '${field}': '${value}'. Allowed: ${allowedValues.join(', ')}`\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate date formats\r\n   * @param entity Entity to validate\r\n   * @param dateFields Date field names\r\n   * @returns Validation result\r\n   */\r\n  validateDates(entity: Record<string, unknown>, dateFields: string[]): ValidationResult {\r\n    const errors: string[] = [];\r\n\r\n    for (const field of dateFields) {\r\n      const value = entity[field];\r\n\r\n      if (value !== undefined && value !== null) {\r\n        let isValid = false;\r\n\r\n        if (value instanceof Date) {\r\n          isValid = !isNaN(value.getTime());\r\n        } else if (typeof value === 'string') {\r\n          const date = new Date(value);\r\n          isValid = !isNaN(date.getTime());\r\n        }\r\n\r\n        if (!isValid) {\r\n          errors.push(`Invalid date format for '${field}': ${value}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate relation targets\r\n   * @param entity Entity to validate\r\n   * @param relationFields Map of field to target database\r\n   * @param existingIds Optional map of database to existing IDs\r\n   * @returns Validation result\r\n   */\r\n  validateRelations(\r\n    entity: Record<string, unknown>,\r\n    relationFields: Record<string, string>,\r\n    existingIds?: Map<string, Set<string>>\r\n  ): ValidationResult {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n\r\n    for (const [field, targetDatabase] of Object.entries(relationFields)) {\r\n      const value = entity[field];\r\n\r\n      if (value !== undefined && value !== null) {\r\n        // Handle array of IDs\r\n        const ids = Array.isArray(value) ? value : [value];\r\n\r\n        for (const id of ids) {\r\n          if (typeof id !== 'string' || id.trim() === '') {\r\n            errors.push(`Invalid relation ID for '${field}': ${id}`);\r\n            continue;\r\n          }\r\n\r\n          // Check if ID exists (if we have existing IDs)\r\n          if (existingIds && !existingIds.get(targetDatabase)?.has(id as string)) {\r\n            warnings.push(`Relation '${field}' references non-existent ${targetDatabase}: ${id}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate warnings for suspicious changes\r\n   * @param current Current entity state\r\n   * @param proposed Proposed entity state\r\n   * @returns Validation result with warnings\r\n   */\r\n  generateWarnings(\r\n    current: Record<string, unknown>,\r\n    proposed: Record<string, unknown>\r\n  ): ValidationResult {\r\n    const warnings: string[] = [];\r\n\r\n    // Warn about status changes\r\n    if (current.status && proposed.status && current.status !== proposed.status) {\r\n      warnings.push(\r\n        `Status change: ${current.status} → ${proposed.status}. Verify this is intentional.`\r\n      );\r\n    }\r\n\r\n    // Warn about completion changes\r\n    if (current.done === true && proposed.done === false) {\r\n      warnings.push(`Marking completed task as incomplete. This may affect metrics.`);\r\n    }\r\n\r\n    // Warn about date changes backwards in time\r\n    if (current.due && proposed.due) {\r\n      const currentDate = new Date(current.due as string);\r\n      const proposedDate = new Date(proposed.due as string);\r\n\r\n      if (proposedDate < currentDate && proposedDate < new Date()) {\r\n        warnings.push(`Setting due date to past: ${proposedDate.toISOString()}`);\r\n      }\r\n    }\r\n\r\n    // Warn about removing relations\r\n    for (const [key, value] of Object.entries(current)) {\r\n      if (key.toLowerCase().includes('relation') || key.endsWith('Id')) {\r\n        if (value && !proposed[key]) {\r\n          warnings.push(`Removing relation '${key}'. This may break dependencies.`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      errors: [],\r\n      warnings,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate a single field against a rule\r\n   */\r\n  private validateField(\r\n    value: unknown,\r\n    rule: ValidationRule,\r\n    _context?: ValidationContext\r\n  ): ValidationIssue[] {"
    },
    {
      "path": "./src/safety/validator.ts",
      "category": "safety",
      "startLine": 303,
      "endLine": 431,
      "chars": 3786,
      "approxTokens": 946.0,
      "sha256": "F755825EBC9F89317EF51779E4D4A070FF2C6783CED13CA3F03ABD3F41EAB8C5",
      "content": "    const issues: ValidationIssue[] = [];\r\n\r\n    // Required check\r\n    if (rule.required && (value === undefined || value === null || value === '')) {\r\n      issues.push({\r\n        field: rule.field,\r\n        message: rule.message || `Field '${rule.field}' is required`,\r\n        severity: 'error',\r\n      });\r\n      return issues; // Stop further validation if required field is missing\r\n    }\r\n\r\n    // Skip validation if value is not provided and not required\r\n    if (value === undefined || value === null) {\r\n      return issues;\r\n    }\r\n\r\n    // Type check\r\n    if (rule.type) {\r\n      const actualType = this.getValueType(value);\r\n      if (actualType !== rule.type) {\r\n        issues.push({\r\n          field: rule.field,\r\n          message: `Field '${rule.field}' must be of type ${rule.type}, got ${actualType}`,\r\n          severity: 'error',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Allowed values check\r\n    if (rule.allowedValues && !rule.allowedValues.includes(value)) {\r\n      issues.push({\r\n        field: rule.field,\r\n        message: `Field '${rule.field}' has invalid value. Allowed: ${rule.allowedValues.join(', ')}`,\r\n        severity: 'error',\r\n      });\r\n    }\r\n\r\n    // String validations\r\n    if (typeof value === 'string') {\r\n      if (rule.minLength && value.length < rule.minLength) {\r\n        issues.push({\r\n          field: rule.field,\r\n          message: `Field '${rule.field}' must be at least ${rule.minLength} characters`,\r\n          severity: 'error',\r\n        });\r\n      }\r\n\r\n      if (rule.maxLength && value.length > rule.maxLength) {\r\n        issues.push({\r\n          field: rule.field,\r\n          message: `Field '${rule.field}' must be at most ${rule.maxLength} characters`,\r\n          severity: 'error',\r\n        });\r\n      }\r\n\r\n      if (rule.pattern && !rule.pattern.test(value)) {\r\n        issues.push({\r\n          field: rule.field,\r\n          message: `Field '${rule.field}' does not match required pattern`,\r\n          severity: 'error',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Custom validation\r\n    if (rule.custom && !rule.custom(value)) {\r\n      issues.push({\r\n        field: rule.field,\r\n        message: rule.message || `Field '${rule.field}' failed custom validation`,\r\n        severity: 'error',\r\n      });\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Validate against schema constraints\r\n   */\r\n  private validateSchema(\r\n    entity: Record<string, unknown>,\r\n    schema: NonNullable<ValidationContext['schema']>\r\n  ): ValidationIssue[] {\r\n    const issues: ValidationIssue[] = [];\r\n\r\n    // Validate required fields\r\n    if (schema.requiredFields) {\r\n      for (const field of schema.requiredFields) {\r\n        const value = entity[field];\r\n        if (value === undefined || value === null || value === '') {\r\n          issues.push({\r\n            field,\r\n            message: `Required field '${field}' is missing`,\r\n            severity: 'error',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate select options\r\n    if (schema.selectOptions) {\r\n      for (const [field, allowedValues] of Object.entries(schema.selectOptions)) {\r\n        const value = entity[field];\r\n        if (value !== undefined && value !== null) {\r\n          if (!allowedValues.includes(String(value))) {\r\n            issues.push({\r\n              field,\r\n              message: `Invalid value for '${field}': '${value}'. Allowed: ${allowedValues.join(', ')}`,\r\n              severity: 'error',\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Get the type of a value\r\n   */\r\n  private getValueType(value: unknown): string {\r\n    if (Array.isArray(value)) return 'array';\r\n    if (value instanceof Date) return 'date';\r\n    if (value === null) return 'null';\r\n    return typeof value;\r\n  }\r\n}"
    },
    {
      "path": "./src/safety/__tests__/batch-limiter.test.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 231,
      "chars": 8242,
      "approxTokens": 2060.0,
      "sha256": "FECB43AAC2744413B3D0A32E7D2E7C6830A0C33E0AE08CD46CCE0CE00DA0A8B6",
      "content": "import { describe, it, expect } from 'vitest';\r\nimport { BatchLimiter } from '../batch-limiter';\r\nimport { BatchLimitExceededError } from '../../core/errors';\r\n\r\ndescribe('BatchLimiter', () => {\r\n  describe('validateBatchSize', () => {\r\n    it('should not throw for batches within limit', () => {\r\n      const limiter = new BatchLimiter();\r\n      expect(() => limiter.validateBatchSize(50)).not.toThrow();\r\n      expect(() => limiter.validateBatchSize(25)).not.toThrow();\r\n    });\r\n\r\n    it('should throw for batches exceeding limit', () => {\r\n      const limiter = new BatchLimiter();\r\n      expect(() => limiter.validateBatchSize(51)).toThrow(BatchLimitExceededError);\r\n      expect(() => limiter.validateBatchSize(100)).toThrow(BatchLimitExceededError);\r\n    });\r\n\r\n    it('should respect custom batch size', () => {\r\n      const limiter = new BatchLimiter({ maxBatchSize: 10 });\r\n      expect(() => limiter.validateBatchSize(10)).not.toThrow();\r\n      expect(() => limiter.validateBatchSize(11)).toThrow(BatchLimitExceededError);\r\n    });\r\n  });\r\n\r\n  describe('isWithinLimit', () => {\r\n    it('should return true for batches within limit', () => {\r\n      const limiter = new BatchLimiter();\r\n      expect(limiter.isWithinLimit(50)).toBe(true);\r\n      expect(limiter.isWithinLimit(25)).toBe(true);\r\n    });\r\n\r\n    it('should return false for batches exceeding limit', () => {\r\n      const limiter = new BatchLimiter();\r\n      expect(limiter.isWithinLimit(51)).toBe(false);\r\n      expect(limiter.isWithinLimit(100)).toBe(false);\r\n    });\r\n  });\r\n\r\n  describe('splitBatch', () => {\r\n    it('should return single chunk for small batches', () => {\r\n      const limiter = new BatchLimiter({ allowSplit: true });\r\n      const items = Array.from({ length: 25 }, (_, i) => i);\r\n      const chunks = limiter.splitBatch(items);\r\n\r\n      expect(chunks).toHaveLength(1);\r\n      expect(chunks[0]).toHaveLength(25);\r\n    });\r\n\r\n    it('should split large batches when allowSplit is true', () => {\r\n      const limiter = new BatchLimiter({ allowSplit: true });\r\n      const items = Array.from({ length: 75 }, (_, i) => i);\r\n      const chunks = limiter.splitBatch(items);\r\n\r\n      expect(chunks).toHaveLength(2);\r\n      expect(chunks[0]).toHaveLength(50);\r\n      expect(chunks[1]).toHaveLength(25);\r\n    });\r\n\r\n    it('should throw when allowSplit is false and batch exceeds limit', () => {\r\n      const limiter = new BatchLimiter({ allowSplit: false });\r\n      const items = Array.from({ length: 75 }, (_, i) => i);\r\n\r\n      expect(() => limiter.splitBatch(items)).toThrow(BatchLimitExceededError);\r\n    });\r\n\r\n    it('should split into exact chunks', () => {\r\n      const limiter = new BatchLimiter({ maxBatchSize: 10, allowSplit: true });\r\n      const items = Array.from({ length: 30 }, (_, i) => i);\r\n      const chunks = limiter.splitBatch(items);\r\n\r\n      expect(chunks).toHaveLength(3);\r\n      expect(chunks[0]).toHaveLength(10);\r\n      expect(chunks[1]).toHaveLength(10);\r\n      expect(chunks[2]).toHaveLength(10);\r\n    });\r\n  });\r\n\r\n  describe('generateDryRunSummary', () => {\r\n    it('should generate summary for small batch', () => {\r\n      const limiter = new BatchLimiter();\r\n      const summary = limiter.generateDryRunSummary(25);\r\n\r\n      expect(summary.itemCount).toBe(25);\r\n      expect(summary.chunks).toBe(1);\r\n      expect(summary.estimatedDuration).toBeGreaterThan(0);\r\n      expect(summary.id).toBeDefined();\r\n    });\r\n\r\n    it('should calculate multiple chunks for large batch', () => {\r\n      const limiter = new BatchLimiter();\r\n      const summary = limiter.generateDryRunSummary(120);\r\n\r\n      expect(summary.itemCount).toBe(120);\r\n      expect(summary.chunks).toBe(3); // 50 + 50 + 20\r\n    });\r\n\r\n    it('should estimate duration correctly', () => {\r\n      const limiter = new BatchLimiter();\r\n      const summary = limiter.generateDryRunSummary(30);\r\n\r\n      // 30 items * 333ms = ~10s\r\n      expect(summary.estimatedDuration).toBeGreaterThanOrEqual(9000);\r\n      expect(summary.estimatedDuration).toBeLessThanOrEqual(11000);\r\n    });\r\n  });\r\n\r\n  describe('executeBatch', () => {\r\n    it('should execute all items successfully', async () => {\r\n      const limiter = new BatchLimiter();\r\n      const items = [1, 2, 3, 4, 5];\r\n      const results: number[] = [];\r\n\r\n      const result = await limiter.executeBatch(items, async (item) => {\r\n        results.push(item);\r\n        return item * 2;\r\n      });\r\n\r\n      expect(result.successful).toBe(5);\r\n      expect(result.failed).toBe(0);\r\n      expect(result.errors).toHaveLength(0);\r\n      expect(results).toEqual([1, 2, 3, 4, 5]);\r\n    });\r\n\r\n    it('should handle failures', async () => {\r\n      const limiter = new BatchLimiter();\r\n      const items = [1, 2, 3, 4, 5];\r\n\r\n      const result = await limiter.executeBatch(items, async (item) => {\r\n        if (item === 3) {\r\n          throw new Error('Failed on 3');\r\n        }\r\n        return item * 2;\r\n      });\r\n\r\n      expect(result.successful).toBe(4);\r\n      expect(result.failed).toBe(1);\r\n      expect(result.errors).toHaveLength(1);\r\n      expect(result.errors[0]?.index).toBe(2);\r\n      expect(result.errors[0]?.error.message).toBe('Failed on 3');\r\n    });\r\n\r\n    it('should call progress callback', async () => {\r\n      const progressCalls: Array<{ completed: number; total: number }> = [];\r\n      const limiter = new BatchLimiter({\r\n        onProgress: (completed, total) => progressCalls.push({ completed, total }),\r\n      });\r\n      const items = [1, 2, 3];\r\n\r\n      await limiter.executeBatch(items, async (item) => item * 2);\r\n\r\n      expect(progressCalls).toHaveLength(3);\r\n      expect(progressCalls[0]).toEqual({ completed: 1, total: 3 });\r\n      expect(progressCalls[1]).toEqual({ completed: 2, total: 3 });\r\n      expect(progressCalls[2]).toEqual({ completed: 3, total: 3 });\r\n    });\r\n\r\n    it('should handle large batches with splitting', async () => {\r\n      const limiter = new BatchLimiter({ maxBatchSize: 10, allowSplit: true });\r\n      const items = Array.from({ length: 25 }, (_, i) => i);\r\n      const results: number[] = [];\r\n\r\n      const result = await limiter.executeBatch(items, async (item) => {\r\n        results.push(item);\r\n        return item;\r\n      });\r\n\r\n      expect(result.successful).toBe(25);\r\n      expect(results).toHaveLength(25);\r\n    });\r\n  });\r\n\r\n  describe('formatSummary', () => {\r\n    it('should format single chunk summary', () => {\r\n      const limiter = new BatchLimiter();\r\n      const summary = limiter.generateDryRunSummary(25);\r\n      const formatted = limiter.formatSummary(summary);\r\n\r\n      expect(formatted).toContain('**Total Items**: 25');\r\n      expect(formatted).toContain('**Chunks**: 1');\r\n    });\r\n\r\n    it('should format multiple chunk summary', () => {\r\n      const limiter = new BatchLimiter();\r\n      const summary = limiter.generateDryRunSummary(120);\r\n      const formatted = limiter.formatSummary(summary);\r\n\r\n      expect(formatted).toContain('**Total Items**: 120');\r\n      expect(formatted).toContain('**Chunks**: 3');\r\n      expect(formatted).toContain('processed in 3 chunks');\r\n    });\r\n  });\r\n\r\n  describe('formatResult', () => {\r\n    it('should format successful result', () => {\r\n      const limiter = new BatchLimiter();\r\n      const result = {\r\n        successful: 10,\r\n        failed: 0,\r\n        errors: [],\r\n        duration: 5000,\r\n      };\r\n\r\n      const formatted = limiter.formatResult(result);\r\n\r\n      expect(formatted).toContain('**Successful**: 10');\r\n      expect(formatted).toContain('**Failed**: 0');\r\n    });\r\n\r\n    it('should format result with errors', () => {\r\n      const limiter = new BatchLimiter();\r\n      const result = {\r\n        successful: 8,\r\n        failed: 2,\r\n        errors: [\r\n          { index: 3, error: new Error('Error 1') },\r\n          { index: 7, error: new Error('Error 2') },\r\n        ],\r\n        duration: 5000,\r\n      };\r\n\r\n      const formatted = limiter.formatResult(result);\r\n\r\n      expect(formatted).toContain('**Successful**: 8');\r\n      expect(formatted).toContain('**Failed**: 2');\r\n      expect(formatted).toContain('Errors');\r\n      expect(formatted).toContain('Item 3');\r\n      expect(formatted).toContain('Item 7');\r\n    });\r\n\r\n    it('should truncate large error lists', () => {"
    },
    {
      "path": "./src/safety/__tests__/batch-limiter.test.ts",
      "category": "safety",
      "startLine": 232,
      "endLine": 250,
      "chars": 436,
      "approxTokens": 109.0,
      "sha256": "5E79027C8E4E06B5A0263F95D4AEE118C7316275910B4B56981DA65A8C2DA6C0",
      "content": "      const limiter = new BatchLimiter();\r\n      const errors = Array.from({ length: 20 }, (_, i) => ({\r\n        index: i,\r\n        error: new Error(`Error ${i}`),\r\n      }));\r\n\r\n      const result = {\r\n        successful: 0,\r\n        failed: 20,\r\n        errors,\r\n        duration: 5000,\r\n      };\r\n\r\n      const formatted = limiter.formatResult(result);\r\n\r\n      expect(formatted).toContain('and 10 more errors');\r\n    });\r\n  });\r\n});"
    },
    {
      "path": "./src/safety/__tests__/diff.test.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 200,
      "chars": 6966,
      "approxTokens": 1742.0,
      "sha256": "41B3D787A974F76300F1868A2F57D7D8EA2AEA2E70EF5F14474159D7EFF93BA7",
      "content": "import { describe, it, expect } from 'vitest';\nimport { DiffEngine } from '../diff';\n\ndescribe('DiffEngine', () => {\n  const engine = new DiffEngine();\n\n  describe('computeDiff', () => {\n    it('should detect property additions when current is null', () => {\n      const proposed = { name: 'Test', priority: 'High' };\n      const diffs = engine.computeDiff(null, proposed);\n\n      expect(diffs).toHaveLength(2);\n      expect(diffs[0]).toMatchObject({\n        property: 'name',\n        oldValue: null,\n        newValue: 'Test',\n      });\n      expect(diffs[1]).toMatchObject({\n        property: 'priority',\n        oldValue: null,\n        newValue: 'High',\n      });\n    });\n\n    it('should detect modified properties', () => {\n      const current = { name: 'Old Name', priority: 'Low' };\n      const proposed = { name: 'New Name', priority: 'Low' };\n      const diffs = engine.computeDiff(current, proposed);\n\n      expect(diffs).toHaveLength(1);\n      expect(diffs[0]).toMatchObject({\n        property: 'name',\n        oldValue: 'Old Name',\n        newValue: 'New Name',\n      });\n    });\n\n    it('should detect removed properties', () => {\n      const current = { name: 'Test', priority: 'High', extra: 'value' };\n      const proposed = { name: 'Test', priority: 'High' };\n      const diffs = engine.computeDiff(current, proposed);\n\n      expect(diffs).toHaveLength(1);\n      expect(diffs[0]).toMatchObject({\n        property: 'extra',\n        oldValue: 'value',\n        newValue: undefined,\n      });\n    });\n\n    it('should return empty array when no changes', () => {\n      const current = { name: 'Test', priority: 'High' };\n      const proposed = { name: 'Test', priority: 'High' };\n      const diffs = engine.computeDiff(current, proposed);\n\n      expect(diffs).toHaveLength(0);\n    });\n\n    it('should handle date comparisons', () => {\n      const date1 = new Date('2026-01-01');\n      const date2 = new Date('2026-01-02');\n      const current = { due: date1 };\n      const proposed = { due: date2 };\n      const diffs = engine.computeDiff(current, proposed);\n\n      expect(diffs).toHaveLength(1);\n      expect(diffs[0]?.property).toBe('due');\n    });\n\n    it('should handle array comparisons', () => {\n      const current = { tags: ['a', 'b'] };\n      const proposed = { tags: ['a', 'b', 'c'] };\n      const diffs = engine.computeDiff(current, proposed);\n\n      expect(diffs).toHaveLength(1);\n      expect(diffs[0]?.property).toBe('tags');\n    });\n  });\n\n  describe('assessImpact', () => {\n    it('should assign high impact to critical properties', () => {\n      expect(engine.assessImpact('id', 'old', 'new')).toBe('high');\n      expect(engine.assessImpact('status', 'Active', 'Completed')).toBe('high');\n      expect(engine.assessImpact('done', false, true)).toBe('high');\n    });\n\n    it('should assign high impact to relation changes', () => {\n      expect(engine.assessImpact('projectId', 'old', 'new')).toBe('high');\n      expect(engine.assessImpact('teamRelation', 'old', 'new')).toBe('high');\n    });\n\n    it('should assign high impact to deletions', () => {\n      expect(engine.assessImpact('anyField', 'value', null)).toBe('high');\n      expect(engine.assessImpact('anyField', 'value', undefined)).toBe('high');\n    });\n\n    it('should assign medium impact to date changes', () => {\n      expect(engine.assessImpact('due', '2026-01-01', '2026-01-02')).toBe('medium');\n      expect(engine.assessImpact('startDate', '2026-01-01', '2026-01-02')).toBe('medium');\n    });\n\n    it('should assign medium impact to priority changes', () => {\n      expect(engine.assessImpact('priority', 'Low', 'High')).toBe('medium');\n    });\n\n    it('should assign low impact to other changes', () => {\n      expect(engine.assessImpact('description', 'old', 'new')).toBe('low');\n      expect(engine.assessImpact('notes', 'old', 'new')).toBe('low');\n    });\n  });\n\n  describe('hasRelationChanges', () => {\n    it('should detect relation changes', () => {\n      const diffs = [\n        { property: 'projectId', oldValue: 'old', newValue: 'new', impact: 'high' as const },\n        { property: 'name', oldValue: 'old', newValue: 'new', impact: 'low' as const },\n      ];\n\n      expect(engine.hasRelationChanges(diffs)).toBe(true);\n    });\n\n    it('should return false when no relation changes', () => {\n      const diffs = [\n        { property: 'name', oldValue: 'old', newValue: 'new', impact: 'low' as const },\n        { property: 'priority', oldValue: 'Low', newValue: 'High', impact: 'medium' as const },\n      ];\n\n      expect(engine.hasRelationChanges(diffs)).toBe(false);\n    });\n  });\n\n  describe('formatAsMarkdown', () => {\n    it('should format diffs as markdown', () => {\n      const diffs = [\n        { property: 'name', oldValue: 'Old', newValue: 'New', impact: 'low' as const },\n        { property: 'priority', oldValue: 'Low', newValue: 'High', impact: 'medium' as const },\n      ];\n\n      const markdown = engine.formatAsMarkdown(diffs);\n\n      expect(markdown).toContain('name');\n      expect(markdown).toContain('priority');\n      expect(markdown).toContain('Old');\n      expect(markdown).toContain('New');\n    });\n\n    it('should handle empty diffs', () => {\n      const markdown = engine.formatAsMarkdown([]);\n      expect(markdown).toContain('No changes');\n    });\n\n    it('should format removed properties', () => {\n      const diffs = [\n        { property: 'extra', oldValue: 'value', newValue: undefined, impact: 'high' as const },\n      ];\n\n      const markdown = engine.formatAsMarkdown(diffs);\n      expect(markdown).toContain('Removed');\n    });\n  });\n\n  describe('generateSummary', () => {\n    it('should summarize changes', () => {\n      const diffs = [\n        { property: 'name', oldValue: null, newValue: 'New', impact: 'low' as const },\n        { property: 'priority', oldValue: 'Low', newValue: 'High', impact: 'medium' as const },\n        { property: 'extra', oldValue: 'value', newValue: undefined, impact: 'high' as const },\n      ];\n\n      const summary = engine.generateSummary(diffs);\n      expect(summary).toContain('added');\n      expect(summary).toContain('modified');\n      expect(summary).toContain('removed');\n    });\n\n    it('should return \"No changes\" for empty diffs', () => {\n      const summary = engine.generateSummary([]);\n      expect(summary).toBe('No changes');\n    });\n\n    it('should handle only additions', () => {\n      const diffs = [\n        { property: 'name', oldValue: null, newValue: 'New', impact: 'low' as const },\n        { property: 'priority', oldValue: null, newValue: 'High', impact: 'medium' as const },\n      ];\n\n      const summary = engine.generateSummary(diffs);\n      expect(summary).toBe('2 added');\n    });\n\n    it('should handle only modifications', () => {\n      const diffs = [\n        { property: 'name', oldValue: 'Old', newValue: 'New', impact: 'low' as const },\n      ];\n\n      const summary = engine.generateSummary(diffs);\n      expect(summary).toBe('1 modified');\n    });\n  });\n});"
    },
    {
      "path": "./src/safety/__tests__/proposal.test.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 223,
      "chars": 6404,
      "approxTokens": 1601.0,
      "sha256": "07DE581DA85C117D6CF510AD449F87EEF892042012F5867F4285AA07B4291FCD",
      "content": "import { describe, it, expect } from 'vitest';\nimport { ProposalManager } from '../proposal';\nimport { DATABASE_IDS } from '../../core/types';\n\ndescribe('ProposalManager', () => {\n  it('should create a proposal with pending status', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    expect(proposal.id).toBeDefined();\n    expect(proposal.status).toBe('pending');\n    expect(proposal.createdAt).toBeInstanceOf(Date);\n  });\n\n  it('should approve a pending proposal', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.approve(proposal.id);\n\n    const retrieved = manager.get(proposal.id);\n    expect(retrieved?.status).toBe('approved');\n  });\n\n  it('should reject a pending proposal', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.reject(proposal.id);\n\n    const retrieved = manager.get(proposal.id);\n    expect(retrieved?.status).toBe('rejected');\n  });\n\n  it('should apply an approved proposal', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.approve(proposal.id);\n\n    const executor = async () => 'entity-123';\n    const result = await manager.apply(proposal.id, executor);\n\n    expect(result.success).toBe(true);\n    expect(result.entityId).toBe('entity-123');\n\n    const retrieved = manager.get(proposal.id);\n    expect(retrieved?.status).toBe('applied');\n    expect(retrieved?.appliedAt).toBeInstanceOf(Date);\n  });\n\n  it('should not apply a proposal without approval', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    const executor = async () => 'entity-123';\n\n    await expect(manager.apply(proposal.id, executor)).rejects.toThrow('must be approved');\n  });\n\n  it('should not approve an already approved proposal', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.approve(proposal.id);\n\n    expect(() => manager.approve(proposal.id)).toThrow('cannot be approved');\n  });\n\n  it('should format proposal for review', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [\n        {\n          property: 'name',\n          oldValue: null,\n          newValue: 'Test Task',\n          impact: 'medium',\n        },\n      ],\n      sideEffects: [\n        {\n          type: 'relation_update',\n          description: 'Updates project relation',\n          affectedItems: ['project-1'],\n        },\n      ],\n      validation: {\n        valid: true,\n        errors: [],\n        warnings: ['This is a test warning'],\n      },\n    });\n\n    const formatted = manager.formatForReview(proposal);\n\n    expect(formatted).toContain('Change Proposal');\n    expect(formatted).toContain('create');\n    expect(formatted).toContain('Property Changes');\n    expect(formatted).toContain('name');\n    expect(formatted).toContain('Side Effects');\n    expect(formatted).toContain('Warnings');\n  });\n\n  it('should list proposals by status', async () => {\n    const manager = new ProposalManager();\n\n    await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Task 1' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    const proposal2 = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Task 2' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.approve(proposal2.id);\n\n    const pending = manager.list('pending');\n    const approved = manager.list('approved');\n\n    expect(pending).toHaveLength(1);\n    expect(approved).toHaveLength(1);\n  });\n\n  it('should handle failed proposal application', async () => {\n    const manager = new ProposalManager();\n\n    const proposal = await manager.propose({\n      type: 'create',\n      target: { database: DATABASE_IDS.TASKS },\n      currentState: null,\n      proposedState: { name: 'Test Task' },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n    });\n\n    manager.approve(proposal.id);\n\n    const executor = async () => {\n      throw new Error('Execution failed');\n    };\n\n    const result = await manager.apply(proposal.id, executor);\n\n    expect(result.success).toBe(false);\n    expect(result.error).toBeInstanceOf(Error);\n\n    const retrieved = manager.get(proposal.id);\n    expect(retrieved?.status).toBe('failed');\n  });\n});"
    },
    {
      "path": "./src/safety/__tests__/validator.test.ts",
      "category": "safety",
      "startLine": 1,
      "endLine": 250,
      "chars": 7977,
      "approxTokens": 1994.0,
      "sha256": "37DD1E934A78252469A1CD3F16F6F553E5EF583939B3FA7B1F73C36FBA34545A",
      "content": "import { describe, it, expect } from 'vitest';\r\nimport { Validator } from '../validator';\r\n\r\ndescribe('Validator', () => {\r\n  const validator = new Validator();\r\n\r\n  describe('validate', () => {\r\n    it('should validate required fields', () => {\r\n      const entity = { name: 'Test' };\r\n      const rules = [{ field: 'name', required: true }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n      expect(result.errors).toHaveLength(0);\r\n    });\r\n\r\n    it('should fail when required field is missing', () => {\r\n      const entity = {};\r\n      const rules = [{ field: 'name', required: true }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors).toHaveLength(1);\r\n      expect(result.errors[0]).toContain('required');\r\n    });\r\n\r\n    it('should validate field types', () => {\r\n      const entity = { name: 'Test', age: 25 };\r\n      const rules = [\r\n        { field: 'name', type: 'string' as const },\r\n        { field: 'age', type: 'number' as const },\r\n      ];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on type mismatch', () => {\r\n      const entity = { name: 123 };\r\n      const rules = [{ field: 'name', type: 'string' as const }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('type');\r\n    });\r\n\r\n    it('should validate allowed values', () => {\r\n      const entity = { status: 'Active' };\r\n      const rules = [{ field: 'status', allowedValues: ['Active', 'Completed', 'On Hold'] }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on invalid value', () => {\r\n      const entity = { status: 'Invalid' };\r\n      const rules = [{ field: 'status', allowedValues: ['Active', 'Completed'] }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('invalid value');\r\n    });\r\n\r\n    it('should validate string length', () => {\r\n      const entity = { name: 'Test' };\r\n      const rules = [{ field: 'name', minLength: 2, maxLength: 10 }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on string too short', () => {\r\n      const entity = { name: 'A' };\r\n      const rules = [{ field: 'name', minLength: 2 }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('at least');\r\n    });\r\n\r\n    it('should fail on string too long', () => {\r\n      const entity = { name: 'Very Long Name' };\r\n      const rules = [{ field: 'name', maxLength: 5 }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('at most');\r\n    });\r\n\r\n    it('should validate pattern', () => {\r\n      const entity = { email: 'test@example.com' };\r\n      // eslint-disable-next-line no-useless-escape\r\n      const rules = [{ field: 'email', pattern: /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/ }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on pattern mismatch', () => {\r\n      const entity = { email: 'invalid-email' };\r\n      // eslint-disable-next-line no-useless-escape\r\n      const rules = [{ field: 'email', pattern: /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/ }];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n    });\r\n\r\n    it('should run custom validation', () => {\r\n      const entity = { age: 25 };\r\n      const rules = [\r\n        {\r\n          field: 'age',\r\n          custom: (value: unknown) => typeof value === 'number' && value >= 18,\r\n        },\r\n      ];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail custom validation', () => {\r\n      const entity = { age: 15 };\r\n      const rules = [\r\n        {\r\n          field: 'age',\r\n          custom: (value: unknown) => typeof value === 'number' && value >= 18,\r\n        },\r\n      ];\r\n\r\n      const result = validator.validate(entity, rules);\r\n\r\n      expect(result.valid).toBe(false);\r\n    });\r\n\r\n    it('should warn about unknown fields in strict mode', () => {\r\n      const entity = { name: 'Test', extra: 'field' };\r\n      const rules = [{ field: 'name', required: true }];\r\n      const context = { options: { allowUnknownFields: false } };\r\n\r\n      const result = validator.validate(entity, rules, context);\r\n\r\n      expect(result.valid).toBe(true);\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('Unknown field');\r\n    });\r\n  });\r\n\r\n  describe('validateRequired', () => {\r\n    it('should validate all required fields present', () => {\r\n      const entity = { name: 'Test', status: 'Active' };\r\n      const result = validator.validateRequired(entity, ['name', 'status']);\r\n\r\n      expect(result.valid).toBe(true);\r\n      expect(result.errors).toHaveLength(0);\r\n    });\r\n\r\n    it('should detect missing required fields', () => {\r\n      const entity = { name: 'Test' };\r\n      const result = validator.validateRequired(entity, ['name', 'status']);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors).toHaveLength(1);\r\n      expect(result.errors[0]).toContain('status');\r\n    });\r\n\r\n    it('should detect empty strings as missing', () => {\r\n      const entity = { name: '' };\r\n      const result = validator.validateRequired(entity, ['name']);\r\n\r\n      expect(result.valid).toBe(false);\r\n    });\r\n  });\r\n\r\n  describe('validateSelectOptions', () => {\r\n    it('should validate select options', () => {\r\n      const entity = { status: 'Active', priority: 'High' };\r\n      const options = {\r\n        status: ['Active', 'Completed', 'On Hold'],\r\n        priority: ['High', 'Medium', 'Low'],\r\n      };\r\n\r\n      const result = validator.validateSelectOptions(entity, options);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on invalid select value', () => {\r\n      const entity = { status: 'Invalid' };\r\n      const options = { status: ['Active', 'Completed'] };\r\n\r\n      const result = validator.validateSelectOptions(entity, options);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('Invalid value');\r\n    });\r\n\r\n    it('should allow undefined values', () => {\r\n      const entity = {};\r\n      const options = { status: ['Active', 'Completed'] };\r\n\r\n      const result = validator.validateSelectOptions(entity, options);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('validateDates', () => {\r\n    it('should validate Date objects', () => {\r\n      const entity = { due: new Date('2026-01-01') };\r\n      const result = validator.validateDates(entity, ['due']);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should validate ISO date strings', () => {\r\n      const entity = { due: '2026-01-01T00:00:00.000Z' };\r\n      const result = validator.validateDates(entity, ['due']);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on invalid date format', () => {\r\n      const entity = { due: 'not-a-date' };\r\n      const result = validator.validateDates(entity, ['due']);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('Invalid date format');\r\n    });\r\n\r\n    it('should fail on invalid Date object', () => {\r\n      const entity = { due: new Date('invalid') };\r\n      const result = validator.validateDates(entity, ['due']);\r\n\r\n      expect(result.valid).toBe(false);\r\n    });\r\n\r\n    it('should allow undefined dates', () => {\r\n      const entity = {};"
    },
    {
      "path": "./src/safety/__tests__/validator.test.ts",
      "category": "safety",
      "startLine": 251,
      "endLine": 349,
      "chars": 3278,
      "approxTokens": 820.0,
      "sha256": "880041FFD3415B0F545BC7DF3B54B6C1158CAA47EF2689B6EDFEB375AFA34797",
      "content": "      const result = validator.validateDates(entity, ['due']);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('validateRelations', () => {\r\n    it('should validate relation IDs', () => {\r\n      const entity = { projectId: 'proj-123' };\r\n      const relations = { projectId: 'Projects' };\r\n\r\n      const result = validator.validateRelations(entity, relations);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should validate array of relation IDs', () => {\r\n      const entity = { teamIds: ['team-1', 'team-2'] };\r\n      const relations = { teamIds: 'Teams' };\r\n\r\n      const result = validator.validateRelations(entity, relations);\r\n\r\n      expect(result.valid).toBe(true);\r\n    });\r\n\r\n    it('should fail on empty relation ID', () => {\r\n      const entity = { projectId: '' };\r\n      const relations = { projectId: 'Projects' };\r\n\r\n      const result = validator.validateRelations(entity, relations);\r\n\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors[0]).toContain('Invalid relation ID');\r\n    });\r\n\r\n    it('should warn on non-existent relation target', () => {\r\n      const entity = { projectId: 'proj-999' };\r\n      const relations = { projectId: 'Projects' };\r\n      const existingIds = new Map([['Projects', new Set(['proj-123', 'proj-456'])]]);\r\n\r\n      const result = validator.validateRelations(entity, relations, existingIds);\r\n\r\n      expect(result.valid).toBe(true);\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('non-existent');\r\n    });\r\n  });\r\n\r\n  describe('generateWarnings', () => {\r\n    it('should warn on status changes', () => {\r\n      const current = { status: 'Active' };\r\n      const proposed = { status: 'Completed' };\r\n\r\n      const result = validator.generateWarnings(current, proposed);\r\n\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('Status change');\r\n    });\r\n\r\n    it('should warn when marking completed task as incomplete', () => {\r\n      const current = { done: true };\r\n      const proposed = { done: false };\r\n\r\n      const result = validator.generateWarnings(current, proposed);\r\n\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('incomplete');\r\n    });\r\n\r\n    it('should warn on past due dates', () => {\r\n      const current = { due: new Date('2026-02-01') };\r\n      const proposed = { due: new Date('2025-01-01') };\r\n\r\n      const result = validator.generateWarnings(current, proposed);\r\n\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('past');\r\n    });\r\n\r\n    it('should warn when removing relations', () => {\r\n      const current = { projectId: 'proj-123', name: 'Task' };\r\n      const proposed = { name: 'Task' };\r\n\r\n      const result = validator.generateWarnings(current, proposed);\r\n\r\n      expect(result.warnings).toHaveLength(1);\r\n      expect(result.warnings[0]).toContain('Removing relation');\r\n    });\r\n\r\n    it('should not warn on normal changes', () => {\r\n      const current = { name: 'Old Name' };\r\n      const proposed = { name: 'New Name' };\r\n\r\n      const result = validator.generateWarnings(current, proposed);\r\n\r\n      expect(result.warnings).toHaveLength(0);\r\n    });\r\n  });\r\n});"
    },
    {
      "path": "./src/schemas/index.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 56,
      "chars": 1893,
      "approxTokens": 473.0,
      "sha256": "6CC0BBB2720E429A62AEB4ABCFD1B0B38012C577EF9729772BC98201C5ACA7EE",
      "content": "import { z } from 'zod';\n\nconst notionId = z.string();\nconst isoDate = z.string(); // ISO 8601\n\nexport const TeamSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  meetings: z.array(notionId).default([]),\n  projects: z.array(notionId).default([]),\n  projectsComplete: z.number().optional(), // rollup/formula\n  tasks: z.array(notionId).default([]),\n  tasksCompleted: z.number().optional(), // rollup/formula\n});\nexport type Team = z.infer<typeof TeamSchema>;\n\nexport const ProjectSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  status: z.enum(['Active', 'Completed', 'On Hold', 'Cancelled']),\n  milestone: z.enum(['M1', 'M2', 'M3']).nullable(),\n  phase: z\n    .enum(['P1.1', 'P1.2', 'P1.3', 'P2.1', 'P2.2', 'P2.3', 'P3.1', 'P3.2', 'P3.3'])\n    .nullable(),\n  domain: z.enum(['OPS', 'PROD', 'DES', 'ENG', 'MKT', 'RES']).nullable(),\n  startDate: isoDate.nullable(),\n  endDate: isoDate.nullable(),\n  teamId: notionId.optional(),\n  taskIds: z.array(notionId).default([]),\n});\nexport type Project = z.infer<typeof ProjectSchema>;\n\nexport const TaskSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  done: z.boolean(),\n  taskCode: z.string().optional(),\n  due: isoDate.nullable(),\n  priority: z.enum(['High', 'Medium', 'Low']).nullable(),\n  projectId: notionId.optional(),\n  teamId: notionId.optional(),\n});\nexport type Task = z.infer<typeof TaskSchema>;\n\nexport const MeetingSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  type: z.enum(['Standup', 'Sprint Planning', 'Post-mortem', 'Team Sync', 'Ad Hoc']),\n  cadence: z.enum(['Daily', 'Weekly', 'Biweekly', 'Monthly', 'Ad Hoc']).nullable(),\n  date: isoDate.nullable(),\n  attendeeTeamIds: z.array(notionId).default([]),\n  actionItemTaskIds: z.array(notionId).default([]),\n  projectIds: z.array(notionId).default([]),\n  teamIds: z.array(notionId).default([]),\n});\nexport type Meeting = z.infer<typeof MeetingSchema>;"
    },
    {
      "path": "./src/schemas/meeting.schema.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 30,
      "chars": 773,
      "approxTokens": 193.0,
      "sha256": "7493A0A40C218195BDE02B808866048BE8B748E339551615D5CA75E10B1C8498",
      "content": "import { z } from 'zod';\n\n/**\n * Notion ID schema (UUID format)\n */\nconst notionId = z.string();\n\n/**\n * ISO 8601 date string schema\n */\nconst isoDate = z.string();\n\n/**\n * Meeting schema\n *\n * Represents a meeting in the Digital Herencia workspace\n */\nexport const MeetingSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  type: z.enum(['Standup', 'Sprint Planning', 'Post-mortem', 'Team Sync', 'Ad Hoc']),\n  cadence: z.enum(['Daily', 'Weekly', 'Biweekly', 'Monthly', 'Ad Hoc']).nullable(),\n  date: isoDate.nullable(),\n  attendeeTeamIds: z.array(notionId).default([]),\n  actionItemTaskIds: z.array(notionId).default([]),\n  projectIds: z.array(notionId).default([]),\n  teamIds: z.array(notionId).default([]),\n});\n\nexport type Meeting = z.infer<typeof MeetingSchema>;"
    },
    {
      "path": "./src/schemas/project.schema.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 33,
      "chars": 828,
      "approxTokens": 207.0,
      "sha256": "48EC1F6C5E1D11CB7F3A05822FB888C3AA013A819F682C8446950465F67FF6FD",
      "content": "import { z } from 'zod';\n\n/**\n * Notion ID schema (UUID format)\n */\nconst notionId = z.string();\n\n/**\n * ISO 8601 date string schema\n */\nconst isoDate = z.string();\n\n/**\n * Project schema\n *\n * Represents a project in the Digital Herencia workspace\n */\nexport const ProjectSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  status: z.enum(['Active', 'Completed', 'On Hold', 'Cancelled']),\n  milestone: z.enum(['M1', 'M2', 'M3']).nullable(),\n  phase: z\n    .enum(['P1.1', 'P1.2', 'P1.3', 'P2.1', 'P2.2', 'P2.3', 'P3.1', 'P3.2', 'P3.3'])\n    .nullable(),\n  domain: z.enum(['OPS', 'PROD', 'DES', 'ENG', 'MKT', 'RES']).nullable(),\n  startDate: isoDate.nullable(),\n  endDate: isoDate.nullable(),\n  teamId: notionId.optional(),\n  taskIds: z.array(notionId).default([]),\n});\n\nexport type Project = z.infer<typeof ProjectSchema>;"
    },
    {
      "path": "./src/schemas/task.schema.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 29,
      "chars": 577,
      "approxTokens": 144.0,
      "sha256": "CC30FE12D16A961D5AFC651247977CE3B95107CCCAA7461A860D8CBC91278104",
      "content": "import { z } from 'zod';\n\n/**\n * Notion ID schema (UUID format)\n */\nconst notionId = z.string();\n\n/**\n * ISO 8601 date string schema\n */\nconst isoDate = z.string();\n\n/**\n * Task schema\n *\n * Represents a task in the Digital Herencia workspace\n */\nexport const TaskSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  done: z.boolean(),\n  taskCode: z.string().optional(),\n  due: isoDate.nullable(),\n  priority: z.enum(['High', 'Medium', 'Low']).nullable(),\n  projectId: notionId.optional(),\n  teamId: notionId.optional(),\n});\n\nexport type Task = z.infer<typeof TaskSchema>;"
    },
    {
      "path": "./src/schemas/team.schema.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 23,
      "chars": 513,
      "approxTokens": 128.0,
      "sha256": "3C10F7601CE1B4ACE2C9EBD3814F7C1DE3AB6733A428BD13BC5BED061BC79789",
      "content": "import { z } from 'zod';\n\n/**\n * Notion ID schema (UUID format)\n */\nconst notionId = z.string();\n\n/**\n * Team schema\n *\n * Represents a team in the Digital Herencia workspace\n */\nexport const TeamSchema = z.object({\n  id: notionId,\n  name: z.string(),\n  meetings: z.array(notionId).default([]),\n  projects: z.array(notionId).default([]),\n  projectsComplete: z.number().optional(),\n  tasks: z.array(notionId).default([]),\n  tasksCompleted: z.number().optional(),\n});\n\nexport type Team = z.infer<typeof TeamSchema>;"
    },
    {
      "path": "./src/schemas/__tests__/schemas.test.ts",
      "category": "schemas",
      "startLine": 1,
      "endLine": 115,
      "chars": 2906,
      "approxTokens": 726.0,
      "sha256": "88156F0D141C3D071F0A41811A7A70F3894CF48063562A4943FB20EB19271623",
      "content": "import { describe, it, expect } from 'vitest';\nimport { TeamSchema, ProjectSchema, TaskSchema, MeetingSchema } from '../index.js';\n\ndescribe('Schemas', () => {\n  describe('TeamSchema', () => {\n    it('should validate a valid team', () => {\n      const team = {\n        id: 'test-id',\n        name: 'Engineering Team',\n        meetings: [],\n        projects: [],\n        tasks: [],\n      };\n      expect(() => TeamSchema.parse(team)).not.toThrow();\n    });\n\n    it('should reject invalid team', () => {\n      const team = {\n        id: 'test-id',\n      };\n      expect(() => TeamSchema.parse(team)).toThrow();\n    });\n  });\n\n  describe('ProjectSchema', () => {\n    it('should validate a valid project', () => {\n      const project = {\n        id: 'test-id',\n        name: 'Test Project',\n        status: 'Active',\n        milestone: 'M1',\n        phase: 'P1.1',\n        domain: 'ENG',\n        startDate: '2024-01-01',\n        endDate: '2024-01-15',\n        taskIds: [],\n      };\n      expect(() => ProjectSchema.parse(project)).not.toThrow();\n    });\n\n    it('should allow nullable fields', () => {\n      const project = {\n        id: 'test-id',\n        name: 'Test Project',\n        status: 'Active',\n        milestone: null,\n        phase: null,\n        domain: null,\n        startDate: null,\n        endDate: null,\n        taskIds: [],\n      };\n      expect(() => ProjectSchema.parse(project)).not.toThrow();\n    });\n  });\n\n  describe('TaskSchema', () => {\n    it('should validate a valid task', () => {\n      const task = {\n        id: 'test-id',\n        name: 'Test Task',\n        done: false,\n        due: '2024-01-01',\n        priority: 'High',\n      };\n      expect(() => TaskSchema.parse(task)).not.toThrow();\n    });\n\n    it('should validate task with all fields', () => {\n      const task = {\n        id: 'test-id',\n        name: 'Test Task',\n        done: true,\n        taskCode: 'TASK-001',\n        due: null,\n        priority: null,\n        projectId: 'project-id',\n        teamId: 'team-id',\n      };\n      expect(() => TaskSchema.parse(task)).not.toThrow();\n    });\n  });\n\n  describe('MeetingSchema', () => {\n    it('should validate a valid meeting', () => {\n      const meeting = {\n        id: 'test-id',\n        name: 'Daily Standup',\n        type: 'Standup',\n        cadence: 'Daily',\n        date: '2024-01-01',\n        attendeeTeamIds: [],\n        actionItemTaskIds: [],\n        projectIds: [],\n        teamIds: [],\n      };\n      expect(() => MeetingSchema.parse(meeting)).not.toThrow();\n    });\n\n    it('should allow nullable fields', () => {\n      const meeting = {\n        id: 'test-id',\n        name: 'Ad Hoc Meeting',\n        type: 'Ad Hoc',\n        cadence: null,\n        date: null,\n        attendeeTeamIds: [],\n        actionItemTaskIds: [],\n        projectIds: [],\n        teamIds: [],\n      };\n      expect(() => MeetingSchema.parse(meeting)).not.toThrow();\n    });\n  });\n});"
    },
    {
      "path": "./src/workflows/analytics.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 241,
      "chars": 8196,
      "approxTokens": 2049.0,
      "sha256": "0D118449DAE9A1C4863633BFA1218EE3948CED1FFF629AB0C2D9192ADB74AB3E",
      "content": "import type { Project, Task } from '../schemas';\r\nimport type { ITeamRepository, IProjectRepository, ITaskRepository } from '../domain/repositories';\r\nimport type { ProjectStatus, Priority } from '../core/types';\r\n\r\n/**\r\n * Metrics for a specific team\r\n */\r\nexport interface TeamMetrics {\r\n  teamId: string;\r\n  teamName: string;\r\n  totalProjects: number;\r\n  activeProjects: number;\r\n  completedProjects: number;\r\n  projectsByStatus: Record<ProjectStatus, number>;\r\n  totalTasks: number;\r\n  completedTasks: number;\r\n  activeTasks: number;\r\n  completionRate: number;\r\n  overdueTasks: number;\r\n  tasksByPriority: Record<Priority, number>;\r\n  velocity: number; // Tasks completed per day\r\n}\r\n\r\n/**\r\n * Metrics for a specific project\r\n */\r\nexport interface ProjectMetrics {\r\n  projectId: string;\r\n  projectName: string;\r\n  status: ProjectStatus;\r\n  teamId?: string;\r\n  teamName?: string;\r\n  totalTasks: number;\r\n  completedTasks: number;\r\n  activeTasks: number;\r\n  completionRate: number;\r\n  overdueTasks: number;\r\n  tasksByPriority: Record<Priority, number>;\r\n  startDate: string | null;\r\n  endDate: string | null;\r\n  duration: number | null; // Days\r\n  daysRemaining: number | null;\r\n  onTrack: boolean;\r\n}\r\n\r\n/**\r\n * Overall analytics across all teams\r\n */\r\nexport interface OverallAnalytics {\r\n  totalTeams: number;\r\n  totalProjects: number;\r\n  totalTasks: number;\r\n  overallCompletionRate: number;\r\n  projectsByStatus: Record<ProjectStatus, number>;\r\n  tasksByPriority: Record<Priority, number>;\r\n  topPerformingTeams: Array<{ teamId: string; teamName: string; completionRate: number }>;\r\n  bottomPerformingTeams: Array<{ teamId: string; teamName: string; completionRate: number }>;\r\n  criticalProjects: ProjectMetrics[]; // Projects with issues\r\n}\r\n\r\n/**\r\n * Service for generating analytics and metrics\r\n * Provides insights into team performance, project progress, and task completion\r\n */\r\nexport class AnalyticsService {\r\n  constructor(\r\n    private readonly teams: ITeamRepository,\r\n    private readonly projects: IProjectRepository,\r\n    private readonly tasks: ITaskRepository\r\n  ) {}\r\n\r\n  /**\r\n   * Get comprehensive metrics for a specific team\r\n   *\r\n   * @param teamId Team ID to analyze\r\n   * @returns Team metrics\r\n   */\r\n  async getTeamMetrics(teamId: string): Promise<TeamMetrics> {\r\n    const allTeams = await this.teams.findMany();\r\n    const team = allTeams.find((t) => t.id === teamId);\r\n\r\n    if (!team) {\r\n      throw new Error(`Team ${teamId} not found`);\r\n    }\r\n\r\n    const projects = await this.projects.findByTeam(teamId);\r\n    const tasks = await this.tasks.findByTeam(teamId);\r\n\r\n    const completedTasks = tasks.filter((t) => t.done);\r\n    const activeTasks = tasks.filter((t) => !t.done);\r\n    const overdueTasks = this.countOverdueTasks(activeTasks);\r\n\r\n    const completionRate = tasks.length > 0 ? (completedTasks.length / tasks.length) * 100 : 0;\r\n\r\n    // Calculate velocity (tasks completed per day)\r\n    const velocity = this.calculateVelocity(completedTasks, projects);\r\n\r\n    return {\r\n      teamId: team.id,\r\n      teamName: team.name,\r\n      totalProjects: projects.length,\r\n      activeProjects: projects.filter((p) => p.status === 'Active').length,\r\n      completedProjects: projects.filter((p) => p.status === 'Completed').length,\r\n      projectsByStatus: this.groupByStatus(projects),\r\n      totalTasks: tasks.length,\r\n      completedTasks: completedTasks.length,\r\n      activeTasks: activeTasks.length,\r\n      completionRate: Math.round(completionRate * 10) / 10,\r\n      overdueTasks,\r\n      tasksByPriority: this.groupByPriority(tasks),\r\n      velocity: Math.round(velocity * 10) / 10,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive metrics for a specific project\r\n   *\r\n   * @param projectId Project ID to analyze\r\n   * @returns Project metrics\r\n   */\r\n  async getProjectMetrics(projectId: string): Promise<ProjectMetrics> {\r\n    const allProjects = await this.projects.findMany();\r\n    const project = allProjects.find((p) => p.id === projectId);\r\n\r\n    if (!project) {\r\n      throw new Error(`Project ${projectId} not found`);\r\n    }\r\n\r\n    // Get team name if available\r\n    let teamName: string | undefined;\r\n    if (project.teamId) {\r\n      const team = await this.teams.findById(project.teamId);\r\n      teamName = team?.name;\r\n    }\r\n\r\n    const tasks = await this.tasks.findByProject(projectId);\r\n    const completedTasks = tasks.filter((t) => t.done);\r\n    const activeTasks = tasks.filter((t) => !t.done);\r\n    const overdueTasks = this.countOverdueTasks(activeTasks);\r\n\r\n    const completionRate = tasks.length > 0 ? (completedTasks.length / tasks.length) * 100 : 0;\r\n\r\n    // Calculate duration and remaining time\r\n    let duration: number | null = null;\r\n    let daysRemaining: number | null = null;\r\n    let onTrack = true;\r\n\r\n    if (project.startDate && project.endDate) {\r\n      const start = new Date(project.startDate);\r\n      const end = new Date(project.endDate);\r\n      const now = new Date();\r\n\r\n      duration = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\r\n      daysRemaining = Math.ceil((end.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n      // Project is off-track if completion rate is significantly behind schedule\r\n      const elapsedDays = Math.ceil((now.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));\r\n      const expectedCompletionRate = duration > 0 ? (elapsedDays / duration) * 100 : 0;\r\n      onTrack = completionRate >= expectedCompletionRate - 10; // 10% tolerance\r\n    }\r\n\r\n    return {\r\n      projectId: project.id,\r\n      projectName: project.name,\r\n      status: project.status,\r\n      teamId: project.teamId,\r\n      teamName,\r\n      totalTasks: tasks.length,\r\n      completedTasks: completedTasks.length,\r\n      activeTasks: activeTasks.length,\r\n      completionRate: Math.round(completionRate * 10) / 10,\r\n      overdueTasks,\r\n      tasksByPriority: this.groupByPriority(tasks),\r\n      startDate: project.startDate,\r\n      endDate: project.endDate,\r\n      duration,\r\n      daysRemaining,\r\n      onTrack,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get overall analytics across all teams and projects\r\n   *\r\n   * @returns Overall analytics\r\n   */\r\n  async getOverallAnalytics(): Promise<OverallAnalytics> {\r\n    const allTeams = await this.teams.findMany();\r\n    const allProjects = await this.projects.findMany();\r\n    const allTasks = await this.tasks.findMany();\r\n\r\n    const completedTasks = allTasks.filter((t) => t.done);\r\n    const overallCompletionRate =\r\n      allTasks.length > 0 ? (completedTasks.length / allTasks.length) * 100 : 0;\r\n\r\n    // Calculate team performance\r\n    const teamMetrics = await Promise.all(allTeams.map((team) => this.getTeamMetrics(team.id)));\r\n\r\n    const sortedByCompletion = [...teamMetrics].sort((a, b) => b.completionRate - a.completionRate);\r\n    const topPerformingTeams = sortedByCompletion.slice(0, 3).map((m) => ({\r\n      teamId: m.teamId,\r\n      teamName: m.teamName,\r\n      completionRate: m.completionRate,\r\n    }));\r\n    const bottomPerformingTeams = sortedByCompletion\r\n      .slice(-3)\r\n      .reverse()\r\n      .map((m) => ({\r\n        teamId: m.teamId,\r\n        teamName: m.teamName,\r\n        completionRate: m.completionRate,\r\n      }));\r\n\r\n    // Identify critical projects (off-track or with many overdue tasks)\r\n    const projectMetrics = await Promise.all(\r\n      allProjects.map((project) => this.getProjectMetrics(project.id))\r\n    );\r\n    const criticalProjects = projectMetrics.filter(\r\n      (p) => !p.onTrack || p.overdueTasks > 3 || (p.status === 'Active' && p.completionRate < 30)\r\n    );\r\n\r\n    return {\r\n      totalTeams: allTeams.length,\r\n      totalProjects: allProjects.length,\r\n      totalTasks: allTasks.length,\r\n      overallCompletionRate: Math.round(overallCompletionRate * 10) / 10,\r\n      projectsByStatus: this.groupByStatus(allProjects),\r\n      tasksByPriority: this.groupByPriority(allTasks),\r\n      topPerformingTeams,\r\n      bottomPerformingTeams,\r\n      criticalProjects,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a formatted analytics report\r\n   *\r\n   * @param analytics Overall analytics\r\n   * @returns Markdown-formatted report\r\n   */\r\n  formatOverallReport(analytics: OverallAnalytics): string {"
    },
    {
      "path": "./src/workflows/analytics.ts",
      "category": "workflows",
      "startLine": 242,
      "endLine": 418,
      "chars": 5100,
      "approxTokens": 1275.0,
      "sha256": "1D61457810617C98281073EC897178200F5D7C48CABF1B616B1C8A941976C064",
      "content": "    const lines: string[] = [\r\n      `# Analytics Report`,\r\n      ``,\r\n      `## Overall Summary`,\r\n      ``,\r\n      `- **Teams**: ${analytics.totalTeams}`,\r\n      `- **Projects**: ${analytics.totalProjects}`,\r\n      `- **Tasks**: ${analytics.totalTasks}`,\r\n      `- **Overall Completion Rate**: ${analytics.overallCompletionRate}%`,\r\n      ``,\r\n      `### Projects by Status`,\r\n      ``,\r\n    ];\r\n\r\n    for (const [status, count] of Object.entries(analytics.projectsByStatus)) {\r\n      if (count > 0) {\r\n        lines.push(`- ${status}: ${count}`);\r\n      }\r\n    }\r\n\r\n    lines.push(``);\r\n    lines.push(`### Tasks by Priority`);\r\n    lines.push(``);\r\n\r\n    for (const [priority, count] of Object.entries(analytics.tasksByPriority)) {\r\n      if (count > 0) {\r\n        lines.push(`- ${priority}: ${count}`);\r\n      }\r\n    }\r\n\r\n    lines.push(``);\r\n    lines.push(`## Top Performing Teams`);\r\n    lines.push(``);\r\n\r\n    for (const team of analytics.topPerformingTeams) {\r\n      lines.push(`- **${team.teamName}**: ${team.completionRate}% completion`);\r\n    }\r\n\r\n    if (analytics.bottomPerformingTeams.length > 0) {\r\n      lines.push(``);\r\n      lines.push(`## Teams Needing Support`);\r\n      lines.push(``);\r\n\r\n      for (const team of analytics.bottomPerformingTeams) {\r\n        lines.push(`- **${team.teamName}**: ${team.completionRate}% completion`);\r\n      }\r\n    }\r\n\r\n    if (analytics.criticalProjects.length > 0) {\r\n      lines.push(``);\r\n      lines.push(`## ⚠️ Critical Projects`);\r\n      lines.push(``);\r\n\r\n      for (const project of analytics.criticalProjects) {\r\n        lines.push(`### ${project.projectName}`);\r\n        lines.push(`- Status: ${project.status}`);\r\n        lines.push(`- Completion: ${project.completionRate}%`);\r\n        lines.push(`- Overdue Tasks: ${project.overdueTasks}`);\r\n        if (project.daysRemaining !== null) {\r\n          lines.push(`- Days Remaining: ${project.daysRemaining}`);\r\n        }\r\n        lines.push(`- On Track: ${project.onTrack ? '✅' : '❌'}`);\r\n        lines.push(``);\r\n      }\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Generate a team performance report\r\n   *\r\n   * @param teamMetrics Team metrics\r\n   * @returns Markdown-formatted report\r\n   */\r\n  formatTeamReport(teamMetrics: TeamMetrics): string {\r\n    const lines: string[] = [\r\n      `# Team Report: ${teamMetrics.teamName}`,\r\n      ``,\r\n      `## Overview`,\r\n      ``,\r\n      `- **Projects**: ${teamMetrics.totalProjects} (${teamMetrics.activeProjects} active, ${teamMetrics.completedProjects} completed)`,\r\n      `- **Tasks**: ${teamMetrics.totalTasks} (${teamMetrics.completedTasks} completed, ${teamMetrics.activeTasks} active)`,\r\n      `- **Completion Rate**: ${teamMetrics.completionRate}%`,\r\n      `- **Overdue Tasks**: ${teamMetrics.overdueTasks}`,\r\n      `- **Velocity**: ${teamMetrics.velocity} tasks/day`,\r\n      ``,\r\n      `### Projects by Status`,\r\n      ``,\r\n    ];\r\n\r\n    for (const [status, count] of Object.entries(teamMetrics.projectsByStatus)) {\r\n      if (count > 0) {\r\n        lines.push(`- ${status}: ${count}`);\r\n      }\r\n    }\r\n\r\n    lines.push(``);\r\n    lines.push(`### Tasks by Priority`);\r\n    lines.push(``);\r\n\r\n    for (const [priority, count] of Object.entries(teamMetrics.tasksByPriority)) {\r\n      if (count > 0) {\r\n        lines.push(`- ${priority}: ${count}`);\r\n      }\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Count overdue tasks\r\n   */\r\n  private countOverdueTasks(tasks: Task[]): number {\r\n    const now = new Date();\r\n    return tasks.filter((task) => {\r\n      if (task.done || !task.due) return false;\r\n      return new Date(task.due) < now;\r\n    }).length;\r\n  }\r\n\r\n  /**\r\n   * Group projects by status\r\n   */\r\n  private groupByStatus(projects: Project[]): Record<ProjectStatus, number> {\r\n    const result: Record<ProjectStatus, number> = {\r\n      Active: 0,\r\n      Completed: 0,\r\n      'On Hold': 0,\r\n      Cancelled: 0,\r\n    };\r\n\r\n    for (const project of projects) {\r\n      result[project.status]++;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Group tasks by priority\r\n   */\r\n  private groupByPriority(tasks: Task[]): Record<Priority, number> {\r\n    const result: Record<Priority, number> = {\r\n      High: 0,\r\n      Medium: 0,\r\n      Low: 0,\r\n    };\r\n\r\n    for (const task of tasks) {\r\n      if (task.priority) {\r\n        result[task.priority]++;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate velocity (tasks completed per day)\r\n   * Based on completed tasks and project duration\r\n   */\r\n  private calculateVelocity(completedTasks: Task[], projects: Project[]): number {\r\n    if (completedTasks.length === 0 || projects.length === 0) return 0;\r\n\r\n    // Find earliest start date and latest end date\r\n    const dates = projects.filter((p) => p.startDate).map((p) => new Date(p.startDate!).getTime());\r\n\r\n    if (dates.length === 0) return 0;\r\n\r\n    const earliestStart = Math.min(...dates);\r\n    const now = Date.now();\r\n    const daysPassed = Math.ceil((now - earliestStart) / (1000 * 60 * 60 * 24));\r\n\r\n    return daysPassed > 0 ? completedTasks.length / daysPassed : 0;\r\n  }\r\n}"
    },
    {
      "path": "./src/workflows/daily-standup.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 270,
      "chars": 8371,
      "approxTokens": 2093.0,
      "sha256": "C13645A98B24EEA3913787C54C83C81E510256BA7592D5CB92678806BE0CDEA8",
      "content": "import type { Task, Team } from '../schemas';\r\nimport type { ITaskRepository, ITeamRepository } from '../domain/repositories';\r\n\r\n/**\r\n * Configuration for generating a daily standup report\r\n */\r\nexport interface StandupConfig {\r\n  teamIds?: string[]; // If empty, generate for all teams\r\n  date?: Date; // Date for the standup (default: today)\r\n  includeDone?: boolean; // Include completed tasks (default: false)\r\n}\r\n\r\n/**\r\n * Task summary for a team\r\n */\r\nexport interface TeamTaskSummary {\r\n  teamId: string;\r\n  teamName: string;\r\n  totalTasks: number;\r\n  completedTasks: number;\r\n  activeTasks: number;\r\n  overdueTasks: number;\r\n  highPriorityTasks: number;\r\n  completionRate: number;\r\n  tasks: TaskDetail[];\r\n}\r\n\r\n/**\r\n * Detailed task information\r\n */\r\nexport interface TaskDetail {\r\n  id: string;\r\n  name: string;\r\n  done: boolean;\r\n  priority: string | null;\r\n  due: string | null;\r\n  isOverdue: boolean;\r\n  projectId?: string;\r\n}\r\n\r\n/**\r\n * Complete standup report\r\n */\r\nexport interface StandupReport {\r\n  date: Date;\r\n  teams: TeamTaskSummary[];\r\n  overallSummary: {\r\n    totalTeams: number;\r\n    totalTasks: number;\r\n    completedTasks: number;\r\n    activeTasks: number;\r\n    overdueTasks: number;\r\n    averageCompletionRate: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Workflow for generating daily standup reports\r\n * Provides task summaries by team for daily coordination\r\n */\r\nexport class DailyStandupWorkflow {\r\n  constructor(\r\n    private readonly tasks: ITaskRepository,\r\n    private readonly teams: ITeamRepository\r\n  ) {}\r\n\r\n  /**\r\n   * Generate a daily standup report with task summaries by team\r\n   *\r\n   * @param config Standup configuration\r\n   * @returns Complete standup report\r\n   */\r\n  async generateStandupReport(config: StandupConfig = {}): Promise<StandupReport> {\r\n    const date = config.date || new Date();\r\n    const includeDone = config.includeDone || false;\r\n\r\n    // Get teams to report on\r\n    const allTeams = await this.teams.findMany();\r\n    const targetTeams = config.teamIds\r\n      ? allTeams.filter((team) => config.teamIds!.includes(team.id))\r\n      : allTeams;\r\n\r\n    // Generate team summaries\r\n    const teamSummaries = await Promise.all(\r\n      targetTeams.map((team) => this.generateTeamSummary(team, date, includeDone))\r\n    );\r\n\r\n    // Calculate overall summary\r\n    const overallSummary = this.calculateOverallSummary(teamSummaries);\r\n\r\n    return {\r\n      date,\r\n      teams: teamSummaries,\r\n      overallSummary,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate task summary for a specific team\r\n   *\r\n   * @param team Team to summarize\r\n   * @param date Reference date for the standup\r\n   * @param includeDone Include completed tasks\r\n   * @returns Team task summary\r\n   */\r\n  private async generateTeamSummary(\r\n    team: Team,\r\n    date: Date,\r\n    includeDone: boolean\r\n  ): Promise<TeamTaskSummary> {\r\n    // Get all tasks for this team\r\n    const allTasks = await this.tasks.findByTeam(team.id);\r\n\r\n    // Filter tasks based on configuration\r\n    const tasks = includeDone ? allTasks : allTasks.filter((task) => !task.done);\r\n\r\n    // Convert to detailed format with overdue calculation\r\n    const taskDetails = tasks.map((task) => this.createTaskDetail(task, date));\r\n\r\n    // Calculate metrics\r\n    const completedTasks = allTasks.filter((t) => t.done).length;\r\n    const activeTasks = allTasks.filter((t) => !t.done).length;\r\n    const overdueTasks = taskDetails.filter((t) => t.isOverdue).length;\r\n    const highPriorityTasks = taskDetails.filter((t) => t.priority === 'High').length;\r\n    const completionRate = allTasks.length > 0 ? (completedTasks / allTasks.length) * 100 : 0;\r\n\r\n    return {\r\n      teamId: team.id,\r\n      teamName: team.name,\r\n      totalTasks: allTasks.length,\r\n      completedTasks,\r\n      activeTasks,\r\n      overdueTasks,\r\n      highPriorityTasks,\r\n      completionRate: Math.round(completionRate * 10) / 10, // Round to 1 decimal\r\n      tasks: taskDetails,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create detailed task information with overdue status\r\n   *\r\n   * @param task Task to detail\r\n   * @param referenceDate Date to check if task is overdue\r\n   * @returns Task detail\r\n   */\r\n  private createTaskDetail(task: Task, referenceDate: Date): TaskDetail {\r\n    let isOverdue = false;\r\n    if (!task.done && task.due) {\r\n      const dueDate = new Date(task.due);\r\n      isOverdue = dueDate < referenceDate;\r\n    }\r\n\r\n    return {\r\n      id: task.id,\r\n      name: task.name,\r\n      done: task.done,\r\n      priority: task.priority,\r\n      due: task.due,\r\n      isOverdue,\r\n      projectId: task.projectId,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate overall summary across all teams\r\n   *\r\n   * @param teamSummaries Array of team summaries\r\n   * @returns Overall summary\r\n   */\r\n  private calculateOverallSummary(teamSummaries: TeamTaskSummary[]) {\r\n    const totalTasks = teamSummaries.reduce((sum, team) => sum + team.totalTasks, 0);\r\n    const completedTasks = teamSummaries.reduce((sum, team) => sum + team.completedTasks, 0);\r\n    const activeTasks = teamSummaries.reduce((sum, team) => sum + team.activeTasks, 0);\r\n    const overdueTasks = teamSummaries.reduce((sum, team) => sum + team.overdueTasks, 0);\r\n\r\n    const averageCompletionRate =\r\n      teamSummaries.length > 0\r\n        ? teamSummaries.reduce((sum, team) => sum + team.completionRate, 0) / teamSummaries.length\r\n        : 0;\r\n\r\n    return {\r\n      totalTeams: teamSummaries.length,\r\n      totalTasks,\r\n      completedTasks,\r\n      activeTasks,\r\n      overdueTasks,\r\n      averageCompletionRate: Math.round(averageCompletionRate * 10) / 10,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Format standup report as markdown\r\n   *\r\n   * @param report Standup report to format\r\n   * @returns Markdown-formatted report\r\n   */\r\n  formatReport(report: StandupReport): string {\r\n    const lines: string[] = [\r\n      `# Daily Standup Report`,\r\n      ``,\r\n      `**Date**: ${report.date.toLocaleDateString()}`,\r\n      ``,\r\n      `## Overall Summary`,\r\n      ``,\r\n      `- **Teams**: ${report.overallSummary.totalTeams}`,\r\n      `- **Total Tasks**: ${report.overallSummary.totalTasks}`,\r\n      `- **Completed**: ${report.overallSummary.completedTasks}`,\r\n      `- **Active**: ${report.overallSummary.activeTasks}`,\r\n      `- **Overdue**: ${report.overallSummary.overdueTasks} ⚠️`,\r\n      `- **Average Completion Rate**: ${report.overallSummary.averageCompletionRate}%`,\r\n      ``,\r\n    ];\r\n\r\n    // Add team summaries\r\n    for (const team of report.teams) {\r\n      lines.push(`## ${team.teamName}`);\r\n      lines.push(``);\r\n      lines.push(`**Metrics**:`);\r\n      lines.push(`- Total: ${team.totalTasks}`);\r\n      lines.push(`- Completed: ${team.completedTasks}`);\r\n      lines.push(`- Active: ${team.activeTasks}`);\r\n      lines.push(`- Overdue: ${team.overdueTasks}${team.overdueTasks > 0 ? ' ⚠️' : ''}`);\r\n      lines.push(`- High Priority: ${team.highPriorityTasks}`);\r\n      lines.push(`- Completion Rate: ${team.completionRate}%`);\r\n      lines.push(``);\r\n\r\n      if (team.tasks.length > 0) {\r\n        lines.push(`**Tasks**:`);\r\n        lines.push(``);\r\n\r\n        // Group tasks by status\r\n        const activeTasks = team.tasks.filter((t) => !t.done);\r\n        const completedTasks = team.tasks.filter((t) => t.done);\r\n\r\n        if (activeTasks.length > 0) {\r\n          lines.push(`*Active Tasks:*`);\r\n          for (const task of activeTasks) {\r\n            const priorityBadge = task.priority ? ` [${task.priority}]` : '';\r\n            const overdueBadge = task.isOverdue ? ' ⚠️ OVERDUE' : '';\r\n            const dueDateStr = task.due ? ` - Due: ${new Date(task.due).toLocaleDateString()}` : '';\r\n            lines.push(`- [ ] ${task.name}${priorityBadge}${dueDateStr}${overdueBadge}`);\r\n          }\r\n          lines.push(``);\r\n        }\r\n\r\n        if (completedTasks.length > 0) {\r\n          lines.push(`*Completed Tasks:*`);\r\n          for (const task of completedTasks) {\r\n            lines.push(`- [x] ${task.name}`);\r\n          }\r\n          lines.push(``);\r\n        }\r\n      }\r\n\r\n      lines.push(`---`);\r\n      lines.push(``);\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Generate a quick summary for a specific team\r\n   *\r\n   * @param teamId Team ID to summarize\r\n   * @param date Reference date (default: today)\r\n   * @returns Formatted team summary\r\n   */\r\n  async generateTeamQuickSummary(teamId: string, date: Date = new Date()): Promise<string> {"
    },
    {
      "path": "./src/workflows/daily-standup.ts",
      "category": "workflows",
      "startLine": 271,
      "endLine": 293,
      "chars": 693,
      "approxTokens": 173.0,
      "sha256": "001C7842B68538214B50791FB3EBD3B281CE9621B2029AB3AFB66295FBFED41D",
      "content": "    const allTeams = await this.teams.findMany();\r\n    const team = allTeams.find((t) => t.id === teamId);\r\n\r\n    if (!team) {\r\n      throw new Error(`Team ${teamId} not found`);\r\n    }\r\n\r\n    const summary = await this.generateTeamSummary(team, date, false);\r\n\r\n    const lines: string[] = [\r\n      `**${summary.teamName}** - Quick Summary`,\r\n      ``,\r\n      `📊 ${summary.activeTasks} active • ✅ ${summary.completedTasks} done • ⚠️ ${summary.overdueTasks} overdue`,\r\n      `📈 Completion: ${summary.completionRate}%`,\r\n    ];\r\n\r\n    if (summary.highPriorityTasks > 0) {\r\n      lines.push(`🔥 ${summary.highPriorityTasks} high priority tasks`);\r\n    }\r\n\r\n    return lines.join('\\n');\r\n  }\r\n}"
    },
    {
      "path": "./src/workflows/index.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 3,
      "chars": 93,
      "approxTokens": 23.0,
      "sha256": "DC1715B3F53F1DD7E368A5A2E7CE3CE9165518F0E32460636EA0A18D5FCC6669",
      "content": "export * from './sprint-cycle';\nexport * from './daily-standup';\nexport * from './analytics';"
    },
    {
      "path": "./src/workflows/sprint-cycle.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 301,
      "chars": 8721,
      "approxTokens": 2180.0,
      "sha256": "0E45CBE53D0DD80314E0D369E2A5BB2E750B4D3DF022196355F00D534BA72E40",
      "content": "import type { ChangeProposal } from '../safety';\r\nimport type { Project, Task, Meeting } from '../schemas';\r\nimport type { Milestone, Phase, Domain } from '../core/types';\r\nimport type {\r\n  IProjectRepository,\r\n  ITaskRepository,\r\n  IMeetingRepository,\r\n  TaskCreateInput,\r\n} from '../domain/repositories';\r\n\r\n/**\r\n * Configuration for planning a sprint\r\n */\r\nexport interface SprintConfig {\r\n  teamId: string;\r\n  name: string;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  milestone: Milestone;\r\n  phase: Phase;\r\n  domain: Domain;\r\n  tasks: TaskCreateInput[];\r\n}\r\n\r\n/**\r\n * Aggregate proposal for a complete sprint\r\n */\r\nexport interface SprintProposal {\r\n  project: ChangeProposal<Project>;\r\n  tasks: ChangeProposal<Task>[];\r\n  meetings: ChangeProposal<Meeting>[];\r\n  summary: SprintSummary;\r\n}\r\n\r\n/**\r\n * Summary of a sprint configuration\r\n */\r\nexport interface SprintSummary {\r\n  projectName: string;\r\n  teamId: string;\r\n  duration: string;\r\n  taskCount: number;\r\n  meetingCount: number;\r\n  milestone: Milestone;\r\n  phase: Phase;\r\n}\r\n\r\n/**\r\n * Result of executing a sprint\r\n */\r\nexport interface SprintResult {\r\n  success: boolean;\r\n  projectId?: string;\r\n  taskIds: string[];\r\n  meetingIds: string[];\r\n  errors: Error[];\r\n  summary: string;\r\n}\r\n\r\n/**\r\n * Workflow orchestration for sprint cycle management\r\n * Implements the 2-week sprint planning process for Digital Herencia\r\n */\r\nexport class SprintCycleWorkflow {\r\n  constructor(\r\n    private readonly projects: IProjectRepository,\r\n    private readonly tasks: ITaskRepository,\r\n    private readonly meetings: IMeetingRepository\r\n  ) {}\r\n\r\n  /**\r\n   * Plan a new sprint with all required artifacts\r\n   * Returns proposals for review before execution (Propose step)\r\n   *\r\n   * @param config Sprint configuration\r\n   * @returns Aggregate proposal containing project, tasks, and meetings\r\n   */\r\n  async planSprint(config: SprintConfig): Promise<SprintProposal> {\r\n    // Validate configuration\r\n    this.validateSprintConfig(config);\r\n\r\n    // 1. Create project proposal\r\n    const projectProposal = await this.projects.create({\r\n      name: config.name,\r\n      status: 'Active',\r\n      milestone: config.milestone,\r\n      phase: config.phase,\r\n      domain: config.domain,\r\n      startDate: config.startDate.toISOString(),\r\n      endDate: config.endDate.toISOString(),\r\n      teamId: config.teamId,\r\n    });\r\n\r\n    // 2. Create task proposals linked to project\r\n    const taskProposals = await Promise.all(\r\n      config.tasks.map((taskInput) =>\r\n        this.tasks.create({\r\n          ...taskInput,\r\n          projectId: projectProposal.proposedState.id,\r\n          teamId: config.teamId,\r\n        })\r\n      )\r\n    );\r\n\r\n    // 3. Create meeting proposals for sprint cycle\r\n    const meetingProposals = await this.createSprintMeetings(\r\n      config,\r\n      projectProposal.proposedState.id\r\n    );\r\n\r\n    // 4. Generate summary\r\n    const summary = this.generateSprintSummary(\r\n      config,\r\n      taskProposals.length,\r\n      meetingProposals.length\r\n    );\r\n\r\n    return {\r\n      project: projectProposal,\r\n      tasks: taskProposals,\r\n      meetings: meetingProposals,\r\n      summary,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create standard meetings for a sprint\r\n   * - Sprint Planning meeting (start)\r\n   * - Daily Standup template\r\n   * - Post-mortem/Retrospective (end)\r\n   *\r\n   * @param config Sprint configuration\r\n   * @param projectId Project ID to link meetings to\r\n   * @returns Array of meeting proposals\r\n   */\r\n  private async createSprintMeetings(\r\n    config: SprintConfig,\r\n    projectId: string\r\n  ): Promise<ChangeProposal<Meeting>[]> {\r\n    const meetings: ChangeProposal<Meeting>[] = [];\r\n\r\n    // Sprint Planning meeting\r\n    const planningMeeting = await this.meetings.create({\r\n      name: `Sprint Planning - ${config.name}`,\r\n      type: 'Sprint Planning',\r\n      cadence: 'Biweekly',\r\n      date: config.startDate.toISOString(),\r\n      teamIds: [config.teamId],\r\n      projectIds: [projectId],\r\n    });\r\n    meetings.push(planningMeeting);\r\n\r\n    // Daily Standup (recurring template)\r\n    const standupMeeting = await this.meetings.create({\r\n      name: `Daily Standup - ${config.name}`,\r\n      type: 'Standup',\r\n      cadence: 'Daily',\r\n      date: config.startDate.toISOString(),\r\n      teamIds: [config.teamId],\r\n      projectIds: [projectId],\r\n    });\r\n    meetings.push(standupMeeting);\r\n\r\n    // Post-mortem / Retrospective meeting\r\n    const postMortemMeeting = await this.meetings.create({\r\n      name: `Post-mortem - ${config.name}`,\r\n      type: 'Post-mortem',\r\n      cadence: 'Biweekly',\r\n      date: config.endDate.toISOString(),\r\n      teamIds: [config.teamId],\r\n      projectIds: [projectId],\r\n    });\r\n    meetings.push(postMortemMeeting);\r\n\r\n    return meetings;\r\n  }\r\n\r\n  /**\r\n   * Generate a human-readable summary of the sprint\r\n   *\r\n   * @param config Sprint configuration\r\n   * @param taskCount Number of tasks\r\n   * @param meetingCount Number of meetings\r\n   * @returns Sprint summary\r\n   */\r\n  private generateSprintSummary(\r\n    config: SprintConfig,\r\n    taskCount: number,\r\n    meetingCount: number\r\n  ): SprintSummary {\r\n    const durationMs = config.endDate.getTime() - config.startDate.getTime();\r\n    const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));\r\n\r\n    return {\r\n      projectName: config.name,\r\n      teamId: config.teamId,\r\n      duration: `${durationDays} days`,\r\n      taskCount,\r\n      meetingCount,\r\n      milestone: config.milestone,\r\n      phase: config.phase,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate sprint configuration\r\n   *\r\n   * @param config Sprint configuration to validate\r\n   * @throws Error if configuration is invalid\r\n   */\r\n  private validateSprintConfig(config: SprintConfig): void {\r\n    if (!config.name || config.name.trim().length === 0) {\r\n      throw new Error('Sprint name is required');\r\n    }\r\n\r\n    if (!config.teamId || config.teamId.trim().length === 0) {\r\n      throw new Error('Team ID is required');\r\n    }\r\n\r\n    if (config.startDate >= config.endDate) {\r\n      throw new Error('Sprint end date must be after start date');\r\n    }\r\n\r\n    const durationMs = config.endDate.getTime() - config.startDate.getTime();\r\n    const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));\r\n\r\n    // Warn if sprint is not ~2 weeks (10-16 days)\r\n    if (durationDays < 10 || durationDays > 16) {\r\n      console.warn(`Sprint duration is ${durationDays} days. Recommended: 10-16 days (2 weeks)`);\r\n    }\r\n\r\n    if (!config.tasks || config.tasks.length === 0) {\r\n      throw new Error('Sprint must have at least one task');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format sprint proposal for review\r\n   *\r\n   * @param proposal Sprint proposal to format\r\n   * @returns Markdown-formatted review text\r\n   */\r\n  formatForReview(proposal: SprintProposal): string {\r\n    const lines: string[] = [\r\n      `# Sprint Planning Proposal`,\r\n      ``,\r\n      `## Summary`,\r\n      ``,\r\n      `- **Project**: ${proposal.summary.projectName}`,\r\n      `- **Team**: ${proposal.summary.teamId}`,\r\n      `- **Duration**: ${proposal.summary.duration}`,\r\n      `- **Milestone**: ${proposal.summary.milestone}`,\r\n      `- **Phase**: ${proposal.summary.phase}`,\r\n      `- **Tasks**: ${proposal.summary.taskCount}`,\r\n      `- **Meetings**: ${proposal.summary.meetingCount}`,\r\n      ``,\r\n      `## Project`,\r\n      ``,\r\n      `- **ID**: ${proposal.project.id}`,\r\n      `- **Name**: ${proposal.project.proposedState.name}`,\r\n      `- **Status**: ${proposal.project.proposedState.status}`,\r\n      `- **Start**: ${proposal.project.proposedState.startDate}`,\r\n      `- **End**: ${proposal.project.proposedState.endDate}`,\r\n      ``,\r\n      `## Tasks (${proposal.tasks.length})`,\r\n      ``,\r\n    ];\r\n\r\n    for (let i = 0; i < proposal.tasks.length; i++) {\r\n      const task = proposal.tasks[i];\r\n      if (task) {\r\n        lines.push(`${i + 1}. **${task.proposedState.name}**`);\r\n        if (task.proposedState.priority) {\r\n          lines.push(`   - Priority: ${task.proposedState.priority}`);\r\n        }\r\n        if (task.proposedState.due) {\r\n          lines.push(`   - Due: ${task.proposedState.due}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    lines.push(``);\r\n    lines.push(`## Meetings (${proposal.meetings.length})`);\r\n    lines.push(``);\r\n\r\n    for (const meeting of proposal.meetings) {\r\n      lines.push(`- **${meeting.proposedState.name}**`);\r\n      lines.push(`  - Type: ${meeting.proposedState.type}`);\r\n      lines.push(`  - Date: ${meeting.proposedState.date}`);\r\n    }\r\n\r\n    lines.push(``);\r\n    lines.push(`---`);\r\n    lines.push(``);\r\n    lines.push(\r\n      `**Note**: All changes are proposals only. Use \\`executeSprint()\\` after approval to apply.`\r\n    );\r\n\r\n    return lines.join('\\n');\r\n  }\r\n}"
    },
    {
      "path": "./src/workflows/__tests__/analytics.test.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 202,
      "chars": 7069,
      "approxTokens": 1767.0,
      "sha256": "9D56D7324B5AB27252ED0ADDE05E3B9E7311EA891414BF67BACE8D3879E4CBD4",
      "content": "import { describe, it, expect, vi } from 'vitest';\nimport { AnalyticsService } from '../analytics';\nimport type {\n  ITeamRepository,\n  IProjectRepository,\n  ITaskRepository,\n} from '../../domain/repositories';\nimport type { Team, Project, Task } from '../../schemas';\n\ndescribe('AnalyticsService', () => {\n  const mockTeamRepo: ITeamRepository = {\n    findById: vi.fn(),\n    findMany: vi.fn(),\n  };\n\n  const mockProjectRepo: IProjectRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  const mockTaskRepo: ITaskRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findByProject: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  const mockTeam: Team = {\n    id: 'team-1',\n    name: 'Engineering Team',\n    meetings: [],\n    projects: ['project-1'],\n    tasks: ['task-1', 'task-2'],\n  };\n\n  const mockProject: Project = {\n    id: 'project-1',\n    name: 'Test Project',\n    status: 'Active',\n    milestone: 'M1',\n    phase: 'P1.1',\n    domain: 'ENG',\n    startDate: new Date(Date.now() - 7 * 86400000).toISOString(), // 7 days ago\n    endDate: new Date(Date.now() + 7 * 86400000).toISOString(), // 7 days from now\n    teamId: 'team-1',\n    taskIds: ['task-1', 'task-2'],\n  };\n\n  const mockTasks: Task[] = [\n    {\n      id: 'task-1',\n      name: 'Task 1',\n      done: true,\n      priority: 'High',\n      due: null,\n      teamId: 'team-1',\n      projectId: 'project-1',\n    },\n    {\n      id: 'task-2',\n      name: 'Task 2',\n      done: false,\n      priority: 'Medium',\n      due: new Date(Date.now() + 86400000).toISOString(),\n      teamId: 'team-1',\n      projectId: 'project-1',\n    },\n  ];\n\n  it('should get team metrics', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue([mockTeam]);\n    vi.mocked(mockProjectRepo.findByTeam).mockResolvedValue([mockProject]);\n    vi.mocked(mockTaskRepo.findByTeam).mockResolvedValue(mockTasks);\n\n    const metrics = await service.getTeamMetrics('team-1');\n\n    expect(metrics.teamId).toBe('team-1');\n    expect(metrics.teamName).toBe('Engineering Team');\n    expect(metrics.totalProjects).toBe(1);\n    expect(metrics.activeProjects).toBe(1);\n    expect(metrics.totalTasks).toBe(2);\n    expect(metrics.completedTasks).toBe(1);\n    expect(metrics.activeTasks).toBe(1);\n    expect(metrics.completionRate).toBe(50);\n  });\n\n  it('should get project metrics', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockProjectRepo.findMany).mockResolvedValue([mockProject]);\n    vi.mocked(mockTeamRepo.findById).mockResolvedValue(mockTeam);\n    vi.mocked(mockTaskRepo.findByProject).mockResolvedValue(mockTasks);\n\n    const metrics = await service.getProjectMetrics('project-1');\n\n    expect(metrics.projectId).toBe('project-1');\n    expect(metrics.projectName).toBe('Test Project');\n    expect(metrics.status).toBe('Active');\n    expect(metrics.totalTasks).toBe(2);\n    expect(metrics.completedTasks).toBe(1);\n    expect(metrics.completionRate).toBe(50);\n    expect(metrics.onTrack).toBeDefined();\n  });\n\n  it('should identify overdue tasks in project metrics', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    const tasksWithOverdue: Task[] = [\n      ...mockTasks,\n      {\n        id: 'task-3',\n        name: 'Overdue Task',\n        done: false,\n        priority: 'High',\n        due: new Date(Date.now() - 86400000).toISOString(), // Yesterday\n        teamId: 'team-1',\n        projectId: 'project-1',\n      },\n    ];\n\n    vi.mocked(mockProjectRepo.findMany).mockResolvedValue([mockProject]);\n    vi.mocked(mockTeamRepo.findById).mockResolvedValue(mockTeam);\n    vi.mocked(mockTaskRepo.findByProject).mockResolvedValue(tasksWithOverdue);\n\n    const metrics = await service.getProjectMetrics('project-1');\n\n    expect(metrics.overdueTasks).toBe(1);\n  });\n\n  it('should calculate overall analytics', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue([mockTeam]);\n    vi.mocked(mockProjectRepo.findMany).mockResolvedValue([mockProject]);\n    vi.mocked(mockProjectRepo.findByTeam).mockResolvedValue([mockProject]);\n    vi.mocked(mockTaskRepo.findMany).mockResolvedValue(mockTasks);\n    vi.mocked(mockTaskRepo.findByTeam).mockResolvedValue(mockTasks);\n    vi.mocked(mockTaskRepo.findByProject).mockResolvedValue(mockTasks);\n    vi.mocked(mockTeamRepo.findById).mockResolvedValue(mockTeam);\n\n    const analytics = await service.getOverallAnalytics();\n\n    expect(analytics.totalTeams).toBe(1);\n    expect(analytics.totalProjects).toBe(1);\n    expect(analytics.totalTasks).toBe(2);\n    expect(analytics.overallCompletionRate).toBe(50);\n  });\n\n  it('should format overall report', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue([mockTeam]);\n    vi.mocked(mockProjectRepo.findMany).mockResolvedValue([mockProject]);\n    vi.mocked(mockProjectRepo.findByTeam).mockResolvedValue([mockProject]);\n    vi.mocked(mockTaskRepo.findMany).mockResolvedValue(mockTasks);\n    vi.mocked(mockTaskRepo.findByTeam).mockResolvedValue(mockTasks);\n    vi.mocked(mockTaskRepo.findByProject).mockResolvedValue(mockTasks);\n    vi.mocked(mockTeamRepo.findById).mockResolvedValue(mockTeam);\n\n    const analytics = await service.getOverallAnalytics();\n    const formatted = service.formatOverallReport(analytics);\n\n    expect(formatted).toContain('Analytics Report');\n    expect(formatted).toContain('Overall Summary');\n    expect(formatted).toContain('**Teams**: 1');\n    expect(formatted).toContain('**Projects**: 1');\n  });\n\n  it('should format team report', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue([mockTeam]);\n    vi.mocked(mockProjectRepo.findByTeam).mockResolvedValue([mockProject]);\n    vi.mocked(mockTaskRepo.findByTeam).mockResolvedValue(mockTasks);\n\n    const metrics = await service.getTeamMetrics('team-1');\n    const formatted = service.formatTeamReport(metrics);\n\n    expect(formatted).toContain('Team Report: Engineering Team');\n    expect(formatted).toContain('Overview');\n    expect(formatted).toContain('Completion Rate');\n  });\n\n  it('should group tasks by priority', async () => {\n    const service = new AnalyticsService(mockTeamRepo, mockProjectRepo, mockTaskRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue([mockTeam]);\n    vi.mocked(mockProjectRepo.findByTeam).mockResolvedValue([mockProject]);\n    vi.mocked(mockTaskRepo.findByTeam).mockResolvedValue(mockTasks);\n\n    const metrics = await service.getTeamMetrics('team-1');\n\n    expect(metrics.tasksByPriority.High).toBe(1);\n    expect(metrics.tasksByPriority.Medium).toBe(1);\n    expect(metrics.tasksByPriority.Low).toBe(0);\n  });\n});"
    },
    {
      "path": "./src/workflows/__tests__/daily-standup.test.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 161,
      "chars": 5351,
      "approxTokens": 1338.0,
      "sha256": "4E2F5283FE991FF43BB7708A1B49967DFCE73F989B3FC75856704498B62FDF7E",
      "content": "import { describe, it, expect, vi } from 'vitest';\nimport { DailyStandupWorkflow } from '../daily-standup';\nimport type { ITaskRepository, ITeamRepository } from '../../domain/repositories';\nimport type { Team, Task } from '../../schemas';\n\ndescribe('DailyStandupWorkflow', () => {\n  const mockTaskRepo: ITaskRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findByProject: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  const mockTeamRepo: ITeamRepository = {\n    findById: vi.fn(),\n    findMany: vi.fn(),\n  };\n\n  const mockTeams: Team[] = [\n    {\n      id: 'team-1',\n      name: 'Engineering Team',\n      meetings: [],\n      projects: [],\n      tasks: [],\n    },\n    {\n      id: 'team-2',\n      name: 'Design Team',\n      meetings: [],\n      projects: [],\n      tasks: [],\n    },\n  ];\n\n  const mockTasks: Task[] = [\n    {\n      id: 'task-1',\n      name: 'Task 1',\n      done: false,\n      priority: 'High',\n      due: new Date(Date.now() - 86400000).toISOString(), // Yesterday (overdue)\n      teamId: 'team-1',\n    },\n    {\n      id: 'task-2',\n      name: 'Task 2',\n      done: true,\n      priority: 'Medium',\n      due: null,\n      teamId: 'team-1',\n    },\n    {\n      id: 'task-3',\n      name: 'Task 3',\n      done: false,\n      priority: 'Low',\n      due: new Date(Date.now() + 86400000).toISOString(), // Tomorrow\n      teamId: 'team-2',\n    },\n  ];\n\n  it('should generate standup report for all teams', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const report = await workflow.generateStandupReport();\n\n    expect(report.teams).toHaveLength(2);\n    expect(report.overallSummary.totalTeams).toBe(2);\n    expect(report.overallSummary.totalTasks).toBe(3);\n  });\n\n  it('should calculate team metrics correctly', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const report = await workflow.generateStandupReport();\n    const team1Summary = report.teams.find((t) => t.teamId === 'team-1');\n\n    expect(team1Summary).toBeDefined();\n    expect(team1Summary!.totalTasks).toBe(2);\n    expect(team1Summary!.completedTasks).toBe(1);\n    expect(team1Summary!.activeTasks).toBe(1);\n    expect(team1Summary!.overdueTasks).toBe(1);\n    expect(team1Summary!.highPriorityTasks).toBe(1);\n  });\n\n  it('should identify overdue tasks correctly', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const report = await workflow.generateStandupReport();\n    const team1Summary = report.teams.find((t) => t.teamId === 'team-1');\n\n    const overdueTask = team1Summary!.tasks.find((t) => t.isOverdue);\n    expect(overdueTask).toBeDefined();\n    expect(overdueTask!.done).toBe(false);\n  });\n\n  it('should format standup report', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const report = await workflow.generateStandupReport();\n    const formatted = workflow.formatReport(report);\n\n    expect(formatted).toContain('Daily Standup Report');\n    expect(formatted).toContain('Engineering Team');\n    expect(formatted).toContain('Design Team');\n    expect(formatted).toContain('OVERDUE');\n  });\n\n  it('should generate team quick summary', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const summary = await workflow.generateTeamQuickSummary('team-1');\n\n    expect(summary).toContain('Engineering Team');\n    expect(summary).toContain('active');\n    expect(summary).toContain('done');\n  });\n\n  it('should filter out completed tasks when includeDone is false', async () => {\n    const workflow = new DailyStandupWorkflow(mockTaskRepo, mockTeamRepo);\n\n    vi.mocked(mockTeamRepo.findMany).mockResolvedValue(mockTeams);\n    vi.mocked(mockTaskRepo.findByTeam).mockImplementation(async (teamId: string) => {\n      return mockTasks.filter((t) => t.teamId === teamId);\n    });\n\n    const report = await workflow.generateStandupReport({ includeDone: false });\n    const team1Summary = report.teams.find((t) => t.teamId === 'team-1');\n\n    // Should only include the active task, not the completed one\n    expect(team1Summary!.tasks.length).toBe(1);\n    expect(team1Summary!.tasks[0].done).toBe(false);\n  });\n});"
    },
    {
      "path": "./src/workflows/__tests__/sprint-cycle.test.ts",
      "category": "workflows",
      "startLine": 1,
      "endLine": 211,
      "chars": 5954,
      "approxTokens": 1488.0,
      "sha256": "DB2CC5406F92D7E3B13501F17B33FB5D0E96635217FFEC5D705D1A0C1DD466E7",
      "content": "import { describe, it, expect, vi } from 'vitest';\nimport { SprintCycleWorkflow } from '../sprint-cycle';\nimport type {\n  IProjectRepository,\n  ITaskRepository,\n  IMeetingRepository,\n} from '../../domain/repositories';\nimport type { ChangeProposal } from '../../safety';\nimport type { Project, Task, Meeting } from '../../schemas';\n\ndescribe('SprintCycleWorkflow', () => {\n  // Mock repositories\n  const mockProjectRepo: IProjectRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  const mockTaskRepo: ITaskRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findByProject: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  const mockMeetingRepo: IMeetingRepository = {\n    findById: vi.fn(),\n    findByTeam: vi.fn(),\n    findMany: vi.fn(),\n    create: vi.fn(),\n  };\n\n  it('should create a sprint proposal with project, tasks, and meetings', async () => {\n    const workflow = new SprintCycleWorkflow(mockProjectRepo, mockTaskRepo, mockMeetingRepo);\n\n    // Mock the create methods to return proposals\n    const mockProjectProposal: ChangeProposal<Project> = {\n      id: 'proposal-1',\n      type: 'create',\n      target: { database: '2d5a4e63-bf23-81b1-b507-f5ac308958e6' },\n      currentState: null,\n      proposedState: {\n        id: 'project-1',\n        name: 'Test Sprint',\n        status: 'Active',\n        milestone: 'M1',\n        phase: 'P1.1',\n        domain: 'ENG',\n        startDate: '2026-01-06T00:00:00.000Z',\n        endDate: '2026-01-20T00:00:00.000Z',\n        teamId: 'team-1',\n        taskIds: [],\n      },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    vi.mocked(mockProjectRepo.create).mockResolvedValue(mockProjectProposal);\n\n    const mockTaskProposal: ChangeProposal<Task> = {\n      id: 'task-proposal-1',\n      type: 'create',\n      target: { database: '2d5a4e63-bf23-816f-a217-ef754ce4a70e' },\n      currentState: null,\n      proposedState: {\n        id: 'task-1',\n        name: 'Test task',\n        done: false,\n        due: null,\n        priority: 'High',\n        projectId: 'project-1',\n        teamId: 'team-1',\n      },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    vi.mocked(mockTaskRepo.create).mockResolvedValue(mockTaskProposal);\n\n    const mockMeetingProposal: ChangeProposal<Meeting> = {\n      id: 'meeting-proposal-1',\n      type: 'create',\n      target: { database: '2d5a4e63-bf23-8168-af99-d85e20bfb76f' },\n      currentState: null,\n      proposedState: {\n        id: 'meeting-1',\n        name: 'Sprint Planning - Test Sprint',\n        type: 'Sprint Planning',\n        cadence: 'Biweekly',\n        date: '2026-01-06T00:00:00.000Z',\n        teamIds: ['team-1'],\n        projectIds: ['project-1'],\n        attendeeTeamIds: [],\n        actionItemTaskIds: [],\n      },\n      diff: [],\n      sideEffects: [],\n      validation: { valid: true, errors: [], warnings: [] },\n      status: 'pending',\n      createdAt: new Date(),\n    };\n\n    vi.mocked(mockMeetingRepo.create).mockResolvedValue(mockMeetingProposal);\n\n    const config = {\n      teamId: 'team-1',\n      name: 'Test Sprint',\n      startDate: new Date('2026-01-06'),\n      endDate: new Date('2026-01-20'),\n      milestone: 'M1' as const,\n      phase: 'P1.1' as const,\n      domain: 'ENG' as const,\n      tasks: [\n        {\n          name: 'Test task',\n          done: false,\n          due: null,\n          priority: 'High' as const,\n          teamId: 'team-1',\n        },\n      ],\n    };\n\n    const proposal = await workflow.planSprint(config);\n\n    expect(proposal.project).toBeDefined();\n    expect(proposal.tasks).toHaveLength(1);\n    expect(proposal.meetings).toHaveLength(3); // Planning, Standup, Post-mortem\n    expect(proposal.summary.projectName).toBe('Test Sprint');\n    expect(proposal.summary.taskCount).toBe(1);\n    expect(proposal.summary.meetingCount).toBe(3);\n  });\n\n  it('should validate sprint configuration', async () => {\n    const workflow = new SprintCycleWorkflow(mockProjectRepo, mockTaskRepo, mockMeetingRepo);\n\n    const invalidConfig = {\n      teamId: '',\n      name: '',\n      startDate: new Date('2026-01-20'),\n      endDate: new Date('2026-01-06'), // End before start\n      milestone: 'M1' as const,\n      phase: 'P1.1' as const,\n      domain: 'ENG' as const,\n      tasks: [],\n    };\n\n    await expect(workflow.planSprint(invalidConfig)).rejects.toThrow();\n  });\n\n  it('should format sprint proposal for review', async () => {\n    const workflow = new SprintCycleWorkflow(mockProjectRepo, mockTaskRepo, mockMeetingRepo);\n\n    const mockProposal = {\n      project: {\n        id: 'proposal-1',\n        proposedState: {\n          id: 'project-1',\n          name: 'Test Sprint',\n          status: 'Active',\n          startDate: '2026-01-06',\n          endDate: '2026-01-20',\n        },\n      },\n      tasks: [\n        {\n          id: 'task-1',\n          proposedState: {\n            name: 'Task 1',\n            priority: 'High',\n            due: '2026-01-10',\n          },\n        },\n      ],\n      meetings: [\n        {\n          id: 'meeting-1',\n          proposedState: {\n            name: 'Sprint Planning',\n            type: 'Sprint Planning',\n            date: '2026-01-06',\n          },\n        },\n      ],\n      summary: {\n        projectName: 'Test Sprint',\n        teamId: 'team-1',\n        duration: '14 days',\n        taskCount: 1,\n        meetingCount: 1,\n        milestone: 'M1',\n        phase: 'P1.1',\n      },\n    } as SprintProposal;\n\n    const formatted = workflow.formatForReview(mockProposal);\n\n    expect(formatted).toContain('Test Sprint');\n    expect(formatted).toContain('Task 1');\n    expect(formatted).toContain('Sprint Planning');\n    expect(formatted).toContain('14 days');\n  });\n});"
    },
    {
      "path": "./src/index.ts",
      "category": "exports",
      "startLine": 1,
      "endLine": 53,
      "chars": 1214,
      "approxTokens": 304.0,
      "sha256": "9526F6D38C4A84C6471DBCCD0D4299428493B52B0F76724B60A9679732ED6D4C",
      "content": "// MCP Client\nexport { McpClient, MockMcpClient } from './mcp/client.js';\n\n// Core constants\nexport { DATABASE_IDS as DATABASE_IDS_CONST } from './core/constants/databases.js';\nexport { DATABASE_IDS, MCP_DEFAULTS } from './core/constants/index.js';\n\n// Core types\nexport type {\n  CsvParserOptions,\n  Snapshot,\n  SnapshotDiff,\n  SnapshotRecord,\n} from './core/types/snapshot.js';\n\nexport { SnapshotRecordSchema, SnapshotSchema } from './core/types/snapshot.js';\n\n// Snapshot management\nexport { SnapshotManager } from './sync/snapshot.js';\n\n// CSV parsing\nexport { CsvSnapshotParser } from './sync/parser/csv.js';\n\n// Safety Layer\nexport {\n  BatchLimiter,\n  DiffEngine,\n  ProposalManager,\n  Validator,\n  type ApplyResult,\n  type BatchConfig,\n  type BatchOperation,\n  type BatchResult,\n  type ChangeProposal,\n  type DiffResult,\n  type ImpactLevel,\n  type PropertyDiff,\n  type SideEffect,\n  type ValidationContext,\n  type ValidationResult,\n  type ValidationRule,\n} from './safety/index.js';\n\n// Error types\nexport {\n  BatchLimitExceededError,\n  EntityNotFoundError,\n  McpError,\n  NotionistaError,\n  ProposalNotFoundError,\n  RepositoryError,\n  ValidationError as SafetyValidationError,\n} from './core/errors/index.js';"
    },
    {
      "path": "./examples/analytics.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 231,
      "chars": 8109,
      "approxTokens": 2027.0,
      "sha256": "4C1B0D2A7750E61A672A4FAFF222D698AB71CFB26F88B32982C05835F1D526B9",
      "content": "/**\r\n * Example: Analytics and Reporting\r\n * \r\n * This example demonstrates generating analytics and reports including:\r\n * - Team performance metrics\r\n * - Project progress tracking\r\n * - Task completion rates\r\n * - Sprint reports\r\n */\r\n\r\nimport { NotionistaSdk } from '../src';\r\nimport { AnalyticsService } from '../src/domain/services/analytics';\r\n\r\n// Initialize the SDK\r\nconst sdk = new NotionistaSdk({\r\n  notionToken: process.env.NOTION_TOKEN!,\r\n  logLevel: 'info',\r\n});\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('🔌 Connecting to Notion MCP server...\\n');\r\n    await sdk.connect();\r\n\r\n    const analytics = new AnalyticsService(sdk);\r\n\r\n    // ========================================\r\n    // Example 1: Team Metrics\r\n    // ========================================\r\n    console.log('📊 Example 1: Team Performance Metrics');\r\n    console.log('═'.repeat(60));\r\n\r\n    // Get all teams\r\n    const teams = await sdk.teams.findMany();\r\n    \r\n    if (teams.length === 0) {\r\n      console.log('No teams found\\n');\r\n    } else {\r\n      console.log(`Found ${teams.length} teams\\n`);\r\n\r\n      for (const team of teams) {\r\n        const metrics = await analytics.getTeamMetrics(team.id);\r\n\r\n        console.log(`\\n📋 ${team.name}`);\r\n        console.log('─'.repeat(60));\r\n        console.log(`Projects:`);\r\n        console.log(`  Total: ${metrics.totalProjects}`);\r\n        console.log(`  Active: ${metrics.activeProjects}`);\r\n        console.log(`  Completed: ${metrics.completedProjects}`);\r\n        console.log(`  On Hold: ${metrics.onHoldProjects}`);\r\n        console.log();\r\n        console.log(`Tasks:`);\r\n        console.log(`  Total: ${metrics.totalTasks}`);\r\n        console.log(`  Completed: ${metrics.completedTasks}`);\r\n        console.log(`  In Progress: ${metrics.inProgressTasks}`);\r\n        console.log(`  Completion Rate: ${metrics.completionRate.toFixed(1)}%`);\r\n        console.log();\r\n        console.log(`Priority Breakdown:`);\r\n        console.log(`  High: ${metrics.tasksByPriority.High || 0}`);\r\n        console.log(`  Medium: ${metrics.tasksByPriority.Medium || 0}`);\r\n        console.log(`  Low: ${metrics.tasksByPriority.Low || 0}`);\r\n        console.log();\r\n        \r\n        if (metrics.overdueTasks > 0) {\r\n          console.log(`⚠️  Overdue Tasks: ${metrics.overdueTasks}`);\r\n        }\r\n      }\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 2: Project Progress Report\r\n    // ========================================\r\n    console.log('📊 Example 2: Project Progress Report');\r\n    console.log('═'.repeat(60));\r\n\r\n    const activeProjects = await sdk.projects.findMany({\r\n      where: { status: 'Active' },\r\n    });\r\n\r\n    if (activeProjects.length === 0) {\r\n      console.log('No active projects\\n');\r\n    } else {\r\n      console.log(`\\nFound ${activeProjects.length} active projects\\n`);\r\n\r\n      for (const project of activeProjects) {\r\n        const report = await analytics.getProjectProgress(project.id);\r\n\r\n        console.log(`\\n🎯 ${project.name}`);\r\n        console.log('─'.repeat(60));\r\n        console.log(`Milestone: ${project.milestone || 'None'}`);\r\n        console.log(`Phase: ${project.phase || 'None'}`);\r\n        console.log(`Duration: ${report.durationDays} days`);\r\n        console.log(`Progress: ${report.progressPercent.toFixed(1)}%`);\r\n        console.log();\r\n        console.log(`Tasks: ${report.completedTasks}/${report.totalTasks} completed`);\r\n        \r\n        if (report.remainingDays !== null) {\r\n          console.log(`Remaining: ${report.remainingDays} days`);\r\n        }\r\n        \r\n        // Progress bar (uses Unicode blocks by default; fall back to ASCII on\r\n        // terminals that may not render block characters correctly)\r\n        const barLength = 40;\r\n        const filled = Math.round((report.progressPercent / 100) * barLength);\r\n        const useAsciiBar =\r\n          process.env.TERM === 'dumb' || process.env.CI === 'true';\r\n        const filledChar = useAsciiBar ? '#' : '█';\r\n        const emptyChar = useAsciiBar ? '-' : '░';\r\n        const bar = filledChar.repeat(filled) + emptyChar.repeat(barLength - filled);\r\n        console.log(`[${bar}] ${report.progressPercent.toFixed(1)}%`);\r\n      }\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 3: Sprint Report\r\n    // ========================================\r\n    console.log('📊 Example 3: Sprint Report');\r\n    console.log('═'.repeat(60));\r\n\r\n    // Find recent sprints (projects in the last 30 days)\r\n    const thirtyDaysAgo = new Date();\r\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\r\n\r\n    const recentSprints = await sdk.projects.findMany({\r\n      where: {\r\n        startDate: { onOrAfter: thirtyDaysAgo.toISOString() },\r\n      },\r\n      limit: 3,\r\n    });\r\n\r\n    if (recentSprints.length === 0) {\r\n      console.log('\\nNo recent sprints found\\n');\r\n    } else {\r\n      for (const sprint of recentSprints) {\r\n        const report = await analytics.generateSprintReport(sprint.id);\r\n\r\n        console.log(`\\n🏃 ${report.name}`);\r\n        console.log('─'.repeat(60));\r\n        console.log(`Status: ${report.status}`);\r\n        console.log(`Duration: ${report.startDate} - ${report.endDate}`);\r\n        console.log(`Days: ${report.durationDays}`);\r\n        console.log();\r\n        console.log(`Velocity: ${report.velocity.toFixed(1)} tasks/day`);\r\n        console.log(`Burndown: ${report.remainingTasks} tasks remaining`);\r\n        console.log();\r\n        console.log(`Task Breakdown:`);\r\n        console.log(`  Completed: ${report.completedTasks}`);\r\n        console.log(`  In Progress: ${report.inProgressTasks}`);\r\n        console.log(`  Not Started: ${report.notStartedTasks}`);\r\n        console.log(`  Total: ${report.totalTasks}`);\r\n        console.log();\r\n        \r\n        if (report.blockers.length > 0) {\r\n          console.log(`🚧 Blockers (${report.blockers.length}):`);\r\n          report.blockers.forEach(blocker => {\r\n            console.log(`  • ${blocker.name}`);\r\n          });\r\n        }\r\n      }\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 4: Task Completion Trends\r\n    // ========================================\r\n    console.log('📊 Example 4: Task Completion Trends');\r\n    console.log('═'.repeat(60));\r\n\r\n    const last7Days = Array.from({ length: 7 }, (_, i) => {\r\n      const date = new Date();\r\n      date.setDate(date.getDate() - (6 - i));\r\n      return date;\r\n    });\r\n\r\n    console.log('\\nTasks completed per day (last 7 days):\\n');\r\n\r\n    for (const date of last7Days) {\r\n      const nextDay = new Date(date);\r\n      nextDay.setDate(nextDay.getDate() + 1);\r\n\r\n      const completedTasks = await sdk.tasks.findMany({\r\n        where: {\r\n          done: true,\r\n          completedAt: {\r\n            onOrAfter: date.toISOString(),\r\n            before: nextDay.toISOString(),\r\n          },\r\n        },\r\n      });\r\n\r\n      const dateStr = date.toLocaleDateString('en-US', { \r\n        month: 'short', \r\n        day: 'numeric' \r\n      });\r\n      \r\n      const bar = '█'.repeat(completedTasks.length);\r\n      console.log(`  ${dateStr}: ${bar} ${completedTasks.length}`);\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 5: Custom Analytics Query\r\n    // ========================================\r\n    console.log('📊 Example 5: Custom Analytics Query');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\nHigh-priority tasks by team:\\n');\r\n\r\n    for (const team of teams) {\r\n      const highPriorityTasks = await sdk.tasks.findMany({\r\n        where: {\r\n          teamId: team.id,\r\n          priority: 'High',\r\n          done: false,\r\n        },\r\n      });\r\n\r\n      if (highPriorityTasks.length > 0) {\r\n        console.log(`  ${team.name}: ${highPriorityTasks.length} tasks`);\r\n      }\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 6: Export Report\r\n    // ========================================\r\n    console.log('📊 Example 6: Export Report to Markdown');\r\n    console.log('═'.repeat(60));"
    },
    {
      "path": "./examples/analytics.ts",
      "category": "examples",
      "startLine": 232,
      "endLine": 282,
      "chars": 1737,
      "approxTokens": 434.0,
      "sha256": "1BF56BF5B378C2BACD39603802999F245B76BC7DEDC8F033CB63FC55D7C20EBC",
      "content": "    const report = await analytics.generateFullReport({\r\n      includeTeams: true,\r\n      includeProjects: true,\r\n      includeTasks: true,\r\n      format: 'markdown',\r\n    });\r\n\r\n    console.log('\\n📄 Report generated:');\r\n    console.log('─'.repeat(60));\r\n    console.log(report.slice(0, 500) + '...');\r\n    console.log('\\n(truncated for display)');\r\n    console.log();\r\n\r\n    // Save to file\r\n    const fs = await import('fs/promises');\r\n    const reportPath = `/tmp/notion-report-${Date.now()}.md`;\r\n    await fs.writeFile(reportPath, report);\r\n    console.log(`✓ Full report saved to: ${reportPath}`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Summary\r\n    // ========================================\r\n    console.log('═'.repeat(60));\r\n    console.log('✨ Analytics Capabilities Summary');\r\n    console.log('═'.repeat(60));\r\n    console.log('\\n📊 Available Analytics:');\r\n    console.log('   1. Team performance metrics');\r\n    console.log('   2. Project progress tracking');\r\n    console.log('   3. Sprint reports and velocity');\r\n    console.log('   4. Task completion trends');\r\n    console.log('   5. Custom queries and filters');\r\n    console.log('   6. Export to various formats');\r\n    console.log('\\n💡 Use Cases:');\r\n    console.log('   • Daily standup reports');\r\n    console.log('   • Sprint retrospectives');\r\n    console.log('   • Team performance reviews');\r\n    console.log('   • Resource allocation');\r\n    console.log('   • Bottleneck identification');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Error:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    console.log('\\n🔌 Disconnecting from MCP server...');\r\n    await sdk.disconnect();\r\n  }\r\n}\r\n\r\n// Run the example\r\nmain();"
    },
    {
      "path": "./examples/basic-usage.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 174,
      "chars": 5737,
      "approxTokens": 1434.0,
      "sha256": "ADB6C2A975BA0E0431D3D64EB4C64BE250B2674B71EFC4961EDB04A5CFC10538",
      "content": "/**\n * Example: Basic Repository Usage\n * \n * This example demonstrates the core repository operations and safety workflow.\n */\n\nimport {\n  TeamRepository,\n  ProjectRepository,\n  TaskRepository,\n  MockMcpClient,\n  type ChangeProposal,\n  type Team,\n  type Project,\n  type Task,\n} from '../src';\n\nasync function main() {\n  // Initialize repositories with mock client\n  const client = new MockMcpClient();\n  const teamRepo = new TeamRepository(client);\n  const projectRepo = new ProjectRepository(client);\n  const taskRepo = new TaskRepository(client);\n\n  console.log('=== Notionista SDK Example ===\\n');\n\n  // ============================================\n  // Example 1: Create a Team (Safety Workflow)\n  // ============================================\n  console.log('1. Creating a team using safety workflow...');\n  \n  const teamProposal = await teamRepo.create({\n    name: 'Engineering Team',\n  });\n\n  console.log('   - Proposal type:', teamProposal.type);\n  console.log('   - Proposal ID:', teamProposal.id);\n  console.log('   - Current state:', teamProposal.currentState);\n  console.log('   - Proposed state:', teamProposal.proposedState);\n  console.log('   - Property diffs:', teamProposal.diff.length, 'changes');\n  console.log('   - Validation:', teamProposal.validation.valid ? 'VALID' : 'INVALID');\n\n  // Apply the proposal\n  const engineeringTeam = await teamRepo.executeCreate(teamProposal);\n  console.log('   ✓ Team created:', engineeringTeam.name, `(${engineeringTeam.id})\\n`);\n\n  // ============================================\n  // Example 2: Create a Project\n  // ============================================\n  console.log('2. Creating a project...');\n  \n  const projectProposal = await projectRepo.create({\n    name: 'Q1 2026 Sprint',\n    status: 'Active',\n    milestone: 'M1',\n    phase: 'P1.1',\n    domain: 'ENG',\n    startDate: '2026-01-01',\n    endDate: '2026-01-14',\n    teamId: engineeringTeam.id,\n  });\n\n  const project = await projectRepo.executeCreate(projectProposal);\n  console.log('   ✓ Project created:', project.name);\n  console.log('     - Status:', project.status);\n  console.log('     - Milestone:', project.milestone);\n  console.log('     - Phase:', project.phase, '\\n');\n\n  // ============================================\n  // Example 3: Create Tasks\n  // ============================================\n  console.log('3. Creating tasks...');\n  \n  const tasks = await Promise.all([\n    taskRepo.create({\n      name: 'Implement authentication',\n      done: false,\n      priority: 'High',\n      due: '2026-01-05',\n      projectId: project.id,\n      teamId: engineeringTeam.id,\n    }),\n    taskRepo.create({\n      name: 'Write documentation',\n      done: false,\n      priority: 'Medium',\n      due: '2026-01-10',\n      projectId: project.id,\n      teamId: engineeringTeam.id,\n    }),\n    taskRepo.create({\n      name: 'Setup CI/CD',\n      done: true,\n      priority: 'High',\n      due: '2026-01-03',\n      projectId: project.id,\n      teamId: engineeringTeam.id,\n    }),\n  ]);\n\n  const createdTasks = await Promise.all(\n    tasks.map(proposal => taskRepo.executeCreate(proposal))\n  );\n\n  console.log('   ✓ Created', createdTasks.length, 'tasks');\n  createdTasks.forEach(task => {\n    console.log(`     - [${task.done ? '✓' : ' '}] ${task.name} (${task.priority})`);\n  });\n\n  // ============================================\n  // Example 4: Update a Task\n  // ============================================\n  console.log('\\n4. Updating a task (marking as done)...');\n  \n  const taskToUpdate = createdTasks[0]!;\n  const updateProposal = await taskRepo.update(taskToUpdate.id, {\n    done: true,\n  });\n\n  console.log('   - Current state:', updateProposal.currentState?.done ? 'done' : 'incomplete');\n  console.log('   - Proposed state:', updateProposal.proposedState.done ? 'done' : 'incomplete');\n  \n  const doneChange = updateProposal.diff.find(d => d.property === 'done');\n  if (doneChange) {\n    console.log('   - Change impact:', doneChange.impact);\n  }\n\n  const updatedTask = await taskRepo.executeUpdate(updateProposal);\n  console.log('   ✓ Task updated:', updatedTask.name, '- Status:', updatedTask.done ? 'Done' : 'Todo', '\\n');\n\n  // ============================================\n  // Example 5: Query and Filter\n  // ============================================\n  console.log('5. Querying data...');\n  \n  // Find incomplete tasks\n  const incompleteTasks = await taskRepo.findIncomplete();\n  console.log('   - Incomplete tasks:', incompleteTasks.length);\n\n  // Find high priority tasks\n  const highPriorityTasks = await taskRepo.findHighPriority();\n  console.log('   - High priority tasks:', highPriorityTasks.length);\n\n  // Calculate project completion rate\n  const completionRate = await taskRepo.getProjectCompletionRate(project.id);\n  console.log('   - Project completion:', completionRate.toFixed(1), '%');\n\n  // Find active projects\n  const activeProjects = await projectRepo.findActive();\n  console.log('   - Active projects:', activeProjects.length);\n\n  // Get team metrics\n  const metrics = await teamRepo.getMetrics(engineeringTeam.id);\n  console.log('   - Team metrics:');\n  console.log('     * Total projects:', metrics.totalProjects);\n  console.log('     * Total tasks:', metrics.totalTasks);\n  console.log('     * Tasks completed:', metrics.tasksCompleted, '\\n');\n\n  // ============================================\n  // Example 6: Error Handling\n  // ============================================\n  console.log('6. Error handling...');\n  \n  try {\n    await teamRepo.findByIdOrThrow('non-existent-id');\n  } catch (error: any) {\n    console.log('   ✓ Caught expected error:', error.message, '\\n');\n  }\n\n  console.log('=== Example Complete ===');\n}\n\n// Run the example\nmain().catch(console.error);"
    },
    {
      "path": "./examples/bulk-update.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 254,
      "chars": 7832,
      "approxTokens": 1958.0,
      "sha256": "21AE47FA14606210C49762AACDB75636FE07CAF0D0E705E35DE1551A1FA52974",
      "content": "/**\n * Example: Bulk Update Operations\n * \n * This example demonstrates safe bulk update operations with:\n * - Batch size limits (max 50 items)\n * - Dry-run summaries\n * - Progress tracking\n * - Error handling\n */\n\nimport { NotionistaSdk } from '../src';\n\n// Initialize the SDK\nconst sdk = new NotionistaSdk({\n  notionToken: process.env.NOTION_TOKEN!,\n  logLevel: 'info',\n});\n\nasync function main() {\n  try {\n    console.log('🔌 Connecting to Notion MCP server...\\n');\n    await sdk.connect();\n\n    // ========================================\n    // Example 1: Small Batch Update\n    // ========================================\n    console.log('📦 Example 1: Small batch update (safe)');\n    console.log('═'.repeat(60));\n\n    // Get some incomplete tasks\n    const tasksToUpdate = await sdk.tasks.findMany({\n      where: { done: false, priority: { isEmpty: true } },\n      limit: 5,\n    });\n\n    if (tasksToUpdate.length === 0) {\n      console.log('No tasks found to update\\n');\n    } else {\n      console.log(`Found ${tasksToUpdate.length} tasks without priority\\n`);\n\n      // Create bulk update proposal\n      const bulkProposal = await sdk.tasks.bulkUpdate(\n        tasksToUpdate.map(task => ({\n          id: task.id,\n          updates: { priority: 'Medium' },\n        }))\n      );\n\n      console.log('📋 Bulk Update Proposal:');\n      console.log('─'.repeat(60));\n      console.log(`  Items: ${bulkProposal.items.length}`);\n      console.log(`  Status: ${bulkProposal.status}`);\n      console.log(`  Estimated duration: ${bulkProposal.estimatedDuration}ms`);\n      console.log();\n\n      // Show detailed changes\n      console.log('📝 Changes:');\n      bulkProposal.items.forEach((item, index) => {\n        console.log(`  ${index + 1}. Task: ${tasksToUpdate[index].name}`);\n        console.log(`     Change: priority → Medium`);\n      });\n      console.log();\n\n      // Review and approve\n      console.log('🤔 Reviewing bulk update...');\n      console.log('   → Decision: APPROVE\\n');\n\n      await bulkProposal.approve();\n      console.log('✓ Proposal approved\\n');\n\n      // Apply changes with progress tracking\n      console.log('🚀 Applying changes...');\n      const result = await bulkProposal.apply();\n\n      console.log('✓ Bulk update complete!');\n      console.log(`  Successful: ${result.successful}`);\n      console.log(`  Failed: ${result.failed}`);\n      console.log(`  Total time: ${result.duration}ms`);\n      console.log();\n\n      // Show results\n      if (result.errors.length > 0) {\n        console.log('⚠️  Errors:');\n        result.errors.forEach(error => {\n          console.log(`  • ${error.taskId}: ${error.message}`);\n        });\n      }\n    }\n    console.log();\n\n    // ========================================\n    // Example 2: Batch Size Limit Enforcement\n    // ========================================\n    console.log('📦 Example 2: Batch size limit enforcement');\n    console.log('═'.repeat(60));\n\n    try {\n      console.log('\\nAttempting to update 51 items (exceeds limit)...');\n      \n      const tooManyUpdates = Array(51).fill(null).map((_, i) => ({\n        id: `task-${i}`,\n        updates: { priority: 'High' },\n      }));\n\n      await sdk.tasks.bulkUpdate(tooManyUpdates);\n      \n    } catch (error) {\n      console.log('❌ Error caught (as expected):');\n      if (error instanceof Error) {\n        console.log(`   ${error.message}`);\n      } else {\n        console.log(`   ${String(error)}`);\n      }\n      console.log('   → Batch operations limited to 50 items for safety');\n    }\n    console.log();\n\n    // ========================================\n    // Example 3: Dry Run\n    // ========================================\n    console.log('📦 Example 3: Dry run (preview without executing)');\n    console.log('═'.repeat(60));\n\n    const dryRunTasks = await sdk.tasks.findMany({\n      where: { done: false },\n      limit: 10,\n    });\n\n    console.log(`\\nGenerating dry-run for ${dryRunTasks.length} tasks...\\n`);\n\n    const dryRunProposal = await sdk.tasks.bulkUpdate(\n      dryRunTasks.map(task => ({\n        id: task.id,\n        updates: { priority: 'Low' },\n      })),\n      { dryRun: true }\n    );\n\n    console.log('📊 Dry Run Summary:');\n    console.log('─'.repeat(60));\n    console.log(dryRunProposal.dryRunSummary);\n    console.log();\n    console.log('ℹ️  This was a preview only - no changes applied');\n    console.log();\n\n    // ========================================\n    // Example 4: Bulk Update with Error Handling\n    // ========================================\n    console.log('📦 Example 4: Bulk update with error handling');\n    console.log('═'.repeat(60));\n\n    const tasksForUpdate = await sdk.tasks.findMany({\n      where: { done: false },\n      limit: 3,\n    });\n\n    if (tasksForUpdate.length > 0) {\n      console.log(`\\nUpdating ${tasksForUpdate.length} tasks...\\n`);\n\n      try {\n        const proposal = await sdk.tasks.bulkUpdate(\n          tasksForUpdate.map(task => ({\n            id: task.id,\n            updates: { \n              priority: 'High',\n              due: new Date('2026-01-15'),\n            },\n          })),\n          { continueOnError: true }  // Continue even if some fail\n        );\n\n        await proposal.approve();\n        const result = await proposal.apply();\n\n        console.log('📊 Results:');\n        console.log(`  Total: ${result.total}`);\n        console.log(`  Successful: ${result.successful}`);\n        console.log(`  Failed: ${result.failed}`);\n        \n        if (result.failed > 0) {\n          console.log('\\n⚠️  Failed items:');\n          result.errors.forEach(error => {\n            console.log(`  • ${error.id}: ${error.message}`);\n          });\n        }\n\n      } catch (error) {\n        if (error instanceof Error) {\n          console.error('❌ Bulk update failed:', error.message);\n        } else {\n          console.error('❌ Bulk update failed:', String(error));\n        }\n      }\n    }\n    console.log();\n\n    // ========================================\n    // Example 5: Progress Tracking\n    // ========================================\n    console.log('📦 Example 5: Progress tracking for large batches');\n    console.log('═'.repeat(60));\n\n    const largeBatchTasks = await sdk.tasks.findMany({\n      where: { done: false },\n      limit: 20,\n    });\n\n    if (largeBatchTasks.length > 0) {\n      console.log(`\\nUpdating ${largeBatchTasks.length} tasks with progress tracking...\\n`);\n\n      const proposal = await sdk.tasks.bulkUpdate(\n        largeBatchTasks.map(task => ({\n          id: task.id,\n          updates: { priority: 'Medium' },\n        }))\n      );\n\n      await proposal.approve();\n\n      // Set up progress tracking\n      proposal.on('progress', (event) => {\n        const percent = ((event.completed / event.total) * 100).toFixed(0);\n        process.stdout.write(`\\r  Progress: ${percent}% (${event.completed}/${event.total})`);\n      });\n\n      await proposal.apply();\n      console.log('\\n✓ Batch update complete!\\n');\n    }\n\n    // ========================================\n    // Best Practices Summary\n    // ========================================\n    console.log('═'.repeat(60));\n    console.log('✨ Bulk Update Best Practices');\n    console.log('═'.repeat(60));\n    console.log('\\n📚 Key Takeaways:');\n    console.log('   1. Batch operations limited to 50 items for safety');\n    console.log('   2. Always use dry-run to preview large updates');\n    console.log('   3. Use continueOnError for fault tolerance');\n    console.log('   4. Track progress for large batches');\n    console.log('   5. Handle errors gracefully');\n    console.log('   6. Review proposals before applying');\n\n  } catch (error) {\n    console.error('\\n❌ Error:', error);\n    process.exit(1);\n  } finally {\n    console.log('\\n🔌 Disconnecting from MCP server...');\n    await sdk.disconnect();\n  }\n}\n\n// Run the example\nmain();"
    },
    {
      "path": "./examples/compare-snapshots.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 153,
      "chars": 5010,
      "approxTokens": 1252.0,
      "sha256": "D3BA6D17582AC99CAAE9B62BC3EA72BF3198BC0C2111997C5CE326C8B124C691",
      "content": "#!/usr/bin/env node\n/**\n * Example: Parse CSV snapshots and compare them\n *\n * This example demonstrates how to:\n * 1. List available snapshots\n * 2. Load specific snapshots\n * 3. Compare snapshots to detect changes\n * 4. Generate diff reports\n *\n * Note: Run `npm run build` before running this example.\n */\n\nimport { SnapshotManager, type SnapshotRecord } from \"../dist/index.js\";\n\nconst SNAPSHOT_DIRECTORY = \"./snapshots\";\n\nconst formatError = (error: unknown): string =>\n  error instanceof Error ? error.message : String(error);\n\nconst getRecordName = (record: SnapshotRecord): string => {\n  const nameKeys = [\"Name\", \"name\"] as const;\n  for (const key of nameKeys) {\n    const value = record.properties[key];\n    if (typeof value === \"string\" && value.trim().length > 0) {\n      return value;\n    }\n  }\n  return record.id;\n};\n\nasync function main(): Promise<void> {\n  const manager = new SnapshotManager(SNAPSHOT_DIRECTORY);\n\n  console.log(\"📸 Snapshot Comparison Example\\n\");\n\n  // List available snapshots\n  console.log(\"Available snapshots:\");\n  const snapshots = manager.listSnapshots();\n\n  if (snapshots.length === 0) {\n    console.log(`⚠️  No snapshots found in ${SNAPSHOT_DIRECTORY} directory`);\n    console.log(`   Please export your Notion workspace and place it in ${SNAPSHOT_DIRECTORY}/`);\n    console.log(\"   Expected format: snapshots/notion-export-YYYY-MM-DD/\");\n    return;\n  }\n\n  snapshots.forEach((snap, i) => {\n    console.log(`  ${i + 1}. ${snap}`);\n  });\n\n  // Load the two most recent snapshots\n  if (snapshots.length < 2) {\n    console.log(\"\\n⚠️  Need at least 2 snapshots to compare\");\n\n    // Show info about the single snapshot\n    const [singleSnapshot] = snapshots;\n    if (singleSnapshot) {\n      console.log(`\\nLoading single snapshot: ${singleSnapshot}`);\n\n      try {\n        const snapshot = manager.loadSnapshot(singleSnapshot, \"tasks\");\n        console.log(`\\n📋 Tasks Snapshot:`);\n        console.log(`   Database ID: ${snapshot.databaseId}`);\n        console.log(`   Captured: ${snapshot.capturedAt.toISOString()}`);\n        console.log(`   Records: ${snapshot.pageCount}`);\n\n        if (snapshot.records.length > 0) {\n          console.log(`\\n   Sample records:`);\n          snapshot.records.slice(0, 3).forEach((record) => {\n            console.log(`   - ${getRecordName(record)}`);\n          });\n        }\n      } catch (error) {\n        console.error(`   Error loading snapshot: ${formatError(error)}`);\n      }\n    }\n    return;\n  }\n\n  const newestSnapshot = snapshots[0]!;\n  const olderSnapshot = snapshots[1]!;\n  console.log(`\\n🔍 Comparing:`);\n  console.log(`   Old: ${olderSnapshot}`);\n  console.log(`   New: ${newestSnapshot}`);\n\n  // Compare Tasks\n  console.log(\"\\n📋 Tasks Database:\");\n  try {\n    const oldSnapshot = manager.loadSnapshot(olderSnapshot, \"tasks\");\n    const newSnapshot = manager.loadSnapshot(newestSnapshot, \"tasks\");\n\n    const diff = manager.compareSnapshots(oldSnapshot, newSnapshot);\n\n    console.log(`   Added: ${diff.added.length} records`);\n    console.log(`   Removed: ${diff.removed.length} records`);\n    console.log(`   Modified: ${diff.modified.length} records`);\n\n    if (diff.added.length > 0 || diff.removed.length > 0 || diff.modified.length > 0) {\n      console.log(\"\\n📄 Detailed Diff Report:\");\n      console.log(\"─\".repeat(60));\n      const report = manager.formatDiffReport(diff);\n      console.log(report);\n    } else {\n      console.log(\"   ✅ No changes detected\");\n    }\n  } catch (error) {\n    console.error(`   ❌ Error: ${formatError(error)}`);\n  }\n\n  // Compare Projects\n  console.log(\"\\n📁 Projects Database:\");\n  try {\n    const oldSnapshot = manager.loadSnapshot(olderSnapshot, \"projects\");\n    const newSnapshot = manager.loadSnapshot(newestSnapshot, \"projects\");\n\n    const diff = manager.compareSnapshots(oldSnapshot, newSnapshot);\n\n    console.log(`   Added: ${diff.added.length} records`);\n    console.log(`   Removed: ${diff.removed.length} records`);\n    console.log(`   Modified: ${diff.modified.length} records`);\n\n    if (diff.modified.length > 0) {\n      console.log(\"\\n   Modified projects:\");\n      diff.modified.forEach((mod) => {\n        console.log(`   - ${getRecordName(mod.newRecord)}: ${mod.changedProperties.join(\", \")}`);\n      });\n    }\n  } catch (error) {\n    console.error(`   ❌ Error: ${formatError(error)}`);\n  }\n\n  // Compare Teams\n  console.log(\"\\n👥 Teams Database:\");\n  try {\n    const oldSnapshot = manager.loadSnapshot(olderSnapshot, \"teams\");\n    const newSnapshot = manager.loadSnapshot(newestSnapshot, \"teams\");\n\n    const diff = manager.compareSnapshots(oldSnapshot, newSnapshot);\n\n    console.log(`   Added: ${diff.added.length} records`);\n    console.log(`   Removed: ${diff.removed.length} records`);\n    console.log(`   Modified: ${diff.modified.length} records`);\n  } catch (error) {\n    console.error(`   ❌ Error: ${formatError(error)}`);\n  }\n\n  console.log(\"\\n✨ Done!\\n\");\n}\n\nmain().catch((error) => {\n  console.error(`❌ Unexpected error: ${formatError(error)}`);\n});"
    },
    {
      "path": "./examples/create-sprint.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 217,
      "chars": 7946,
      "approxTokens": 1986.0,
      "sha256": "DBC07F4F86478C9BF0649E9DBF1817873A6F5FEF81B14BC274341D9FC9DC58E4",
      "content": "/**\r\n * Example: Create Sprint (Workflow Orchestration)\r\n * \r\n * This example demonstrates high-level workflow orchestration for sprint planning.\r\n * A single workflow call creates a complete sprint including:\r\n * - A project with all metadata\r\n * - Multiple tasks linked to the project\r\n * - Sprint meetings (planning, standups, retrospective)\r\n * \r\n * All changes go through the safety workflow (Propose → Approve → Apply).\r\n */\r\n\r\nimport { NotionistaSdk } from '../src';\r\nimport { SprintCycleWorkflow } from '../src/workflows';\r\n\r\n// Initialize the SDK\r\nconst sdk = new NotionistaSdk({\r\n  notionToken: process.env.NOTION_TOKEN!,\r\n  logLevel: 'info',\r\n});\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('🔌 Connecting to Notion MCP server...\\n');\r\n    await sdk.connect();\r\n\r\n    // Get the Engineering team\r\n    console.log('🔍 Finding Engineering Team...');\r\n    const teams = await sdk.teams.findMany({\r\n      where: { name: { contains: 'Engineering' } },\r\n    });\r\n\r\n    if (teams.length === 0) {\r\n      console.error('❌ Engineering team not found. Please create it first.');\r\n      process.exit(1);\r\n    }\r\n\r\n    const engineeringTeam = teams[0];\r\n    console.log(`✓ Found team: ${engineeringTeam.name} (ID: ${engineeringTeam.id})\\n`);\r\n\r\n    // ========================================\r\n    // Configure Sprint\r\n    // ========================================\r\n    console.log('📋 Sprint Configuration');\r\n    console.log('═'.repeat(60));\r\n\r\n    const sprintConfig = {\r\n      teamId: engineeringTeam.id,\r\n      name: 'Sprint 2026-W02: SDK Foundation',\r\n      startDate: new Date('2026-01-06'),\r\n      endDate: new Date('2026-01-20'),\r\n      milestone: 'M1' as const,\r\n      phase: 'P1.1' as const,\r\n      domain: 'ENG' as const,\r\n      tasks: [\r\n        {\r\n          name: 'Set up TypeScript project structure',\r\n          priority: 'High' as const,\r\n          due: new Date('2026-01-08'),\r\n        },\r\n        {\r\n          name: 'Implement MCP client layer',\r\n          priority: 'High' as const,\r\n          due: new Date('2026-01-10'),\r\n        },\r\n        {\r\n          name: 'Create base repository pattern',\r\n          priority: 'High' as const,\r\n          due: new Date('2026-01-13'),\r\n        },\r\n        {\r\n          name: 'Implement safety layer with proposals',\r\n          priority: 'High' as const,\r\n          due: new Date('2026-01-15'),\r\n        },\r\n        {\r\n          name: 'Write unit tests for core modules',\r\n          priority: 'Medium' as const,\r\n          due: new Date('2026-01-17'),\r\n        },\r\n        {\r\n          name: 'Create API documentation',\r\n          priority: 'Medium' as const,\r\n          due: new Date('2026-01-19'),\r\n        },\r\n      ],\r\n    };\r\n\r\n    console.log(`Team: ${engineeringTeam.name}`);\r\n    console.log(`Sprint: ${sprintConfig.name}`);\r\n    console.log(`Duration: ${sprintConfig.startDate.toLocaleDateString()} - ${sprintConfig.endDate.toLocaleDateString()}`);\r\n    console.log(`Milestone: ${sprintConfig.milestone}`);\r\n    console.log(`Phase: ${sprintConfig.phase}`);\r\n    console.log(`Domain: ${sprintConfig.domain}`);\r\n    console.log(`Tasks: ${sprintConfig.tasks.length}`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Phase 1: Plan Sprint (Propose)\r\n    // ========================================\r\n    console.log('🔵 Phase 1: PLAN SPRINT (Generate Proposals)');\r\n    console.log('═'.repeat(60));\r\n    \r\n    const workflow = new SprintCycleWorkflow(sdk);\r\n    \r\n    console.log('🔄 Planning sprint...');\r\n    const sprintProposal = await workflow.planSprint(sprintConfig);\r\n    \r\n    console.log('✓ Sprint planning complete (proposals created)');\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Phase 2: Review Proposals\r\n    // ========================================\r\n    console.log('🔵 Phase 2: REVIEW SPRINT PROPOSALS');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\n📊 Sprint Summary:');\r\n    console.log('─'.repeat(60));\r\n    console.log(sprintProposal.summary);\r\n    console.log();\r\n\r\n    console.log('📋 Project Proposal:');\r\n    console.log('─'.repeat(60));\r\n    console.log(sprintProposal.project.formatForReview());\r\n    console.log();\r\n\r\n    console.log(`📝 Task Proposals (${sprintProposal.tasks.length} tasks):`);\r\n    console.log('─'.repeat(60));\r\n    sprintProposal.tasks.forEach((taskProposal, index) => {\r\n      console.log(`\\nTask ${index + 1}:`);\r\n      console.log(taskProposal.formatForReview());\r\n    });\r\n    console.log();\r\n\r\n    console.log(`📅 Meeting Proposals (${sprintProposal.meetings.length} meetings):`);\r\n    console.log('─'.repeat(60));\r\n    sprintProposal.meetings.forEach((meetingProposal, index) => {\r\n      console.log(`\\nMeeting ${index + 1}:`);\r\n      console.log(meetingProposal.formatForReview());\r\n    });\r\n    console.log();\r\n\r\n    // Show validation results\r\n    console.log('✅ Validation Results:');\r\n    console.log('─'.repeat(60));\r\n    console.log(`Project validation: ${sprintProposal.project.validation.isValid ? '✓ Passed' : '✗ Failed'}`);\r\n    console.log(`Tasks validation: ${sprintProposal.tasks.every(t => t.validation.isValid) ? '✓ All passed' : '✗ Some failed'}`);\r\n    console.log(`Meetings validation: ${sprintProposal.meetings.every(m => m.validation.isValid) ? '✓ All passed' : '✗ Some failed'}`);\r\n    console.log();\r\n\r\n    // Show side effects\r\n    if (sprintProposal.sideEffects.length > 0) {\r\n      console.log('⚠️  Side Effects:');\r\n      console.log('─'.repeat(60));\r\n      sprintProposal.sideEffects.forEach(effect => {\r\n        console.log(`  ${effect.type}: ${effect.description}`);\r\n        console.log(`    Affected items: ${effect.affectedItems.length}`);\r\n      });\r\n      console.log();\r\n    }\r\n\r\n    // ========================================\r\n    // User Decision\r\n    // ========================================\r\n    console.log('🤔 Review Decision:');\r\n    console.log('─'.repeat(60));\r\n    console.log('   ✓ Sprint configuration looks good');\r\n    console.log('   ✓ All tasks are properly defined');\r\n    console.log('   ✓ Meetings are scheduled correctly');\r\n    console.log('   ✓ Relations will be set up properly');\r\n    console.log('   → Decision: APPROVE AND EXECUTE');\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Phase 3: Execute Sprint\r\n    // ========================================\r\n    console.log('🔵 Phase 3: EXECUTE SPRINT (Apply Proposals)');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\n🚀 Executing sprint creation...');\r\n    console.log('   This will create:');\r\n    console.log(`   - 1 project`);\r\n    console.log(`   - ${sprintProposal.tasks.length} tasks`);\r\n    console.log(`   - ${sprintProposal.meetings.length} meetings`);\r\n    console.log();\r\n\r\n    const sprintResult = await workflow.executeSprint(sprintProposal);\r\n\r\n    console.log('✓ Sprint execution complete!');\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Display Results\r\n    // ========================================\r\n    console.log('📊 Execution Results:');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\n✅ Project Created:');\r\n    console.log(`   Name: ${sprintResult.project.name}`);\r\n    console.log(`   ID: ${sprintResult.project.id}`);\r\n    console.log(`   Status: ${sprintResult.project.status}`);\r\n    console.log(`   Milestone: ${sprintResult.project.milestone}`);\r\n    console.log(`   Phase: ${sprintResult.project.phase}`);\r\n    console.log();\r\n\r\n    console.log('✅ Tasks Created:');\r\n    sprintResult.tasks.forEach((task, index) => {\r\n      const dueDate = task.due ? new Date(task.due).toLocaleDateString() : 'No due date';\r\n      console.log(`   ${index + 1}. ${task.name}`);\r\n      console.log(`      Priority: ${task.priority} | Due: ${dueDate}`);\r\n      console.log(`      ID: ${task.id}`);\r\n    });\r\n    console.log();\r\n\r\n    console.log('✅ Meetings Scheduled:');\r\n    sprintResult.meetings.forEach((meeting, index) => {"
    },
    {
      "path": "./examples/create-sprint.ts",
      "category": "examples",
      "startLine": 218,
      "endLine": 293,
      "chars": 2894,
      "approxTokens": 724.0,
      "sha256": "6BA7904529A2EC4A3D2499B36AE68F14DC1D1D3691D3EF095E4B31AA66B44DF7",
      "content": "      const meetingDate = meeting.date ? new Date(meeting.date).toLocaleString() : 'TBD';\r\n      console.log(`   ${index + 1}. ${meeting.name}`);\r\n      console.log(`      Type: ${meeting.type} | Date: ${meetingDate}`);\r\n      console.log(`      ID: ${meeting.id}`);\r\n    });\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Verify Relations\r\n    // ========================================\r\n    console.log('🔗 Verifying Relations:');\r\n    console.log('═'.repeat(60));\r\n\r\n    // Verify project → tasks relation\r\n    const projectTasks = await sdk.tasks.findMany({\r\n      where: { projectId: sprintResult.project.id },\r\n    });\r\n    console.log(`✓ Project has ${projectTasks.length} linked tasks`);\r\n\r\n    // Verify team → project relation\r\n    const teamProjects = await sdk.projects.findMany({\r\n      where: { teamId: engineeringTeam.id },\r\n    });\r\n    console.log(`✓ Project is linked to ${engineeringTeam.name}`);\r\n\r\n    // Verify meetings → project relation\r\n    const projectMeetings = await sdk.meetings.findMany({\r\n      where: { projectIds: { contains: sprintResult.project.id } },\r\n    });\r\n    console.log(`✓ Found ${projectMeetings.length} meetings linked to project`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Generate Sprint Report\r\n    // ========================================\r\n    console.log('📈 Sprint Report:');\r\n    console.log('═'.repeat(60));\r\n    \r\n    const report = await workflow.generateSprintReport(sprintResult.project.id);\r\n    \r\n    console.log(`\\nSprint: ${report.name}`);\r\n    console.log(`Duration: ${report.duration} days`);\r\n    console.log(`Progress: ${report.progress.toFixed(1)}% complete`);\r\n    console.log(`\\nTasks:`);\r\n    console.log(`  Total: ${report.totalTasks}`);\r\n    console.log(`  Completed: ${report.completedTasks}`);\r\n    console.log(`  In Progress: ${report.inProgressTasks}`);\r\n    console.log(`  Not Started: ${report.notStartedTasks}`);\r\n    console.log(`\\nBy Priority:`);\r\n    console.log(`  High: ${report.tasksByPriority.High || 0}`);\r\n    console.log(`  Medium: ${report.tasksByPriority.Medium || 0}`);\r\n    console.log(`  Low: ${report.tasksByPriority.Low || 0}`);\r\n    console.log();\r\n\r\n    console.log('═'.repeat(60));\r\n    console.log('✨ Sprint creation completed successfully!');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\n🎯 Next Steps:');\r\n    console.log('   1. View the project in Notion');\r\n    console.log('   2. Start working on tasks');\r\n    console.log('   3. Attend scheduled meetings');\r\n    console.log('   4. Track progress throughout the sprint');\r\n    console.log('   5. Run daily standup reports');\r\n\r\n  } catch (error) {\r\n    console.error('\\n❌ Error:', error);\r\n    process.exit(1);\r\n  } finally {\r\n    console.log('\\n🔌 Disconnecting from MCP server...');\r\n    await sdk.disconnect();\r\n  }\r\n}\r\n\r\n// Run the example\r\nmain();"
    },
    {
      "path": "./examples/parse-csv.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 64,
      "chars": 1777,
      "approxTokens": 444.0,
      "sha256": "3F44706F3F253CC768ACB9EC1F14B145F0AFAF470C50985CE048D89368714B8E",
      "content": "#!/usr/bin/env node\n/**\n * Example: Parse a single CSV file\n *\n * This example demonstrates how to parse individual CSV files\n * and inspect the extracted data.\n *\n * Note: Run `npm run build` before running this example.\n */\n\nimport { CsvSnapshotParser } from \"../dist/index.js\";\n\nconst formatError = (error: unknown): string =>\n  error instanceof Error ? error.message : String(error);\n\nconst logPropertyValue = (key: string, value: unknown): void => {\n  if (value === null) {\n    console.log(`    ${key}: (empty)`);\n  } else if (typeof value === \"boolean\") {\n    console.log(`    ${key}: ${value ? \"✓\" : \"✗\"}`);\n  } else if (Array.isArray(value)) {\n    console.log(`    ${key}: [${value.length} items]`);\n    value.forEach((item) => {\n      console.log(`      - ${String(item)}`);\n    });\n  } else {\n    console.log(`    ${key}: ${String(value)}`);\n  }\n};\n\nasync function main(): Promise<void> {\n  const parser = new CsvSnapshotParser();\n\n  console.log(\"📄 CSV Parser Example\\n\");\n\n  // Parse the test fixture\n  const csvPath = \"./test/fixtures/tasks.csv\";\n  console.log(`Parsing: ${csvPath}\\n`);\n\n  try {\n    const records = parser.parse(csvPath);\n\n    console.log(`✅ Parsed ${records.length} records\\n`);\n\n    // Display each record\n    records.forEach((record, index) => {\n      console.log(`Record ${index + 1}:`);\n      console.log(`  ID: ${record.id}`);\n      console.log(`  Source: ${record.source}`);\n      console.log(`  Properties:`);\n\n      for (const [key, value] of Object.entries(record.properties)) {\n        logPropertyValue(key, value);\n      }\n      console.log();\n    });\n  } catch (error) {\n    console.error(`❌ Error parsing CSV: ${formatError(error)}`);\n  }\n}\n\nmain().catch((error) => {\n  console.error(`❌ Unexpected error: ${formatError(error)}`);\n});"
    },
    {
      "path": "./examples/query-tasks.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 173,
      "chars": 5254,
      "approxTokens": 1314.0,
      "sha256": "DD4EE739DF3336326FBDA5EECBF971FDAE647AA636793C86AEBB16E6DC42DF3C",
      "content": "/**\n * Example: Query Tasks\n * \n * This example demonstrates basic task querying capabilities including:\n * - Querying all tasks\n * - Filtering by completion status\n * - Filtering by priority\n * - Ordering results\n * - Working with due dates\n */\n\nimport { NotionistaSdk } from '../src';\n\n// Initialize the SDK with your Notion token\nconst sdk = new NotionistaSdk({\n  notionToken: process.env.NOTION_TOKEN!,\n  logLevel: 'info',\n});\n\nasync function main() {\n  try {\n    console.log('🔌 Connecting to Notion MCP server...\\n');\n    await sdk.connect();\n\n    // Example 1: Query all incomplete tasks\n    console.log('📋 Example 1: Query all incomplete tasks');\n    console.log('─'.repeat(50));\n    const incompleteTasks = await sdk.tasks.findMany({\n      where: { done: false },\n    });\n    console.log(`Found ${incompleteTasks.length} incomplete tasks`);\n    incompleteTasks.slice(0, 5).forEach(task => {\n      console.log(`  • ${task.name} (Priority: ${task.priority || 'None'})`);\n    });\n    console.log();\n\n    // Example 2: Query high-priority tasks\n    console.log('🔥 Example 2: Query high-priority incomplete tasks');\n    console.log('─'.repeat(50));\n    const highPriorityTasks = await sdk.tasks.findMany({\n      where: { \n        done: false,\n        priority: 'High',\n      },\n    });\n    console.log(`Found ${highPriorityTasks.length} high-priority tasks`);\n    highPriorityTasks.forEach(task => {\n      const dueDate = task.due ? new Date(task.due).toLocaleDateString() : 'No due date';\n      console.log(`  • ${task.name}`);\n      console.log(`    Due: ${dueDate}`);\n    });\n    console.log();\n\n    // Example 3: Query tasks by due date\n    console.log('📅 Example 3: Query tasks due this week');\n    console.log('─'.repeat(50));\n    const today = new Date();\n    const nextWeek = new Date(today);\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    \n    const tasksDueThisWeek = await sdk.tasks.findMany({\n      where: {\n        done: false,\n        due: {\n          onOrAfter: today.toISOString(),\n          onOrBefore: nextWeek.toISOString(),\n        },\n      },\n      orderBy: { due: 'ascending' },\n    });\n    \n    console.log(`Found ${tasksDueThisWeek.length} tasks due this week`);\n    tasksDueThisWeek.forEach(task => {\n      const dueDate = new Date(task.due!).toLocaleDateString();\n      console.log(`  • ${task.name} - Due: ${dueDate}`);\n    });\n    console.log();\n\n    // Example 4: Query tasks by team\n    console.log('👥 Example 4: Query tasks by team');\n    console.log('─'.repeat(50));\n    \n    // First, get the Engineering team\n    const teams = await sdk.teams.findMany({\n      where: { name: { contains: 'Engineering' } },\n    });\n    \n    if (teams.length > 0) {\n      const engineeringTeam = teams[0];\n      const teamTasks = await sdk.tasks.findMany({\n        where: { teamId: engineeringTeam.id },\n        limit: 10,\n      });\n      \n      console.log(`Found ${teamTasks.length} tasks for ${engineeringTeam.name}`);\n      teamTasks.forEach(task => {\n        const status = task.done ? '✓' : '○';\n        console.log(`  ${status} ${task.name}`);\n      });\n    } else {\n      console.log('  Engineering team not found');\n    }\n    console.log();\n\n    // Example 5: Query completed tasks\n    console.log('✅ Example 5: Recently completed tasks');\n    console.log('─'.repeat(50));\n    const completedTasks = await sdk.tasks.findMany({\n      where: { done: true },\n      orderBy: { completedAt: 'descending' },\n      limit: 5,\n    });\n    \n    console.log(`Found ${completedTasks.length} recently completed tasks`);\n    completedTasks.forEach(task => {\n      console.log(`  ✓ ${task.name}`);\n      if (task.completedAt) {\n        console.log(`    Completed: ${new Date(task.completedAt).toLocaleDateString()}`);\n      }\n    });\n    console.log();\n\n    // Example 6: Query tasks with project information\n    console.log('🎯 Example 6: Tasks with project context');\n    console.log('─'.repeat(50));\n    const tasksWithProjects = await sdk.tasks.findMany({\n      where: { \n        done: false,\n        projectId: { isNotEmpty: true },\n      },\n      limit: 5,\n    });\n    \n    for (const task of tasksWithProjects) {\n      console.log(`  • ${task.name}`);\n      if (task.projectId) {\n        const project = await sdk.projects.findById(task.projectId);\n        if (project) {\n          console.log(`    Project: ${project.name} (${project.status})`);\n        }\n      }\n    }\n    console.log();\n\n    // Example 7: Using the query builder\n    console.log('🔧 Example 7: Advanced query with QueryBuilder');\n    console.log('─'.repeat(50));\n    const query = sdk.tasks.queryBuilder()\n      .where('done', 'equals', false)\n      .where('priority', 'equals', 'High')\n      .orderBy('due', 'ascending')\n      .limit(10);\n    \n    const advancedResults = await sdk.tasks.query(query);\n    console.log(`Found ${advancedResults.length} tasks with advanced query`);\n    advancedResults.forEach(task => {\n      console.log(`  • ${task.name}`);\n    });\n    console.log();\n\n    console.log('✨ All queries completed successfully!');\n\n  } catch (error) {\n    console.error('❌ Error:', error);\n    process.exit(1);\n  } finally {\n    console.log('\\n🔌 Disconnecting from MCP server...');\n    await sdk.disconnect();\n  }\n}\n\n// Run the example\nmain();"
    },
    {
      "path": "./examples/safety-layer-demo.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 225,
      "chars": 6713,
      "approxTokens": 1678.0,
      "sha256": "EEFB1504B4F5057EFEC5DBF97BB6222A64B944C95911850CD6E498995D3E175A",
      "content": "/**\n * Example: Using the Safety Layer Components\n * \n * This example demonstrates how to use the DiffEngine, BatchLimiter, \n * Validator, and ProposalManager components of the safety layer.\n */\n\nimport {\n  ProposalManager,\n  DiffEngine,\n  BatchLimiter,\n  Validator,\n  type ValidationRule,\n} from '../src/index.js';\nimport { DATABASE_IDS } from '../src/core/types/databases.js';\n\nasync function main() {\n  console.log('🛡️  Safety Layer Components Demo');\n  console.log('═'.repeat(70));\n  console.log();\n\n  // ========================================\n  // 1. DiffEngine - Compare State Changes\n  // ========================================\n  console.log('1️⃣  DiffEngine - Computing Property Diffs');\n  console.log('─'.repeat(70));\n  \n  const diffEngine = new DiffEngine();\n  \n  const currentTask = {\n    name: 'Update documentation',\n    priority: 'Low',\n    done: false,\n    due: new Date('2026-01-15'),\n  };\n  \n  const proposedTask = {\n    name: 'Update documentation',\n    priority: 'High',\n    done: false,\n    due: new Date('2026-01-10'),\n  };\n  \n  const diffs = diffEngine.computeDiff(currentTask, proposedTask);\n  \n  console.log(`\\nFound ${diffs.length} changes:\\n`);\n  console.log(diffEngine.formatAsMarkdown(diffs));\n  console.log(`\\nSummary: ${diffEngine.generateSummary(diffs)}`);\n  console.log();\n\n  // ========================================\n  // 2. Validator - Pre-change Validation\n  // ========================================\n  console.log('2️⃣  Validator - Validating Entity Data');\n  console.log('─'.repeat(70));\n  \n  const validator = new Validator();\n  \n  // Valid entity\n  const validTask = {\n    name: 'Implement feature',\n    priority: 'High',\n    due: '2026-01-20T00:00:00.000Z',\n  };\n  \n  const rules: ValidationRule[] = [\n    { field: 'name', required: true, minLength: 3 },\n    { field: 'priority', allowedValues: ['High', 'Medium', 'Low'] },\n    { field: 'due', type: 'string' },\n  ];\n  \n  const validResult = validator.validate(validTask, rules);\n  console.log(`\\nValidating valid task: ${validResult.valid ? '✅ PASS' : '❌ FAIL'}`);\n  \n  // Invalid entity\n  const invalidTask = {\n    name: 'AB', // too short\n    priority: 'VeryHigh', // invalid value\n  };\n  \n  const invalidResult = validator.validate(invalidTask, rules);\n  console.log(`\\nValidating invalid task: ${invalidResult.valid ? '✅ PASS' : '❌ FAIL'}`);\n  \n  if (!invalidResult.valid) {\n    console.log('\\nValidation Errors:');\n    invalidResult.errors.forEach((error) => console.log(`  ❌ ${error}`));\n  }\n  \n  // Warnings for suspicious changes\n  const warningResult = validator.generateWarnings(\n    { status: 'Active', done: true },\n    { status: 'Completed', done: false }\n  );\n  \n  if (warningResult.warnings.length > 0) {\n    console.log('\\n⚠️  Warnings:');\n    warningResult.warnings.forEach((warning) => console.log(`  ⚠️  ${warning}`));\n  }\n  console.log();\n\n  // ========================================\n  // 3. BatchLimiter - Enforce Batch Limits\n  // ========================================\n  console.log('3️⃣  BatchLimiter - Managing Bulk Operations');\n  console.log('─'.repeat(70));\n  \n  const batchLimiter = new BatchLimiter({\n    maxBatchSize: 50,\n    allowSplit: false,\n  });\n  \n  // Valid batch\n  const smallBatch = Array.from({ length: 25 }, (_, i) => ({ id: i }));\n  console.log(`\\nValidating batch of ${smallBatch.length} items:`);\n  console.log(`  ✅ Within limit: ${batchLimiter.isWithinLimit(smallBatch.length)}`);\n  \n  // Dry-run summary\n  const summary = batchLimiter.generateDryRunSummary(smallBatch.length);\n  console.log(`\\n${batchLimiter.formatSummary(summary)}`);\n  \n  // Try to exceed limit\n  const largeBatch = Array.from({ length: 75 }, (_, i) => ({ id: i }));\n  console.log(`\\n\\nValidating batch of ${largeBatch.length} items:`);\n  console.log(`  ❌ Within limit: ${batchLimiter.isWithinLimit(largeBatch.length)}`);\n  \n  try {\n    batchLimiter.validateBatchSize(largeBatch.length);\n  } catch (error) {\n    console.log(`  ❌ Error: ${(error as Error).message}`);\n  }\n  \n  // Execute a small batch\n  console.log('\\n\\nExecuting small batch...');\n  const result = await batchLimiter.executeBatch(\n    smallBatch.slice(0, 5),\n    async (item) => {\n      // Simulate processing\n      await new Promise((resolve) => setTimeout(resolve, 10));\n      return item.id;\n    }\n  );\n  \n  console.log(`\\n${batchLimiter.formatResult(result)}`);\n  console.log();\n\n  // ========================================\n  // 4. ProposalManager - Full Workflow\n  // ========================================\n  console.log('4️⃣  ProposalManager - Propose → Approve → Apply');\n  console.log('─'.repeat(70));\n  \n  const proposalManager = new ProposalManager();\n  \n  // Create a proposal\n  const proposal = await proposalManager.propose({\n    type: 'create',\n    target: { database: DATABASE_IDS.TASKS },\n    currentState: null,\n    proposedState: {\n      name: 'Implement safety layer',\n      priority: 'High',\n      done: false,\n    },\n    diff: diffs,\n    sideEffects: [\n      {\n        type: 'relation_update',\n        description: 'Will link to project',\n        affectedItems: ['project-123'],\n      },\n    ],\n    validation: { valid: true, errors: [], warnings: [] },\n  });\n  \n  console.log(`\\n✓ Proposal created: ${proposal.id}`);\n  console.log(`  Status: ${proposal.status}`);\n  console.log(`  Type: ${proposal.type}`);\n  \n  // Format for review\n  console.log('\\n' + proposalManager.formatForReview(proposal));\n  \n  // Try to apply without approval (should fail)\n  console.log('\\n⚠️  Attempting to apply without approval...');\n  try {\n    await proposalManager.apply(proposal.id, async () => 'mock-id');\n    console.log('  ❌ This should not happen!');\n  } catch (error) {\n    console.log(`  ✓ Correctly blocked: ${(error as Error).message}`);\n  }\n  \n  // Approve and apply\n  console.log('\\n✅ Approving proposal...');\n  proposalManager.approve(proposal.id);\n  console.log(`  Status: ${proposalManager.get(proposal.id)?.status}`);\n  \n  console.log('\\n🚀 Applying proposal...');\n  const applyResult = await proposalManager.apply(\n    proposal.id,\n    async () => 'entity-abc123'\n  );\n  \n  if (applyResult.success) {\n    console.log(`  ✅ Successfully applied!`);\n    console.log(`  Entity ID: ${applyResult.entityId}`);\n    console.log(`  Final status: ${proposalManager.get(proposal.id)?.status}`);\n  }\n  \n  // List all proposals\n  console.log('\\n\\n📋 All Proposals:');\n  const allProposals = proposalManager.list();\n  allProposals.forEach((p) => {\n    console.log(`  - ${p.id} (${p.type}): ${p.status}`);\n  });\n  \n  console.log();\n  console.log('═'.repeat(70));\n  console.log('✅ Demo complete!');\n  console.log();\n}\n\n// Run the demo\nmain().catch((error) => {\n  console.error('Error:', error);\n  process.exit(1);\n});"
    },
    {
      "path": "./examples/safety-workflow.ts",
      "category": "examples",
      "startLine": 1,
      "endLine": 237,
      "chars": 8050,
      "approxTokens": 2012.0,
      "sha256": "0312E304957EACE85609F22C66C7CEC18814E8AD4D311D9C4AA6698D048EAAB8",
      "content": "/**\r\n * Example: Safety Workflow (Propose → Approve → Apply)\r\n * \r\n * This example demonstrates the built-in safety workflow that prevents\r\n * accidental data loss by requiring explicit approval before mutations.\r\n * \r\n * The workflow has three phases:\r\n * 1. Propose: Generate a change proposal (no execution yet)\r\n * 2. Review: Inspect the proposed changes\r\n * 3. Approve & Apply: Execute only after explicit approval\r\n */\r\n\r\nimport { NotionistaSdk } from '../src';\r\n\r\n// Initialize the SDK\r\nconst sdk = new NotionistaSdk({\r\n  notionToken: process.env.NOTION_TOKEN!,\r\n  logLevel: 'info',\r\n});\r\n\r\nasync function main() {\r\n  try {\r\n    console.log('🔌 Connecting to Notion MCP server...\\n');\r\n    await sdk.connect();\r\n\r\n    // ========================================\r\n    // Example 1: Create a New Task\r\n    // ========================================\r\n    console.log('📝 Example 1: Creating a new task with safety workflow');\r\n    console.log('═'.repeat(60));\r\n    \r\n    // Phase 1: Propose the change (doesn't execute yet)\r\n    console.log('\\n🔵 Phase 1: PROPOSE');\r\n    console.log('─'.repeat(60));\r\n    const createProposal = await sdk.tasks.create({\r\n      name: 'Review safety workflow documentation',\r\n      priority: 'High',\r\n      due: new Date('2026-01-20'),\r\n    });\r\n    \r\n    console.log('✓ Proposal created (not yet executed)');\r\n    console.log(`  Proposal ID: ${createProposal.id}`);\r\n    console.log(`  Status: ${createProposal.status}`);\r\n    console.log();\r\n\r\n    // Phase 2: Review the proposed changes\r\n    console.log('🔵 Phase 2: REVIEW');\r\n    console.log('─'.repeat(60));\r\n    console.log(createProposal.formatForReview());\r\n    console.log();\r\n\r\n    // Simulating user review process\r\n    console.log('🤔 Reviewing proposed changes...');\r\n    console.log('   - Task name looks good ✓');\r\n    console.log('   - Priority is appropriate ✓');\r\n    console.log('   - Due date is reasonable ✓');\r\n    console.log('   → Decision: APPROVE\\n');\r\n\r\n    // Phase 3: Approve and apply\r\n    console.log('🔵 Phase 3: APPROVE & APPLY');\r\n    console.log('─'.repeat(60));\r\n    \r\n    await createProposal.approve();\r\n    console.log('✓ Proposal approved');\r\n    \r\n    const result = await createProposal.apply();\r\n    console.log('✓ Changes applied successfully');\r\n    console.log(`  Created task ID: ${result.id}`);\r\n    console.log(`  Task name: ${result.name}`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 2: Update a Task\r\n    // ========================================\r\n    console.log('\\n📝 Example 2: Updating an existing task');\r\n    console.log('═'.repeat(60));\r\n\r\n    // Phase 1: Propose update\r\n    console.log('\\n🔵 Phase 1: PROPOSE');\r\n    console.log('─'.repeat(60));\r\n    const updateProposal = await sdk.tasks.update(result.id, {\r\n      priority: 'Medium',\r\n      done: false,\r\n    });\r\n\r\n    console.log('✓ Update proposal created');\r\n    console.log();\r\n\r\n    // Phase 2: Review changes with diff\r\n    console.log('🔵 Phase 2: REVIEW (with diff)');\r\n    console.log('─'.repeat(60));\r\n    console.log(updateProposal.formatForReview());\r\n    \r\n    // Show the diff clearly\r\n    console.log('\\n📊 Property Changes:');\r\n    updateProposal.diff.forEach(change => {\r\n      console.log(`  ${change.property}:`);\r\n      console.log(`    - Old: ${JSON.stringify(change.oldValue)}`);\r\n      console.log(`    + New: ${JSON.stringify(change.newValue)}`);\r\n      console.log(`    Impact: ${change.impact}`);\r\n    });\r\n    console.log();\r\n\r\n    // Phase 3: Approve and apply\r\n    console.log('🔵 Phase 3: APPROVE & APPLY');\r\n    console.log('─'.repeat(60));\r\n    await updateProposal.approve();\r\n    await updateProposal.apply();\r\n    console.log('✓ Task updated successfully');\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 3: Rejecting a Proposal\r\n    // ========================================\r\n    console.log('\\n📝 Example 3: Rejecting a proposal');\r\n    console.log('═'.repeat(60));\r\n\r\n    console.log('\\n🔵 Phase 1: PROPOSE');\r\n    console.log('─'.repeat(60));\r\n    const rejectProposal = await sdk.tasks.update(result.id, {\r\n      done: true,  // Accidentally marking as done\r\n    });\r\n\r\n    console.log('✓ Proposal created');\r\n    console.log();\r\n\r\n    console.log('🔵 Phase 2: REVIEW');\r\n    console.log('─'.repeat(60));\r\n    console.log(rejectProposal.formatForReview());\r\n    console.log();\r\n\r\n    console.log('🤔 Reviewing proposed changes...');\r\n    console.log('   - Wait, this task isn\\'t actually done yet!');\r\n    console.log('   → Decision: REJECT\\n');\r\n\r\n    console.log('🔵 Phase 3: REJECT');\r\n    console.log('─'.repeat(60));\r\n    await rejectProposal.reject();\r\n    console.log('✓ Proposal rejected (no changes applied)');\r\n    console.log(`  Status: ${rejectProposal.status}`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 4: Batch Operations with Safety\r\n    // ========================================\r\n    console.log('\\n📝 Example 4: Batch operations with safety limits');\r\n    console.log('═'.repeat(60));\r\n\r\n    // Get some tasks to update\r\n    const tasksToUpdate = await sdk.tasks.findMany({\r\n      where: { done: false },\r\n      limit: 3,\r\n    });\r\n\r\n    console.log(`\\nFound ${tasksToUpdate.length} tasks to update in batch`);\r\n    console.log();\r\n\r\n    console.log('🔵 Phase 1: PROPOSE BATCH UPDATE');\r\n    console.log('─'.repeat(60));\r\n    \r\n    const batchProposal = await sdk.tasks.bulkUpdate(\r\n      tasksToUpdate.map(task => ({\r\n        id: task.id,\r\n        updates: { priority: 'Low' },\r\n      }))\r\n    );\r\n\r\n    console.log('✓ Batch proposal created');\r\n    console.log(`  Items in batch: ${batchProposal.items.length}`);\r\n    console.log(`  Status: ${batchProposal.status}`);\r\n    console.log();\r\n\r\n    console.log('🔵 Phase 2: REVIEW BATCH');\r\n    console.log('─'.repeat(60));\r\n    console.log(batchProposal.formatForReview());\r\n    console.log();\r\n\r\n    console.log('Batch Summary:');\r\n    console.log(`  • Total items: ${batchProposal.items.length}`);\r\n    console.log(`  • All priorities will change to: Low`);\r\n    console.log(`  • Estimated duration: ${batchProposal.estimatedDuration}ms`);\r\n    console.log();\r\n\r\n    console.log('🔵 Phase 3: APPROVE & APPLY BATCH');\r\n    console.log('─'.repeat(60));\r\n    await batchProposal.approve();\r\n    const batchResult = await batchProposal.apply();\r\n    \r\n    console.log('✓ Batch update completed');\r\n    console.log(`  Successful: ${batchResult.successful}`);\r\n    console.log(`  Failed: ${batchResult.failed}`);\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Example 5: Safety Violations\r\n    // ========================================\r\n    console.log('\\n📝 Example 5: Safety violations and limits');\r\n    console.log('═'.repeat(60));\r\n\r\n    try {\r\n      console.log('\\nAttempting to apply proposal without approval...');\r\n      const unsafeProposal = await sdk.tasks.create({\r\n        name: 'Unsafe task',\r\n      });\r\n      \r\n      // Try to apply without approving\r\n      await unsafeProposal.apply();\r\n      \r\n    } catch (error) {\r\n      console.log('❌ Error caught (as expected):');\r\n      console.log(`   ${error.message}`);\r\n      console.log('   → Proposals must be approved before applying');\r\n    }\r\n    console.log();\r\n\r\n    try {\r\n      console.log('Attempting batch update exceeding limit (max 50)...');\r\n      const tooManyItems = Array(51).fill(null).map((_, i) => ({\r\n        id: `task-${i}`,\r\n        updates: { priority: 'High' },\r\n      }));\r\n      \r\n      await sdk.tasks.bulkUpdate(tooManyItems);\r\n      \r\n    } catch (error) {\r\n      console.log('❌ Error caught (as expected):');\r\n      console.log(`   ${error.message}`);\r\n      console.log('   → Batch operations limited to 50 items for safety');\r\n    }\r\n    console.log();\r\n\r\n    // ========================================\r\n    // Cleanup: Delete the test task\r\n    // ========================================\r\n    console.log('\\n🧹 Cleanup: Deleting test task');\r\n    console.log('═'.repeat(60));"
    },
    {
      "path": "./examples/safety-workflow.ts",
      "category": "examples",
      "startLine": 238,
      "endLine": 274,
      "chars": 1272,
      "approxTokens": 318.0,
      "sha256": "1D4CEA29E6944A87DD6E8C347BAB2AD752F1A09BAF8260626950B00A0901FB9A",
      "content": "    const deleteProposal = await sdk.tasks.delete(result.id);\r\n    console.log('\\n🔵 Review deletion proposal:');\r\n    console.log(deleteProposal.formatForReview());\r\n    \r\n    await deleteProposal.approve();\r\n    await deleteProposal.apply();\r\n    console.log('✓ Test task deleted');\r\n    console.log();\r\n\r\n    console.log('═'.repeat(60));\r\n    console.log('✨ Safety workflow demonstration completed!');\r\n    console.log('═'.repeat(60));\r\n    console.log('\\n📚 Key Takeaways:');\r\n    console.log('   1. All mutations return proposals (not executed immediately)');\r\n    console.log('   2. Review proposals before approving');\r\n    console.log('   3. Proposals must be approved before applying');\r\n    console.log('   4. Batch operations have safety limits (max 50 items)');\r\n    console.log('   5. Proposals can be rejected to prevent unwanted changes');\r\n\r\n  } catch (error: unknown) {\r\n    if (error instanceof Error) {\r\n      console.error('\\n❌ Error:', error.message);\r\n      if (error.stack) {\r\n        console.error(error.stack);\r\n      }\r\n    } else {\r\n      console.error('\\n❌ Error:', error);\r\n    }\r\n    process.exit(1);\r\n  } finally {\r\n    console.log('\\n🔌 Disconnecting from MCP server...');\r\n    await sdk.disconnect();\r\n  }\r\n}\r\n\r\n// Run the example\r\nmain();"
    }
  ],
  "Index": {
    "TotalChunks": 88,
    "TotalTokens": 81107.0,
    "ByCategory": [
      {
        "category": "exports",
        "chunks": 1,
        "approxTokens": 304.0
      },
      {
        "category": "domain",
        "chunks": 13,
        "approxTokens": 10688.0
      },
      {
        "category": "query",
        "chunks": 7,
        "approxTokens": 9036.0
      },
      {
        "category": "mcp",
        "chunks": 14,
        "approxTokens": 7042.0
      },
      {
        "category": "safety",
        "chunks": 12,
        "approxTokens": 16556.0
      },
      {
        "category": "workflows",
        "chunks": 9,
        "approxTokens": 12386.0
      },
      {
        "category": "core",
        "chunks": 14,
        "approxTokens": 7643.0
      },
      {
        "category": "examples",
        "chunks": 12,
        "approxTokens": 15581.0
      },
      {
        "category": "schemas",
        "chunks": 6,
        "approxTokens": 1871.0
      }
    ]
  }
}
